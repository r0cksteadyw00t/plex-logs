**********************
PowerShell transcript start
Start time: 20251006172729
Username: MEDIASERVER\jason
RunAs User: MEDIASERVER\jason
Configuration Name: 
Machine: MEDIASERVER (Microsoft Windows NT 10.0.22631.0)
Host Application: C:\Program Files\PowerShell\7\pwsh.dll
Process ID: 18652
PSVersion: 7.5.3
PSEdition: Core
GitCommitId: 7.5.3
OS: Microsoft Windows 10.0.22631
Platform: Win32NT
PSCompatibleVersions: 1.0, 2.0, 3.0, 4.0, 5.0, 5.1, 6.0, 7.0
PSRemotingProtocolVersion: 2.3
SerializationVersion: 1.1.0.1
WSManStackVersion: 3.0
**********************
Transcript started, output file is D:\PlexTools\logs\s001_plex_remote_20251006_172729.log
S001: Plex Remote Access & NAT diagnostic and safe repair
Guardrails active: Secrets=C:\Users\jason\OneDrive\Public\TOKENS, HTTP-200 only, no destructive actions
  OK  Library path OK: Streaming Movies -> D:\StremioCatalog\_Hybrid\Movies
  OK  Library path OK: Streaming TV Shows -> D:\StremioCatalog\_Hybrid\Shows
  OK  Library path OK: ScarFLIX - Movie Request -> D:\ScarFLIX\Wishlist\Movies
  OK  Library path OK: ScarFLIX - Shows Request -> D:\ScarFLIX\Wishlist\TV
  OK  Backed up Preferences.xml to: C:\Users\jason\AppData\Local\Plex Media Server\Preferences_Backups\Preferences_20251006_172729.xml
  OK  Preferences updated safely.
  OK  Plex restarted from: C:\Program Files\Plex\Plex Media Server\Plex Media Server.exe
PS>TerminatingError(Invoke-WebRequest): "Unable to read data from the transport connection: An existing connection was forcibly closed by the remote host.."
PS>TerminatingError(Invoke-WebRequest): "
<Response
  code="503"
  title="Maintenance"
  status="Plex Media Server is currently running startup maintenance tasks." />"
  WARN Identity failed (status=-1, An error occurred while sending the request.)
  WARN Resources failed (status=-1, Response status code does not indicate success: 503 (Service Unavailable).)
  OK  Firewall inbound rule for 32400 present.
===== S001 SUMMARY =====
Remote Access state: Relay
Preferences before:
ManualPortMappingMode = 1
RemoteAccessEnabled =
InternetStreamPort =
PreferredNetworkInterface =
CustomConnections =
Preferences after:
ManualPortMappingMode = 1
RemoteAccessEnabled = 1
InternetStreamPort =
PreferredNetworkInterface =
CustomConnections =
PS>TerminatingError(): "Cannot convert value "ms" to type "System.Int32". Error: "The input string 'ms' was not in a correct format.""
  ERR  S001 crash: Cannot convert value "ms" to type "System.Int32". Error: "The input string 'ms' was not in a correct format."
Transcript started, output file is D:\PlexTools\logs\s002_scheduler_20251006_172740.log
S002: Scheduler audit and self-heal
PS>TerminatingError(Get-ScheduledTask): "The running command stopped because the preference variable "ErrorActionPreference" or common parameter is set to Stop: No MSFT_ScheduledTask objects found with property 'TaskName' equal to 'PS Smart Bridge'.  Verify the value of the property and retry."
PS>TerminatingError(Register-ScheduledTask): "Cannot process argument transformation on parameter 'RunLevel'. Cannot convert value "LeastPrivilege" to type "Microsoft.PowerShell.Cmdletization.GeneratedTypes.ScheduledTask.RunLevelEnum". Error: "Unable to match the identifier name LeastPrivilege to a valid enumerator name. Specify one of the following enumerator names and try again:
Limited, Highest""
  WARN Create failed for task PS Smart Bridge: Cannot process argument transformation on parameter 'RunLevel'. Cannot convert value "LeastPrivilege" to type "Microsoft.PowerShell.Cmdletization.GeneratedTypes.ScheduledTask.RunLevelEnum". Error: "Unable to match the identifier name LeastPrivilege to a valid enumerator name. Specify one of the following enumerator names and try again:
Limited, Highest"
PS>TerminatingError(New-ScheduledTaskTrigger): "A positional parameter cannot be found that accepts argument '6/10/2025 5:28:42 PM'."
  WARN Could not build action/trigger for RD Queue Processor (per-user): A positional parameter cannot be found that accepts argument '6/10/2025 5:28:42 PM'.
===== S002 SUMMARY =====
OK tasks       :
Healed tasks   :
Quarantined    :
Warnings       : 2
A001: complete. See logs in D:\PlexTools\logs and ledger at D:\PlexTools\logs\job_ledger.csv
PS C:\Windows\System32> cls
PS C:\Windows\System32> # ====================== A001 HOTFIX: S001 + S002 (relay harden + scheduler fixes) ======================
# Guardrails: TOKENS at C:\Users\jason\OneDrive\Public\TOKENS, HTTP-200-only, library paths read-only verify
# Output: human-readable summaries, logs in D:\PlexTools\logs, short ledger lines
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Continue'

# --- Paths ---
$VaultDir  = 'C:\Users\jason\OneDrive\Public\TOKENS'
$LogsDir   = 'D:\PlexTools\logs'
$LedgerCsv = Join-Path $LogsDir 'job_ledger.csv'
if(-not (Test-Path $LogsDir)){ New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }
$UtsNow = [DateTime]::UtcNow.ToString('yyyy-MM-ddTHH:mm:ssZ')

# --- Console helpers ---
function Say([string]$m){ Write-Host $m -ForegroundColor Cyan }
function Ok([string]$m){ Write-Host ("  OK  {0}" -f $m) -ForegroundColor Green }
function Warn([string]$m){ Write-Host ("  WARN {0}" -f $m) -ForegroundColor Yellow }
function Err([string]$m){ Write-Host ("  ERR  {0}" -f $m) -ForegroundColor Red }

# --- Ledger appender ---
function Append-Ledger([string]$JobId, [string]$Status, [int]$WarnCount, [string]$LogPath, [string]$Notes){
  try{
    if(-not (Test-Path $LedgerCsv)){
      "utc_iso,job_id,status,warnings_count,log_path,notes" | Out-File -FilePath $LedgerCsv -Encoding UTF8 -Append
    }
    $clean = ($Notes -replace '"','''')
    '{0},{1},{2},{3},"{4}","{5}"' -f $UtsNow,$JobId,$Status,$WarnCount,$LogPath,$clean |
      Out-File -FilePath $LedgerCsv -Encoding UTF8 -Append
  } catch { Err "Ledger append failed: $($_.Exception.Message)" }
}

# --- HTTP-200 test (defensive) ---
function Test-Http200 {
  param([Parameter(Mandatory=$true)][string]$Url,[string]$Token)
  $sw = [System.Diagnostics.Stopwatch]::StartNew()
  try{
    try {
      [System.Net.ServicePointManager]::Expect100Continue = $false
      $sp = [System.Net.ServicePointManager]::SecurityProtocol
      if(($sp -band [Net.SecurityProtocolType]::Tls12) -eq 0){
        [System.Net.ServicePointManager]::SecurityProtocol = $sp -bor [Net.SecurityProtocolType]::Tls12
      }
    } catch {}
    $headers=@{}; if($Token){$headers['X-Plex-Token']=$Token}
    $resp = Invoke-WebRequest -Uri $Url -Headers $headers -Method Get -TimeoutSec 6 -MaximumRedirection 0 -ErrorAction Stop
    $sw.Stop()
    [PSCustomObject]@{ ok=($resp.StatusCode -eq 200); status=[int]$resp.StatusCode; ms=[int]$sw.Elapsed.TotalMilliseconds; error=$null }
  } catch {
    $sw.Stop()
    [PSCustomObject]@{ ok=$false; status=-1; ms=[int]$sw.Elapsed.TotalMilliseconds; error=$_.Exception.Message }
  }
}

function Get-LastLines { param([string]$Path,[int]$Lines=500)
  if(Test-Path $Path){ Get-Content -LiteralPath $Path -Tail $Lines -ErrorAction SilentlyContinue } else { @() }
}

# =================================== S001: Plex NAT diagnostic + safe repair ===================================
function Run-S001 {
  $jobId='S001'; $warn=0
  $stamp=(Get-Date).ToString('yyyyMMdd_HHmmss')
  $LogPath=Join-Path $LogsDir ("s001_plex_remote_{0}.log" -f $stamp)
  try{ Start-Transcript -Path $LogPath -Append -ErrorAction Stop }catch{ Warn "Transcript start failed: $($_.Exception.Message)"; $warn++ }

  Say "S001: Plex Remote Access & NAT diagnostic and safe repair"
  Say "Guardrails: TOKENS=$VaultDir, HTTP-200-only, no destructive actions"

  $PlexData = Join-Path $env:LOCALAPPDATA 'Plex Media Server'
  $PrefPath = Join-Path $PlexData 'Preferences.xml'
  $PmsLog   = Join-Path (Join-Path $PlexData 'Logs') 'Plex Media Server.log'
  if(-not (Test-Path $PlexData)){ Warn "Plex data directory not found: $PlexData"; $warn++ }
  if(-not (Test-Path $PrefPath)){ Warn "Preferences.xml not found: $PrefPath"; $warn++ }

  # Optional token
  $Token = $null
  $PlexTokenPath = Join-Path $VaultDir 'plex_token.txt'
  if(Test-Path $PlexTokenPath){
    try{ $Token=(Get-Content -LiteralPath $PlexTokenPath -Raw).Trim() }catch{ Warn "Could not read plex_token.txt: $($_.Exception.Message)"; $warn++ }
  } else { Warn "No plex_token.txt in vault. Running degraded local checks."; $warn++ }

  # Read-only library path verification
  foreach($it in @(
    @{n='Streaming Movies'; p='D:\StremioCatalog\_Hybrid\Movies'},
    @{n='Streaming TV Shows'; p='D:\StremioCatalog\_Hybrid\Shows'},
    @{n='ScarFLIX - Movie Request'; p='D:\ScarFLIX\Wishlist\Movies'},
    @{n='ScarFLIX - Shows Request'; p='D:\ScarFLIX\Wishlist\TV'}
  )){
    if(Test-Path $it.p){ Ok ("Library path OK: {0} -> {1}" -f $it.n,$it.p) } else { Warn ("Library path missing: {0} -> {1}" -f $it.n,$it.p); $warn++ }
  }

  $before=[ordered]@{}; $after=[ordered]@{}; $changed=$false
  if(Test-Path $PrefPath){
    try{
      $BackupDir = Join-Path $PlexData 'Preferences_Backups'
      if(-not (Test-Path $BackupDir)){ New-Item -ItemType Directory -Path $BackupDir -Force | Out-Null }
      $BackupPath = Join-Path $BackupDir ("Preferences_{0}.xml" -f $stamp)
      Copy-Item $PrefPath $BackupPath -Force
      Ok "Backup saved: $BackupPath"

      [xml]$x = Get-Content -LiteralPath $PrefPath -Raw
      $pref = $x.Preferences
      function GetA([string]$k){ try{ $pref.GetAttribute($k) }catch{ $null } }
      function SetA([string]$k,[string]$v){ try{ $pref.SetAttribute($k,$v) }catch{} }

      $keys='ManualPortMappingMode','RemoteAccessEnabled','InternetStreamPort','PreferredNetworkInterface','CustomConnections'
      foreach($k in $keys){ $before[$k]=(GetA $k) }

      # Look at logs to see if UPnP/NAT-PMP is failing
      $last = Get-LastLines -Path $PmsLog -Lines 500
      $autoFail = ($last -match 'UPnP.*failed' -or $last -match 'NAT-PMP.*failed' -or $last -match 'mapping.*failed')

      # Ensure remote access is enabled
      if((GetA 'RemoteAccessEnabled') -ne '1'){ SetA 'RemoteAccessEnabled' '1'; $changed=$true }

      # If manual mode is active (or auto fails), ensure port is set
      $manualMode = ((GetA 'ManualPortMappingMode') -eq '1') -or $autoFail
      if($autoFail -and (GetA 'ManualPortMappingMode') -ne '1'){ SetA 'ManualPortMappingMode' '1'; $changed=$true; Warn "Auto mapping failures detected; switching to ManualPortMappingMode=1"; $warn++ }
      if($manualMode){
        $curPort = (GetA 'InternetStreamPort')
        if([string]::IsNullOrWhiteSpace($curPort) -or ($curPort -notmatch '^\d+$')){
          SetA 'InternetStreamPort' '32400'; $changed=$true; Ok "Set InternetStreamPort=32400 for manual mapping"
        }
      }

      foreach($k in $keys){ $after[$k]=(GetA $k) }

      if($changed){
        $x.Save($PrefPath)
        # Try a soft restart
        try{
          $p = Get-Process -Name 'Plex Media Server' -ErrorAction SilentlyContinue | Select-Object -First 1
          if($p){ Stop-Process -Id $p.Id -ErrorAction SilentlyContinue; Start-Sleep -Milliseconds 800 }
          $exe = @(
            'C:\Program Files\Plex\Plex Media Server\Plex Media Server.exe',
            'C:\Program Files (x86)\Plex\Plex Media Server\Plex Media Server.exe'
          ) | Where-Object { Test-Path $_ } | Select-Object -First 1
          if($exe){ Start-Process -FilePath $exe | Out-Null; Ok "Plex restarted: $exe" } else { Warn "Could not locate Plex executable for restart"; $warn++ }
        } catch { Warn "Restart failed: $($_.Exception.Message)"; $warn++ }
      } else { Ok "No preference changes required" }
    } catch { Err "Preferences handling failed: $($_.Exception.Message)"; $warn++ }
  }

  # Local HTTP checks
  $iden = Test-Http200 -Url 'http://127.0.0.1:32400/identity' -Token $Token
  $stat = Test-Http200 -Url 'http://127.0.0.1:32400/statistics/resources' -Token $Token

  if($iden.ok){ Ok ("Identity 200 in {0} ms" -f $iden.ms) } else { Warn ("Identity failed (status={0}, {1})" -f $iden.status, ($iden.error ?? 'n/a')); $warn++ }
  if($stat.ok){ Ok ("Resources 200 in {0} ms" -f $stat.ms) } else { Warn ("Resources failed (status={0}, {1})" -f $stat.status, ($stat.error ?? 'n/a')); $warn++ }

  # NAT evidence
  $status='Unknown'; $recent=Get-LastLines -Path $PmsLog -Lines 400
  if($recent.Count -gt 0){
    $mapped = ($recent -match 'is available outside your network' -or $recent -match 'Mapped external port')
    $relay  = ($recent -match 'relay')
    $failed = ($recent -match 'failed')
    if($mapped){ $status='Mapped' } elseif($relay -and -not $mapped){ $status='Relay' } elseif($failed){ $status='Failed' }
  } else { Warn "Could not read recent NAT evidence from Plex log"; $warn++ }

  # Firewall audit
  try{
    $fwRules = Get-NetFirewallRule -ErrorAction Stop | Where-Object { $_.DisplayName -like '*Plex*' -and $_.Direction -eq 'Inbound' }
    $portOk=$false
    foreach($r in $fwRules){
      $pf = Get-NetFirewallPortFilter -AssociatedNetFirewallRule $r -ErrorAction SilentlyContinue
      if($pf -and ($pf.LocalPort -contains 32400)){ $portOk=$true }
    }
    if($portOk){ Ok "Firewall inbound rule for TCP 32400 present" } else { Warn "No inbound firewall rule for TCP 32400 detected"; $warn++ }
  } catch { Warn "Firewall query failed: $($_.Exception.Message)"; $warn++ }

  # Summary
  Say "===== S001 SUMMARY ====="
  Write-Host ("Remote Access state: {0}" -f $status)
  if($before.Count -gt 0){
    Write-Host "Preferences before:";  $before.GetEnumerator()|ForEach-Object{ "{0} = {1}" -f $_.Key,($_.Value) } | Write-Host
    Write-Host "Preferences after:";   $after.GetEnumerator() |ForEach-Object{ "{0} = {1}" -f $_.Key,($_.Value) } | Write-Host
  }
  Write-Host ("HTTP check: identity={0} ({1}ms), resources={2} ({3}ms)" -f ($iden.status), ([string]$iden.ms), ($stat.status), ([string]$stat.ms))
  Write-Host ("Warnings: {0}" -f $warn)

  try{ Stop-Transcript | Out-Null }catch{}

  # Ledger
  $notes = "NAT=$status; identity=$($iden.status); resources=$($stat.status)"
  Append-Ledger -JobId $jobId -Status 'done' -WarnCount $warn -LogPath $LogPath -Notes $notes
}

# =================================== S002: Scheduler audit & self-heal ===================================
function Run-S002 {
  $jobId='S002'; $warn=0
  $stamp=(Get-Date).ToString('yyyyMMdd_HHmmss')
  $LogPath=Join-Path $LogsDir ("s002_scheduler_{0}.log" -f $stamp)
  try{ Start-Transcript -Path $LogPath -Append -ErrorAction Stop }catch{ Warn "Transcript start failed: $($_.Exception.Message)"; $warn++ }

  Say "S002: Scheduler audit and self-heal"

  $desired = @(
    [PSCustomObject]@{
      Name='PS Smart Bridge'
      Script='D:\PlexTools\TamperBridge\bridge.ps1'
      Args='-NoProfile -ExecutionPolicy Bypass -File "D:\PlexTools\TamperBridge\bridge.ps1"'
      Trigger='Logon'
      IntervalMins=$null
      WorkDir='D:\PlexTools\TamperBridge'
      Description='Starts the localhost HTTP Smart Bridge at user logon'
    },
    [PSCustomObject]@{
      Name='RD Queue Processor (per-user)'
      Script='D:\PlexTools\Scripts\rd_queue_worker.ps1'
      Args='-NoProfile -ExecutionPolicy Bypass -File "D:\PlexTools\Scripts\rd_queue_worker.ps1"'
      Trigger='Repeat'
      IntervalMins=15
      WorkDir='D:\PlexTools\Scripts'
      Description='Processes RD queue every 15 minutes'
    }
  )

  $ok=@(); $healed=@(); $quar=@()

  foreach($td in $desired){
    $exists=$false; try{ Get-ScheduledTask -TaskName $td.Name -ErrorAction Stop | Out-Null; $exists=$true }catch{}
    if(-not (Test-Path $td.Script)){
      Warn ("Script missing: {0}" -f $td.Script)
      if($exists){ try{ Disable-ScheduledTask -TaskName $td.Name -ErrorAction SilentlyContinue | Out-Null }catch{} }
      $quar += $td.Name; $warn++; continue
    }

    # Build action (fallback if WorkingDirectory not supported)
    $act=$null
    try{ $act=New-ScheduledTaskAction -Execute 'powershell.exe' -Argument $td.Args -WorkingDirectory $td.WorkDir }
    catch{ $act=New-ScheduledTaskAction -Execute 'powershell.exe' -Argument $td.Args }

    # Build trigger with corrected syntax
    if($td.Trigger -eq 'Logon'){
      $trg = New-ScheduledTaskTrigger -AtLogOn
    } else {
      $start=(Get-Date).AddMinutes(1)
      $trg = New-ScheduledTaskTrigger -Once -At $start -RepetitionInterval (New-TimeSpan -Minutes $td.IntervalMins) -RepetitionDuration ([TimeSpan]::FromDays(36500))
    }

    # Create or update with RunLevel 'Limited'
    if(-not $exists){
      try{
        Register-ScheduledTask -TaskName $td.Name -Action $act -Trigger $trg -Description $td.Description -RunLevel 'Limited' | Out-Null
        Ok ("Created task: {0}" -f $td.Name); $healed += $td.Name
      } catch { Warn ("Create failed for {0}: {1}" -f $td.Name, $_.Exception.Message); $warn++; continue }
    } else {
      $needsUpdate=$false
      try{
        $info = Get-ScheduledTask -TaskName $td.Name
        $actOk = ($info.Actions.Execute -contains 'powershell.exe') -and ($info.Actions.Arguments -match [Regex]::Escape($td.Script))
        $trgOk = if($td.Trigger -eq 'Logon'){ ($info.Triggers.TriggerType -contains 'Logon') } else { ($info.Triggers.Repetition.Interval -match '00:15:00') }
        if(-not ($actOk -and $trgOk)){ $needsUpdate=$true }
      } catch { $needsUpdate=$true }

      if($needsUpdate){
        try{
          Register-ScheduledTask -TaskName $td.Name -Action $act -Trigger $trg -Description $td.Description -RunLevel 'Limited' -Force | Out-Null
          Ok ("Updated task: {0}" -f $td.Name); $healed += $td.Name
        } catch { Warn ("Update failed for {0}: {1}" -f $td.Name, $_.Exception.Message); $warn++ }
      } else { $ok += $td.Name }
    }

    # Smoke run for created/updated tasks
    if($healed -contains $td.Name){
      try{
        Start-ScheduledTask -TaskName $td.Name -ErrorAction Stop
        Start-Sleep -Seconds 5
        $sti = Get-ScheduledTaskInfo -TaskName $td.Name
        Ok ("Smoke run: {0} => LastTaskResult={1}, State={2}" -f $td.Name, $sti.LastTaskResult, $sti.State)
      } catch { Warn ("Smoke run failed for {0}: {1}" -f $td.Name, $_.Exception.Message); $warn++ }
    }
  }

  Say "===== S002 SUMMARY ====="
  Write-Host ("OK tasks       : {0}" -f (($ok | Sort-Object) -join ', '))
  Write-Host ("Healed tasks   : {0}" -f (($healed | Sort-Object) -join ', '))
  Write-Host ("Quarantined    : {0}" -f (($quar | Sort-Object) -join ', '))
  Write-Host ("Warnings       : {0}" -f $warn)

  try{ Stop-Transcript | Out-Null }catch{}
  $notes = "ok={0}; healed={1}; quarantined={2}" -f ($ok.Count),($healed.Count),($quar.Count)
  Append-Ledger -JobId $jobId -Status 'done' -WarnCount $warn -LogPath $LogPath -Notes $notes
}

# =================================== RUN A001 HOTFIX ===================================
Say "A001 Hotfix: starting S001 then S002 (continue on error)"
try{ Run-S001 }catch{ Err "S001 crash: $($_.Exception.Message)"; Append-Ledger -JobId 'S001' -Status 'error' -WarnCount 1 -LogPath (Join-Path $LogsDir 's001_error.txt') -Notes 'Unhandled exception' }
try{ Run-S002 }catch{ Err "S002 crash: $($_.Exception.Message)"; Append-Ledger -JobId 'S002' -Status 'error' -WarnCount 1 -LogPath (Join-Path $LogsDir 's002_error.txt') -Notes 'Unhandled exception' }
Say "A001 Hotfix complete. See logs in $LogsDir and ledger at $LedgerCsv"
# ====================== END A001 HOTFIX ======================

A001 Hotfix: starting S001 then S002 (continue on error)
Transcript started, output file is D:\PlexTools\logs\s001_plex_remote_20251006_173431.log
S001: Plex Remote Access & NAT diagnostic and safe repair
Guardrails: TOKENS=C:\Users\jason\OneDrive\Public\TOKENS, HTTP-200-only, no destructive actions
  OK  Library path OK: Streaming Movies -> D:\StremioCatalog\_Hybrid\Movies
  OK  Library path OK: Streaming TV Shows -> D:\StremioCatalog\_Hybrid\Shows
  OK  Library path OK: ScarFLIX - Movie Request -> D:\ScarFLIX\Wishlist\Movies
  OK  Library path OK: ScarFLIX - Shows Request -> D:\ScarFLIX\Wishlist\TV
  OK  Backup saved: C:\Users\jason\AppData\Local\Plex Media Server\Preferences_Backups\Preferences_20251006_173431.xml
  OK  Set InternetStreamPort=32400 for manual mapping
  OK  Plex restarted: C:\Program Files\Plex\Plex Media Server\Plex Media Server.exe
PS C:\Windows\System32> TerminatingError(Invoke-WebRequest): "Unable to read data from the transport connection: An existing connection was forcibly closed by the remote host.."
PS C:\Windows\System32> TerminatingError(Invoke-WebRequest): "
<Response
  code="503"
  title="Maintenance"
  status="Plex Media Server is currently running startup maintenance tasks." />"
  WARN Identity failed (status=-1, An error occurred while sending the request.)
  WARN Resources failed (status=-1, Response status code does not indicate success: 503 (Service Unavailable).)
  OK  Firewall inbound rule for TCP 32400 present
===== S001 SUMMARY =====
Remote Access state: Relay
Preferences before:
ManualPortMappingMode = 1
RemoteAccessEnabled = 1
InternetStreamPort =
PreferredNetworkInterface =
CustomConnections =
Preferences after:
ManualPortMappingMode = 1
RemoteAccessEnabled = 1
InternetStreamPort = 32400
PreferredNetworkInterface =
CustomConnections =
HTTP check: identity=-1 (1105ms), resources=-1 (12ms)
Warnings: 2
Transcript started, output file is D:\PlexTools\logs\s002_scheduler_20251006_173439.log
S002: Scheduler audit and self-heal
PS C:\Windows\System32> TerminatingError(Get-ScheduledTask): "The running command stopped because the preference variable "ErrorActionPreference" or common parameter is set to Stop: No MSFT_ScheduledTask objects found with property 'TaskName' equal to 'PS Smart Bridge'.  Verify the value of the property and retry."
  OK  Created task: PS Smart Bridge
  WARN Smoke run failed for PS Smart Bridge: The property 'State' cannot be found on this object. Verify that the property exists.
Register-ScheduledTask: 
Line |
 257 |            Register-ScheduledTask -TaskName $td.Name -Action $act -Tri â€¦
     |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | The task XML contains a value which is incorrectly formatted or out of range.

(10,29):Duration:P36500D
Register-ScheduledTask: 
Line |
 257 |            Register-ScheduledTask -TaskName $td.Name -Action $act -Tri â€¦
     |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | The task XML contains a value which is incorrectly formatted or out of range.

(10,29):Duration:P36500D
  OK  Updated task: RD Queue Processor (per-user)
  WARN Smoke run failed for RD Queue Processor (per-user): The property 'State' cannot be found on this object. Verify that the property exists.
===== S002 SUMMARY =====
OK tasks       :
Healed tasks   : PS Smart Bridge, RD Queue Processor (per-user)
Quarantined    :
Warnings       : 2
A001 Hotfix complete. See logs in D:\PlexTools\logs and ledger at D:\PlexTools\logs\job_ledger.csv
PS C:\Windows\System32> cls
PS C:\Windows\System32> # ==== ONE-CLICK: Torrentio DIAG + Adaptive Populate (no prompts, hardcoded-first honored) ====
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# Paths
$Root     = 'D:\PlexTools'
$Scripts  = Join-Path $Root 'scripts'
$Logs     = Join-Path $Root 'logs'
$Cache    = Join-Path $Root 'cache'
$Populate = Join-Path $Scripts 'Populate.js'
$Runner   = Join-Path $Scripts 'Run_Populate.ps1'

function OK($m){ Write-Host "[OK]  $m" -ForegroundColor Green }
function INFO($m){ Write-Host "[..]  $m" -ForegroundColor Cyan }
function WARN($m){ Write-Host "[WARN] $m" -ForegroundColor Yellow }
[IO.Directory]::CreateDirectory($Scripts)|Out-Null
[IO.Directory]::CreateDirectory($Logs)|Out-Null
[IO.Directory]::CreateDirectory($Cache)|Out-Null

# --- 1) Write a quick Torrentio diagnostic (movie + series) using current STREAMS_URL/RD token ---
$Diag = @'
param()
$Vault = "C:\Users\jason\OneDrive\Public\TOKENS"

function FirstVal($envName,$file){
  $v = $env:$envName
  if([string]::IsNullOrWhiteSpace($v) -and (Test-Path $file)){
    try{ $t=(Get-Content -LiteralPath $file -Raw).Trim(); if($t){ $v=$t } }catch{}
  }
  return ($v | ForEach-Object { $_.Trim() })
}

$RAW = FirstVal 'STREAMS_URL' (Join-Path $Vault 'stremio_streams_url.txt')
$RD  = FirstVal 'RD_TOKEN'    (Join-Path $Vault 'realdebrid_token.txt')

# Parse piped URL -> base + querystring
function Parse-Streams([string]$s){
  if([string]::IsNullOrWhiteSpace($s)){ return @{ base='https://torrentio.strem.fun'; qs='' } }
  $parts = $s.Trim().Split('|') | Where-Object { $_ -ne '' }
  $m = [regex]::Match($parts[0], '^https?://[^/|]+', 'IgnoreCase')
  $base = if($m.Success){ $m.Value } else { 'https://torrentio.strem.fun' }
  $params = @{}
  function AddKV([string]$seg){
    $m2 = [regex]::Match($seg, '^\s*([^=/?]+)=([\s\S]+?)\s*$')
    if($m2.Success){ $params[$m2.Groups[1].Value] = $m2.Groups[2].Value }
  }
  $rest = $parts[0].Substring([Math]::Min($parts[0].Length,$base.Length))
  foreach($seg in ($rest.Split('/') | Where-Object { $_ })){ if($seg -like '*=*'){ AddKV $seg } }
  for($i=1;$i -lt $parts.Count;$i++){ AddKV $parts[$i] }
  if($RD -and -not $params.ContainsKey('realdebrid')){ $params['realdebrid'] = $RD }
  $qs = ($params.Keys | ForEach-Object { [uri]::EscapeDataString($_)+'='+[uri]::EscapeDataString($params[$_]) }) -join '&'
  return @{ base=$base; qs=$qs }
}

$P = Parse-Streams $RAW
Write-Host "[DIAG] Base: $($P.base)" -ForegroundColor Cyan
Write-Host "[DIAG] QS:   $($P.qs)"   -ForegroundColor Cyan

# Known titles
$tests = @(
  @{ type='movie';  id='tt1375666'; name='Inception' },
  @{ type='series'; id='tt0903747:1:1'; name='Breaking Bad S1E1' }
)

foreach($t in $tests){
  $url = ("{0}/stream/{1}/{2}.json{3}" -f $P.base.TrimEnd('/'), $t.type, [uri]::EscapeDataString($t.id), ($P.qs ? ('?'+$P.qs) : ''))
  try{
    $resp = Invoke-WebRequest -UseBasicParsing -Uri $url -TimeoutSec 10
    $j = $null
    try{ $j = $resp.Content | ConvertFrom-Json }catch{}
    $arr = @()
    if($j -is [System.Collections.IEnumerable]){ $arr = @($j) }
    elseif($j.streams){ $arr = @($j.streams) }
    Write-Host ("[DIAG] {0} -> {1} streams" -f $t.name, $arr.Count) -ForegroundColor Green
    $i=0; foreach($s in $arr){ if($null -ne $s.url){ $i++; Write-Host ("       {0}. {1}" -f $i, $s.url); if($i -ge 3){ break } } }
  } catch {
    Write-Host ("[DIAG] {0} -> request failed: {1}" -f $t.name, $_.Exception.Message) -ForegroundColor Yellow
  }
}
'@
$DiagPath = Join-Path $Scripts 'Diag_Torrentio.ps1'
Set-Content -LiteralPath $DiagPath -Value $Diag -Encoding ASCII
OK "Wrote $DiagPath"

# --- 2) Patch Populate.js for ADAPTIVE fallback (tries your strict QS, then progressively loosens if needed) ---
$AdaptivePopulate = @'
/* Populate.js (adaptive) â€” IMDb IDs + piped STREAMS_URL parser + adaptive QS variants + reason logs */
const fs = require('fs');
const path = require('path');
const https = require('https');

function log(m){ process.stdout.write('['+new Date().toISOString()+'] '+m+'\n'); }
function ensureDir(p){ try{ if(p && !fs.existsSync(p)) fs.mkdirSync(p,{recursive:true}); }catch(_){} }

const TOKENS_DIR = 'C:\\Users\\jason\\OneDrive\\Public\\TOKENS';
const HARDCODED = { TMDB:(process.env.TMDB_KEY||''), STREAMS:(process.env.STREAMS_URL||''), RD:(process.env.RD_TOKEN||'') };

function firstVal(name, hard, fileName){
  if (hard && String(hard).trim()) return hard;
  if (process.env[name] && String(process.env[name]).trim()) return process.env[name];
  try{ const p = path.join(TOKENS_DIR, fileName);
       if (fs.existsSync(p)){ const t = String(fs.readFileSync(p,'utf8')).trim(); if (t) return t; } }catch(_){}
  return '';
}

const TMDB_KEY    = firstVal('TMDB_KEY',    HARDCODED.TMDB,    'tmdb_api_key.txt');
const RAW_STREAMS = firstVal('STREAMS_URL', HARDCODED.STREAMS, 'stremio_streams_url.txt');
const RD_TOKEN    = firstVal('RD_TOKEN',    HARDCODED.RD,      'realdebrid_token.txt');

function parseStreams(s){
  if(!s) return { base:'https://torrentio.strem.fun', params:{} };
  const parts = String(s).trim().split('|').filter(Boolean);
  const m = parts[0].match(/^https?:\/\/[^\/|]+/i);
  const base = m ? m[0] : 'https://torrentio.strem.fun';
  const params = {};
  const addKV = seg => { const k = seg.match(/^\s*([^=\/?]+)=/); if(!k) return;
                         const kv = seg.split('='); params[kv[0].trim()] = kv.slice(1).join('=').trim(); };
  const rest = parts[0].slice(base.length);
  rest.split('/').filter(Boolean).forEach(seg => { if(seg.includes('=')) addKV(seg); });
  for (let i=1;i<parts.length;i++) addKV(parts[i]);
  if (RD_TOKEN && !params.realdebrid) params.realdebrid = RD_TOKEN;
  return { base, params };
}
const ST = parseStreams(RAW_STREAMS);

function encodeQS(obj){
  return Object.keys(obj).map(k => encodeURIComponent(k)+'='+encodeURIComponent(obj[k])).join('&');
}

// Build adaptive QS variants (strict first, then loosen)
function buildQsVariants(p){
  const strict = Object.assign({}, p.params);
  const v = [];
  // 0) original (strict)
  v.push(strict);
  // 1) bump limit if very low
  const lim = Object.assign({}, strict); if (!lim.limit || Number(lim.limit) < 10) lim.limit = 10; v.push(lim);
  // 2) drop qualityfilter but keep other params
  const qOff = Object.assign({}, strict); delete qOff.qualityfilter; v.push(qOff);
  // 3) bump + drop qualityfilter
  const qOffHi = Object.assign({}, qOff); if (!qOffHi.limit || Number(qOffHi.limit) < 15) qOffHi.limit = 15; v.push(qOffHi);
  return v;
}
const QS_VARIANTS = buildQsVariants(ST);

// HTTP helpers
function httpGet(url, timeoutMs=7000){
  return new Promise((resolve,reject)=>{
    try{
      const req = https.get(url, (res)=>{ let d=''; res.on('data', c=> d+=c); res.on('end', ()=> resolve({status:res.statusCode||0, body:d})); });
      req.setTimeout(timeoutMs, ()=>{ try{ req.destroy(new Error('timeout '+timeoutMs+'ms')); }catch(_){ } });
      req.on('error', reject);
    }catch(e){ reject(e); }
  });
}
async function httpGetJson(url, timeoutMs=7000){
  const r = await httpGet(url, timeoutMs);
  try{ return JSON.parse(r.body); }catch(e){ throw new Error('JSON parse failed for '+url+': '+e.message); }
}
function headOk(url, timeoutMs=3000){
  if (!url) return false;
  const u = String(url).toLowerCase();
  if (u.startsWith('magnet:') || u.startsWith('acestream:') || u.startsWith('file:')) return true;
  if (!(u.startsWith('http://') || u.startsWith('https://'))) return true;
  return new Promise((resolve)=>{
    try{
      const { URL } = require('url'); const dest = new URL(url);
      const req = https.request(dest, { method:'HEAD' }, res => resolve((res.statusCode||0) >= 200 && (res.statusCode||0) < 400));
      req.setTimeout(timeoutMs, ()=>{ try{ req.destroy(); }catch(_){ } resolve(true); });
      req.on('error', ()=> resolve(true));
      req.end();
    }catch(_){ resolve(true); }
  });
}
function writeStrm(dir, name, url){
  try{
    if(!url) return;
    if (!dir || !fs.existsSync(dir)) fs.mkdirSync(dir, {recursive:true});
    const safe = String(name||'Item').replace(/[<>:"/\\|?*]+/g,' ').slice(0,180);
    fs.writeFileSync(path.join(dir, safe + '.strm'), url, 'utf8');
  }catch(_){}
}

// TMDb helpers
function tmdbUrl(pq){ const glue = pq.includes('?') ? '&' : '?'; return 'https://api.themoviedb.org/3/' + pq + glue + 'api_key=' + TMDB_KEY; }
async function tmdbList(ep){ if(!TMDB_KEY) return []; try{ const j = await httpGetJson(tmdbUrl(ep)); return Array.isArray(j.results)? j.results : []; }catch(_){ return []; } }
async function tmdbMovieImdb(id){ try{ const j = await httpGetJson(tmdbUrl('movie/'+id+'/external_ids')); return (j && j.imdb_id) ? j.imdb_id : ''; }catch(_){ return ''; } }
async function tmdbSeriesImdb(id){ try{ const j = await httpGetJson(tmdbUrl('tv/'+id+'/external_ids')); return (j && j.imdb_id) ? j.imdb_id : ''; }catch(_){ return ''; } }

function buildEndpoint(type, id, qsObj){
  const qs = encodeQS(qsObj);
  return ST.base.replace(/\/$/,'') + '/stream/' + encodeURIComponent(type) + '/' + encodeURIComponent(id) + '.json' + (qs ? ('?'+qs) : '');
}
async function resolveWithId(type, id){
  for(const qs of QS_VARIANTS){
    try{
      const url = buildEndpoint(type, id, qs);
      const j = await httpGetJson(url, 7000);
      const arr = Array.isArray(j) ? j : (Array.isArray(j.streams) ? j.streams : []);
      for(const s of arr){ if(s && s.url){ const ok = await headOk(s.url); if(ok) return {url:s.url, reason:null, qsUsed:qs}; } }
    }catch(_){ /* try next variant */ }
  }
  return {url:null, reason:'no streams on all variants'};
}
async function resolveStream(type, tmdbId, title){
  let imdb = '';
  if (type==='movie') imdb = await tmdbMovieImdb(tmdbId);
  else imdb = await tmdbSeriesImdb(tmdbId);

  if (imdb && /^tt\d+$/i.test(imdb)){
    const r1 = await resolveWithId(type, type==='series' ? (imdb+':1:1') : imdb);
    if (r1.url) return r1;
  }
  const variants = [];
  if (type==='movie'){ variants.push('tmdb:movie:'+tmdbId, 'tmdb:'+tmdbId); }
  else { variants.push('tmdb:tv:'+tmdbId+':1:1', 'tmdb:'+tmdbId+':1:1'); }
  for(const vid of variants){ const r = await resolveWithId(type, vid); if(r.url) return r; }
  return {url:null, reason:'no working id variant for '+title};
}

async function buildShelves(){
  const now=new Date(), y=now.getUTCFullYear(), m=String(now.getUTCMonth()+1).padStart(2,'0');
  const first=y+'-'+m+'-01';
  const shelves=[];
  shelves.push({name:'Movies - Popular',        type:'movie',  list:'movie/popular'});
  shelves.push({name:'Movies - Top Rated',      type:'movie',  list:'movie/top_rated'});
  shelves.push({name:'Movies - New this month', type:'movie',  list:'discover/movie?primary_release_date.gte='+first});
  shelves.push({name:'TV - Popular',            type:'series', list:'tv/popular'});
  shelves.push({name:'TV - Top Rated',          type:'series', list:'tv/top_rated'});
  shelves.push({name:'TV - New this month',     type:'series', list:'discover/tv?first_air_date.gte='+first});
  const nets=[{id:213,name:'Netflix'},{id:1024,name:'Amazon Prime'},{id:2739,name:'Disney+'},{id:49,name:'HBO/Max'},{id:2552,name:'Apple TV+'},{id:453,name:'Hulu'},{id:56,name:'Crunchyroll'}];
  for(const n of nets){ shelves.push({name:'TV - '+n.name, type:'series', list:'discover/tv?with_networks='+n.id}); }
  return shelves;
}

async function run(){
  const DEF_MOVIES='D:\\StremioCatalog\\_Hybrid\\Movies';
  const DEF_SHOWS ='D:\\StremioCatalog\\_Hybrid\\Shows';
  const DEF_SANITY='D:\\StremioCatalog\\_Hybrid\\_Sanity';
  const DEF_CACHE ='D:\\PlexTools\\cache';

  const MOVIES=process.env.MOVIES_DIR||DEF_MOVIES;
  const SHOWS =process.env.SHOWS_DIR ||DEF_SHOWS;
  const SANITY=process.env.SANITY_DIR||DEF_SANITY;
  const CACHE =process.env.CACHE_DIR ||DEF_CACHE;

  ensureDir(MOVIES); ensureDir(SHOWS); ensureDir(SANITY); ensureDir(CACHE);

  log('Dirs -> MOVIES='+MOVIES+' SHOWS='+SHOWS+' SANITY='+SANITY+' CACHE='+CACHE);
  log('STREAMS_URL(base): '+(ST.base||'missing'));
  log('STREAMS_URL(params): '+JSON.stringify(ST.params));
  if (RD_TOKEN) log('RD_TOKEN: '+RD_TOKEN);
  log('QS variants: '+JSON.stringify(QS_VARIANTS));

  const report={started:new Date().toISOString(), shelves:[], failures:0, written:0, failureSamples:[]};
  const shelves=await buildShelves();
  for(const sh of shelves){
    const items=await tmdbList(sh.list);
    const outDir= sh.type==='movie'? MOVIES : SHOWS;
    const bucket={name:sh.name, candidates:items.length, written:0, failed:0};
    log('Shelf -> '+sh.name+' ('+items.length+' candidates)');
    for(const it of items.slice(0,30)){
      const title= it.title||it.name||('ID '+it.id);
      const year = String((it.release_date||it.first_air_date||'')).slice(0,4);
      const r= await resolveStream(sh.type, it.id, title);
      if(r.url){ writeStrm(outDir, title + (year?(' ('+year+')'):'') , r.url); bucket.written++; report.written++; }
      else{ bucket.failed++; report.failures++; if(report.failureSamples.length<20) report.failureSamples.push({shelf:sh.name,title,reason:r.reason}); }
    }
    report.shelves.push(bucket);
  }
  fs.writeFileSync(path.join(CACHE,'catalog_report.json'), JSON.stringify(report,null,2));
  log('Populate finished: written='+report.written+' failures='+report.failures);
}
run().catch(e=>{ console.error(e.stack||String(e)); process.exit(1); });
'@
Set-Content -LiteralPath $Populate -Value $AdaptivePopulate -Encoding ASCII
OK "Patched Populate.js (ADAPTIVE)"

# --- 3) Run the diagnostics, then Populate ---
INFO "Torrentio diagnostics:"
& powershell -NoProfile -ExecutionPolicy Bypass -File $DiagPath

$runLog = Join-Path $Logs ("Populate_run_{0}.log" -f (Get-Date -Format 'yyyyMMdd_HHmmss'))
INFO ("Running Populate (log -> {0})" -f $runLog)
& powershell -NoProfile -ExecutionPolicy Bypass -File $Runner *>&1 | Tee-Object -FilePath $runLog
OK "Populate run complete"

Write-Host "`n==== Populate log tail ====" -ForegroundColor Magenta
Get-Content -LiteralPath $runLog -Tail 120 | ForEach-Object { Write-Host $_ }
Write-Host "==== DONE ====" -ForegroundColor Magenta

[OK]  Wrote D:\PlexTools\scripts\Diag_Torrentio.ps1
[OK]  Patched Populate.js (ADAPTIVE)
[..]  Torrentio diagnostics:
At D:\PlexTools\scripts\Diag_Torrentio.ps1:5 char:8
+   $v = $env:$envName
+        ~~~~~
Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.
At D:\PlexTools\scripts\Diag_Torrentio.ps1:5 char:13
+   $v = $env:$envName
+             ~~~~~~~~
Unexpected token '$envName' in expression or statement.
At D:\PlexTools\scripts\Diag_Torrentio.ps1:45 char:113
+ ... imEnd('/'), $t.type, [uri]::EscapeDataString($t.id), ($P.qs ? ('?'+$P ...
+                                                                 ~
Unexpected token '?' in expression or statement.
At D:\PlexTools\scripts\Diag_Torrentio.ps1:45 char:112
+ ... TrimEnd('/'), $t.type, [uri]::EscapeDataString($t.id), ($P.qs ? ('?'+ ...
+                                                                  ~
Missing closing ')' in expression.
At D:\PlexTools\scripts\Diag_Torrentio.ps1:44 char:22
+ foreach($t in $tests){
+                      ~
Missing closing '}' in statement block or type definition.
At D:\PlexTools\scripts\Diag_Torrentio.ps1:45 char:131
+ ...  $t.type, [uri]::EscapeDataString($t.id), ($P.qs ? ('?'+$P.qs) : ''))
+                                                                        ~
Unexpected token ')' in expression or statement.
At D:\PlexTools\scripts\Diag_Torrentio.ps1:45 char:132
+ ...  $t.type, [uri]::EscapeDataString($t.id), ($P.qs ? ('?'+$P.qs) : ''))
+                                                                         ~
Unexpected token ')' in expression or statement.
At D:\PlexTools\scripts\Diag_Torrentio.ps1:58 char:1
+ }
+ ~
Unexpected token '}' in expression or statement.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : InvalidVariableReferenceWithDrive
[..]  Running Populate (log -> D:\PlexTools\logs\Populate_run_20251006_184533.log)
[ENV] TMDB_KEY:  3a70e2d3239f68d97da1e7c3c70ead0f
[ENV] STREAMS_URL:  https://torrentio.strem.fun/qualityfilter=threed,480p,cam,unknown|limit=2|realdebrid=N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ
[ENV] RD_TOKEN:  N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ
[2025-10-06T07:45:34.051Z] Dirs -> MOVIES=D:\StremioCatalog\_Hybrid\Movies SHOWS=D:\StremioCatalog\_Hybrid\Shows SANITY=D:\StremioCatalog\_Hybrid\_Sanity CACHE=D:\PlexTools\cache
[2025-10-06T07:45:34.053Z] STREAMS_URL(base): https://torrentio.strem.fun
[2025-10-06T07:45:34.053Z] STREAMS_URL(params): {"qualityfilter":"threed,480p,cam,unknown","limit":"2","realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"}
[2025-10-06T07:45:34.053Z] RD_TOKEN: N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ
[2025-10-06T07:45:34.053Z] QS variants: [{"qualityfilter":"threed,480p,cam,unknown","limit":"2","realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"},{"qualityfilter":"threed,480p,cam,unknown","limit":10,"realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"},{"limit":"2","realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"},{"limit":15,"realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"}]
[2025-10-06T07:45:34.743Z] Shelf -> Movies - Popular (20 candidates)
[2025-10-06T07:46:07.872Z] Shelf -> Movies - Top Rated (20 candidates)
[2025-10-06T07:46:41.604Z] Shelf -> Movies - New this month (20 candidates)
[2025-10-06T07:47:20.958Z] Shelf -> TV - Popular (20 candidates)
[2025-10-06T07:48:19.464Z] Shelf -> TV - Top Rated (20 candidates)
[2025-10-06T07:49:16.401Z] Shelf -> TV - New this month (20 candidates)
[2025-10-06T07:50:19.516Z] Shelf -> TV - Netflix (20 candidates)
[2025-10-06T07:51:18.400Z] Shelf -> TV - Amazon Prime (20 candidates)
[2025-10-06T07:52:38.115Z] Shelf -> TV - Disney+ (20 candidates)
[2025-10-06T07:53:57.460Z] Shelf -> TV - HBO/Max (20 candidates)
[2025-10-06T07:55:07.315Z] Shelf -> TV - Apple TV+ (20 candidates)
[2025-10-06T07:55:45.754Z] Shelf -> TV - Hulu (20 candidates)
[2025-10-06T07:56:23.626Z] Shelf -> TV - Crunchyroll (20 candidates)
[2025-10-06T07:57:02.209Z] Populate finished: written=0 failures=260
[OK]  Populate run complete

==== Populate log tail ====
[ENV] TMDB_KEY:  3a70e2d3239f68d97da1e7c3c70ead0f
[ENV] STREAMS_URL:  https://torrentio.strem.fun/qualityfilter=threed,480p,cam,unknown|limit=2|realdebrid=N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ
[ENV] RD_TOKEN:  N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ
[2025-10-06T07:45:34.051Z] Dirs -> MOVIES=D:\StremioCatalog\_Hybrid\Movies SHOWS=D:\StremioCatalog\_Hybrid\Shows SANITY=D:\StremioCatalog\_Hybrid\_Sanity CACHE=D:\PlexTools\cache
[2025-10-06T07:45:34.053Z] STREAMS_URL(base): https://torrentio.strem.fun
[2025-10-06T07:45:34.053Z] STREAMS_URL(params): {"qualityfilter":"threed,480p,cam,unknown","limit":"2","realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"}
[2025-10-06T07:45:34.053Z] RD_TOKEN: N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ
[2025-10-06T07:45:34.053Z] QS variants: [{"qualityfilter":"threed,480p,cam,unknown","limit":"2","realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"},{"qualityfilter":"threed,480p,cam,unknown","limit":10,"realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"},{"limit":"2","realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"},{"limit":15,"realdebrid":"N4FLTAWR4NTMF6O5SU4CESZZSDWYOSHKTVPFDYAAK4FZTWYKAHGQ"}]
[2025-10-06T07:45:34.743Z] Shelf -> Movies - Popular (20 candidates)
[2025-10-06T07:46:07.872Z] Shelf -> Movies - Top Rated (20 candidates)
[2025-10-06T07:46:41.604Z] Shelf -> Movies - New this month (20 candidates)
[2025-10-06T07:47:20.958Z] Shelf -> TV - Popular (20 candidates)
[2025-10-06T07:48:19.464Z] Shelf -> TV - Top Rated (20 candidates)
[2025-10-06T07:49:16.401Z] Shelf -> TV - New this month (20 candidates)
[2025-10-06T07:50:19.516Z] Shelf -> TV - Netflix (20 candidates)
[2025-10-06T07:51:18.400Z] Shelf -> TV - Amazon Prime (20 candidates)
[2025-10-06T07:52:38.115Z] Shelf -> TV - Disney+ (20 candidates)
[2025-10-06T07:53:57.460Z] Shelf -> TV - HBO/Max (20 candidates)
[2025-10-06T07:55:07.315Z] Shelf -> TV - Apple TV+ (20 candidates)
[2025-10-06T07:55:45.754Z] Shelf -> TV - Hulu (20 candidates)
[2025-10-06T07:56:23.626Z] Shelf -> TV - Crunchyroll (20 candidates)
[2025-10-06T07:57:02.209Z] Populate finished: written=0 failures=260
==== DONE ====
PS C:\Windows\System32> cls
PS C:\Windows\System32> # UDM All-in-One Auditor v2.1 â€” Integration API + Cookie Config + Insights (single run)
# Fix: wrap HasProp call in parentheses inside -and condition (parser error).
# - If TOKENS\udm_user.txt or udm_pass.txt are missing, prompts once and saves them.
# - Pulls Integration API (sites/devices/clients) via X-API-KEY from TOKENS\udm_token.txt
# - Logs into Network app (cookie session) to export WLANs, Networks/VLANs, Port Profiles, Firewall, Events, etc.
# - Builds top_talkers.csv and config_insights_<ts>.txt
# - Bundles everything into a zip; optional Gist attach if TOKENS\gist_id.txt + token exist.

$ErrorActionPreference='Stop'
Set-StrictMode -Version Latest

function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'), $m) -ForegroundColor $c }
function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
function HasProp($o,$n){ return ($o -ne $null) -and ($o.PSObject.Properties.Name -contains $n) -and ($o.$n -ne $null -and $o.$n -ne '') }
function TryProp { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ return $o.$n } } return $null }
function TryNum  { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ try{ return [double]$o.$n }catch{} } } return $null }
function ReadJsonFlex($p){
  if(-not (Test-Path $p)){ return @() }
  try{
    $j = Get-Content -LiteralPath $p -Raw | ConvertFrom-Json
    if($j.data){ return $j.data }
    elseif($j.items){ return $j.items }
    elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){ return $j }
    else { return @($j) }
  }catch{ return @() }
}

# Paths
$Vault   = 'C:\Users\jason\OneDrive\Public\TOKENS'
$Root    = 'D:\PlexTools'
$Reports = Join-Path $Root 'reports'
$Cache   = Join-Path $Root 'cache'
Ensure-Dir $Reports; Ensure-Dir $Cache

$Stamp   = Get-Date -Format 'yyyyMMdd_HHmmss'
$Prefix  = "udm_audit_$Stamp"
$Summary = Join-Path $Reports "$Prefix.summary.txt"
"UDM All-in-One Auditor v2.1 - $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

# Load tokens
$UDM_IP   = ReadIf (Join-Path $Vault 'udm_ip.txt')
$API_KEY  = ***REDACTED*** (Join-Path $Vault 'udm_token.txt')
$USER     = ReadIf (Join-Path $Vault 'udm_user.txt')
$PASS     = ReadIf (Join-Path $Vault 'udm_pass.txt')
$GID      = ReadIf (Join-Path $Vault 'gist_id.txt')
$GTOK     = ReadIf (Join-Path $Vault 'gist_token.txt')
if(-not $GTOK -and (Test-Path (Join-Path $Vault 'gist_token.bin'))){
  try{
    $bytes=[IO.File]::ReadAllBytes((Join-Path $Vault 'gist_token.bin'))
    $dec=[System.Security.Cryptography.ProtectedData]::Unprotect($bytes,$null,[System.Security.Cryptography.DataProtectionScope]::CurrentUser)
    $GTOK=[Text.Encoding]::UTF8.GetString($dec).Trim()
  }catch{}
}

# Auto-detect IP if missing
if([string]::IsNullOrWhiteSpace($UDM_IP)){
  $gw = (Get-NetIPConfiguration | Where-Object { $_.IPv4DefaultGateway -and $_.IPv4Address } | Select-Object -First 1)
  if($gw -and $gw.IPv4DefaultGateway){
    $UDM_IP = $gw.IPv4DefaultGateway.NextHop
    Set-Content -LiteralPath (Join-Path $Vault 'udm_ip.txt') -Value $UDM_IP -Encoding ASCII
  }
}
("UDM IP: {0}" -f ($(if($UDM_IP){$UDM_IP}else{'<missing>'}))) | Add-Content -LiteralPath $Summary -Encoding UTF8

# If controller creds missing, prompt once and persist
if([string]::IsNullOrWhiteSpace($USER)){
  $USER = Read-Host "Enter controller username"
  if(-not [string]::IsNullOrWhiteSpace($USER)){ Set-Content -LiteralPath (Join-Path $Vault 'udm_user.txt') -Value $USER -Encoding ASCII }
}
if([string]::IsNullOrWhiteSpace($PASS)){
  $sec = Read-Host "Enter controller password" -AsSecureString
  try{
    $bstr=[Runtime.InteropServices.Marshal]::SecureStringToBSTR($sec)
    $plain=[Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr)
    if(-not [string]::IsNullOrWhiteSpace($plain)){ Set-Content -LiteralPath (Join-Path $Vault 'udm_pass.txt') -Value $plain -Encoding ASCII }
  }finally{
    if($bstr){ [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr) }
  }
  $PASS = ReadIf (Join-Path $Vault 'udm_pass.txt')
}

# Environment hardening
$env:HTTP_PROXY=''; $env:HTTPS_PROXY=''; $env:ALL_PROXY=''
[System.Net.WebRequest]::DefaultWebProxy = $null
try{
  [System.Net.ServicePointManager]::Expect100Continue = $false
  $sp=[System.Net.ServicePointManager]::SecurityProtocol
  if(($sp -band [Net.SecurityProtocolType]::Tls12) -eq 0){ [System.Net.ServicePointManager]::SecurityProtocol = $sp -bor [Net.SecurityProtocolType]::Tls12 }
}catch{}

# curl
$curl = Get-Command curl.exe -ErrorAction SilentlyContinue
if(-not $curl){ Add-Content -LiteralPath $Summary -Value 'curl.exe not found in PATH.' -Encoding UTF8; throw 'curl missing' }

# ---------------- Integration API (X-API-KEY) ----------------
$F_sites = $null; $F_devs = $null; $F_clis = $null; $siteId = 'default'
if(-not [string]::IsNullOrWhiteSpace($UDM_IP) -and -not [string]::IsNullOrWhiteSpace($API_KEY)){
  $BaseInteg = "https://$UDM_IP/proxy/network/integration/v1"
  function CurlJsonInteg { param([string]$path,[string]$outfile)
    $url = "$BaseInteg$path"
    $args = @('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20',
              '-H','Accept: application/json','-H',("X-API-KEY: $API_KEY"),
              '-H','User-Agent: UDM-Audit-Integ','-o',$outfile,'-w','%{http_code}', $url)
    try{
      $codeRaw = & $curl.Source $args 2>$null
      if($codeRaw -match '^\d{3}$'){ [int]$codeRaw } else { -1 }
    }catch{ -1 }
  }
  function FetchInteg { param([string]$path,[string]$name)
    $outfile = Join-Path $Reports ("$Prefix.$name.json")
    $code = CurlJsonInteg $path $outfile
    ("Integration {0} -> {1}" -f $path, $(if($code -ge 0){$code}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($code -ge 200 -and $code -lt 300){ return $outfile } else { return $null }
  }

  $F_sites = FetchInteg '/sites' 'sites'
  if($F_sites){
    try{
      $sj = Get-Content -LiteralPath $F_sites -Raw | ConvertFrom-Json
      $first = $null
      if($sj -is [System.Collections.IEnumerable] -and -not ($sj -is [string])){ $first = $sj | Select-Object -First 1 }
      elseif($sj.data){ $first = $sj.data | Select-Object -First 1 }
      elseif($sj.items){ $first = $sj.items | Select-Object -First 1 }
      if($first){
        if(HasProp $first 'id'){ $siteId = $first.id }
        elseif(HasProp $first 'site'){ $siteId = $first.site }
        elseif(HasProp $first 'name'){ $siteId = ($first.name.ToString()).ToLowerInvariant() }
      }
    }catch{}
    ("Integration siteId: {0}" -f $siteId) | Add-Content -LiteralPath $Summary -Encoding UTF8
    $F_devs = FetchInteg "/sites/$siteId/devices" 'devices'
    $F_clis = FetchInteg "/sites/$siteId/clients" 'clients'
  } else {
    Add-Content -LiteralPath $Summary -Value 'Integration sites call failed (check X-API-KEY).' -Encoding UTF8
  }
} else {
  Add-Content -LiteralPath $Summary -Value 'Skipping Integration API: missing IP or X-API-KEY.' -Encoding UTF8
}

# ---------------- Cookie session (Network app config) ----------------
$CookieJar = Join-Path $Cache ("udm_cookie_{0}.txt" -f $Stamp)
$F_selfSites = $null
$siteShort = 'default'
$loginOK = $false

if(-not [string]::IsNullOrWhiteSpace($UDM_IP) -and -not [string]::IsNullOrWhiteSpace($USER) -and -not [string]::IsNullOrWhiteSpace($PASS)){
  function CurlLogin {
    $loginUrl = "https://$UDM_IP/api/auth/login"
    $payload  = "{`"username`":`"$USER`",`"password`":`"$PASS`",`"rememberMe`":true}"
    $args = @('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20',
              '-H','Accept: application/json','-H','Content-Type: application/json','-H','User-Agent: UDM-Audit-Cookie',
              '-c',$CookieJar,'-b',$CookieJar,'--data-binary',$payload,$loginUrl,'-w','%{http_code}')
    try{
      $code = & $curl.Source $args 2>$null
      if($code -match '^\d{3}$'){ [int]$code } else { -1 }
    }catch{ -1 }
  }
  function GetCsrfFromCookie(){
    if(Test-Path $CookieJar){
      try{
        $lines = Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII
        $m = [regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)')
        if($m.Count -gt 0){ return $m[$m.Count-1].Groups[1].Value.Trim() }
      }catch{}
    }
    return $null
  }
  function CurlJsonCookie([string]$url,[string]$outfile){
    $csrf = GetCsrfFromCookie
    $args = @('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','25',
              '-H','Accept: application/json','-H','User-Agent: UDM-Audit-Cookie',
              '-c',$CookieJar,'-b',$CookieJar,'-o',$outfile,'-w','%{http_code}', $url)
    if($csrf){ $args = @('-H',("X-Csrf-Token: {0}" -f $csrf)) + $args }
    try{
      $code = & $curl.Source $args 2>$null
      if($code -match '^\d{3}$'){ [int]$code } else { -1 }
    }catch{ -1 }
  }
  function FetchCookie([string]$path,[string]$label,[string]$name){
    $url = "https://$UDM_IP$path"
    $outfile = Join-Path $Reports ("$Prefix.$name.json")
    $code = CurlJsonCookie $url $outfile
    ("Cookie {0} -> {1}" -f $path, $(if($code -ge 0){$code}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($code -ge 200 -and $code -lt 300){ return $outfile } else { return $null }
  }

  $codeLogin = CurlLogin
  if($codeLogin -eq 200){
    $loginOK = $true
    Add-Content -LiteralPath $Summary -Value 'Cookie login OK.' -Encoding UTF8
    $F_selfSites = FetchCookie "/proxy/network/api/self/sites" "self_sites" "self_sites"
    if($F_selfSites){
      try{
        $sj = Get-Content -LiteralPath $F_selfSites -Raw | ConvertFrom-Json
        $first = $null
        if($sj.data){ $first = $sj.data | Select-Object -First 1 }
        elseif($sj -is [System.Collections.IEnumerable] -and -not ($sj -is [string])){ $first = $sj | Select-Object -First 1 }
        if($first -and (HasProp $first 'name')){ $siteShort = $first.name }
      }catch{}
    }
    ("Network site short name: {0}" -f $siteShort) | Add-Content -LiteralPath $Summary -Encoding UTF8

    # Config and stats (read-only)
    [void](FetchCookie "/proxy/network/api/s/$siteShort/list/setting"        "list_setting"        "list_setting")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/rest/networkconf"    "rest_networkconf"    "rest_networkconf")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/list/wlanconf"       "list_wlanconf"       "list_wlanconf")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/rest/portconf"       "rest_portconf"       "rest_portconf")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/list/usergroup"      "list_usergroup"      "list_usergroup")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/rest/firewallrule"   "rest_firewallrule"   "rest_firewallrule")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/rest/firewallgroup"  "rest_firewallgroup"  "rest_firewallgroup")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/stat/device"         "stat_device"         "stat_device")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/stat/sta"            "stat_sta"            "stat_sta")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/stat/health"         "stat_health"         "stat_health")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/stat/sysinfo"        "stat_sysinfo"        "stat_sysinfo")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/stat/event"          "stat_event"          "stat_event")
    [void](FetchCookie "/proxy/network/api/s/$siteShort/stat/alarm"          "stat_alarm"          "stat_alarm")
  } else {
    Add-Content -LiteralPath $Summary -Value ("Cookie login failed HTTP {0}. Skipping config export." -f $codeLogin) -Encoding UTF8
  }
} else {
  Add-Content -LiteralPath $Summary -Value 'Skipping cookie login: missing udm_user.txt or udm_pass.txt (prompted above if absent).' -Encoding UTF8
}

# ---------------- Top talkers ----------------
$F_clients_for_top = $null
if($F_clis){ $F_clients_for_top = $F_clis }
elseif(Test-Path (Join-Path $Reports "$Prefix.stat_sta.json")){ $F_clients_for_top = (Join-Path $Reports "$Prefix.stat_sta.json") }

$TopCSV = Join-Path $Reports "$Prefix.top_talkers.csv"
try{
  $rows=@()
  if($F_clients_for_top){
    $arr = ReadJsonFlex $F_clients_for_top
    foreach($c in $arr){
      $name = TryProp $c @('hostname','host_name','name','displayName','display_name','device_name','deviceName','fingerprint_name','mac')
      $ip   = TryProp $c @('ip','ip_address','ipAddress','ipv4','primaryIp','primary_ip')
      $ssid = TryProp $c @('ssid','essid','wifiNetwork','wifi_ssid','wlan_name','wlan','ap_ssid')
      $net  = TryProp $c @('network','network_name','networkName','vlan_name','vlan')
      $wiredFlag = TryProp $c @('is_wired','wired','isWired')
      $wired = $null; if($wiredFlag -ne $null){ $wired = [bool]$wiredFlag }
      $tx = TryNum $c @('tx_bytes','txBytes','tx','tx_total','tx_total_bytes')
      $rx = TryNum $c @('rx_bytes','rxBytes','rx','rx_total','rx_total_bytes')
      if((-not $tx) -or (-not $rx)){
        $stats = TryProp $c @('statistics','stats')
        if($stats){
          if(-not $tx){ $tx = TryNum $stats @('tx_bytes','txBytes','tx','tx_total','bytes_tx') }
          if(-not $rx){ $rx = TryNum $stats @('rx_bytes','rxBytes','rx','rx_total','bytes_rx') }
        }
      }
      if(-not $tx){ $tx=0 }; if(-not $rx){ $rx=0 }
      $rows += [pscustomobject]@{
        name=$name; ip=$ip; mac=(TryProp $c @('mac')); wired=$wired; ssid=$ssid; network=$net;
        tx_bytes=[double]$tx; rx_bytes=[double]$rx; total_bytes=([double]$tx+[double]$rx)
      }
    }
  }
  $top = $rows | Sort-Object -Property total_bytes -Descending | Select-Object -First 20
  if($top){ $top | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8
    ("Top talkers -> {0}" -f $TopCSV) | Add-Content -LiteralPath $Summary -Encoding UTF8
  } else {
    Add-Content -LiteralPath $Summary -Value 'Top talkers -> no bytes available.' -Encoding UTF8
  }
}catch{
  Add-Content -LiteralPath $Summary -Value ("Top talkers error: {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ---------------- Insights (config + clients) ----------------
try{
  $F_devs_int = $F_devs
  if(-not $F_devs_int -and (Test-Path (Join-Path $Reports "$Prefix.stat_device.json"))){ $F_devs_int = (Join-Path $Reports "$Prefix.stat_device.json") }
  $D = if($F_devs_int){ ReadJsonFlex $F_devs_int } else { @() }
  $C = if($F_clis){ ReadJsonFlex $F_clis } elseif(Test-Path (Join-Path $Reports "$Prefix.stat_sta.json")){ ReadJsonFlex (Join-Path $Reports "$Prefix.stat_sta.json") } else { @() }

  $ins = Join-Path $Reports ("config_insights_{0}.txt" -f $Stamp)
  "Config Insights - $(Get-Date)" | Set-Content -LiteralPath $ins -Encoding UTF8

  # Device inventory and firmware
  $kinds=@{}; $fw=@{}; $offline=@()
  foreach($d in $D){
    $kind = TryProp $d @('type','productLine','deviceType','model','role'); if(-not $kind){ $kind='device' }
    if(-not $kinds.ContainsKey($kind)){ $kinds[$kind]=0 }; $kinds[$kind]++
    $ver = TryProp $d @('firmware_version','firmwareVersion','version'); if($ver){ if(-not $fw.ContainsKey($ver)){ $fw[$ver]=0 }; $fw[$ver]++ }
    $up = $null
    if(HasProp $d 'up'){ $up=[bool]$d.up }
    elseif(HasProp $d 'connected'){ $up=[bool]$d.connected }
    elseif(HasProp $d 'online'){ $up=[bool]$d.online }
    elseif(HasProp $d 'status'){ $up = ($d.status.ToString().ToLower() -match 'up|online|connected|ready') }
    if(($up -ne $true)){ $offline += $d }
  }
  Add-Content $ins 'Devices:'
  foreach($k in ($kinds.Keys | Sort-Object)){ Add-Content $ins ("  - {0}: {1}" -f $k,$kinds[$k]) }
  if($fw.Keys.Count -gt 0){
    Add-Content $ins 'Firmware mix:'
    foreach($v in ($fw.Keys | Sort-Object)){ Add-Content $ins ("  - {0}: {1}" -f $v,$fw[$v]) }
  }
  Add-Content $ins ''

  # Pull cookie-based config files if present
  $F_wlan   = Join-Path $Reports "$Prefix.list_wlanconf.json"
  $F_net    = Join-Path $Reports "$Prefix.rest_networkconf.json"
  $F_ports  = Join-Path $Reports "$Prefix.rest_portconf.json"
  $F_fwr    = Join-Path $Reports "$Prefix.rest_firewallrule.json"
  $F_fwg    = Join-Path $Reports "$Prefix.rest_firewallgroup.json"
  $F_events = Join-Path $Reports "$Prefix.stat_event.json"

  $W = ReadJsonFlex $F_wlan
  $N = ReadJsonFlex $F_net
  $PR= ReadJsonFlex $F_ports
  $FR= ReadJsonFlex $F_fwr
  $FG= ReadJsonFlex $F_fwg
  $EV= ReadJsonFlex $F_events

  # WLAN checks
  if($W.Count -gt 0){
    Add-Content $ins 'WLANs:'
    foreach($w in $W){
      $nm = TryProp $w @('name','ssid'); if(-not $nm){ $nm='(unnamed)' }
      $sec = TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version')
      $iso = TryProp $w @('isolation','ap_isolation','is_guest','guest')
      $pmf = TryProp $w @('pmf_mode','pmf','ocpmf')
      Add-Content $ins ("  - {0} | security={1} | isolation={2} | pmf={3}" -f $nm,$sec,$iso,$pmf)
    }
    Add-Content $ins ''
  }

  # Network/VLAN summary
  if($N.Count -gt 0){
    $vlanCount = 0; $netCount = $N.Count
    foreach($n in $N){
      $v = TryProp $n @('vlan','vlan_id','vlanId'); if($v){ $vlanCount++ }
    }
    Add-Content $ins ("Networks: {0} (with VLAN tag on {1})" -f $netCount,$vlanCount)
  }

  # Firewall summary
  if($FR.Count -gt 0){
    $enabled = ($FR | Where-Object { HasProp $_ 'enabled' -and $_.enabled -eq $true }).Count
    Add-Content $ins ("Firewall rules: total={0}, enabled={1}" -f $FR.Count,$enabled)
    # flag broad allow on WAN_IN or LAN_IN
    $broad = @()
    foreach($r in $FR){
      $ruleset = TryProp $r @('ruleset','rule_set','direction')
      $act = TryProp $r @('action')
      $dst = TryProp $r @('dst_address','dst','destination','dst_network')
      $src = TryProp $r @('src_address','src','source','src_network')
      if(($act -eq 'accept' -or $act -eq 'allow') -and ($ruleset -match 'WAN_IN|LAN_IN') -and ((-not $dst) -or $dst -match 'Any|any|0\.0\.0\.0/0')){
        $broad += $r
      }
    }
    if($broad.Count -gt 0){ Add-Content $ins ("Warning: {0} broad allow rule(s) detected in WAN_IN/LAN_IN." -f $broad.Count) }
  }

  # Clients overview
  $wired=0; $wifi=0; $band24=0; $band5=0; $stale=@()
  $now = [DateTimeOffset]::UtcNow
  foreach($c in $C){
    $isWired = TryProp $c @('is_wired','wired','isWired'); if($isWired -ne $null){ if([bool]$isWired){$wired++}else{$wifi++} } else { $wifi++ }
    $radio = TryProp $c @('radio','band','phy')
    if($radio){
      $r = $radio.ToString().ToLower()
      if($r -match 'n|g|2\.4'){ $band24++ }
      elseif($r -match 'a|ac|ax|5'){ $band5++ }
    }
    $last = TryNum $c @('last_seen','lastSeen','last_seen_time','lastSeenTime')
    if($last){
      try{
        $epoch = [DateTimeOffset]::FromUnixTimeSeconds([int64]$last).UtcDateTime
        if(($now.UtcDateTime - $epoch).TotalDays -ge 7){ $stale += $c }
      }catch{}
    }
  }
  Add-Content $ins ("Clients: total={0}, wired={1}, wifi={2}" -f $C.Count,$wired,$wifi)
  if($band24 -or $band5){ Add-Content $ins ("Band mix approx: 2.4GHz={0}, 5GHz={1}" -f $band24,$band5) }
  if($stale.Count -gt 0){ Add-Content $ins ("Stale clients (>7d not seen): {0}" -f $stale.Count) }

  # Suggestions
  Add-Content $ins ''
  Add-Content $ins 'Suggestions:'
  if($W.Count -gt 0){
    $open = $W | Where-Object { ($_.security -match 'open') -or (TryProp $_ @('security','auth','wpa_mode') -eq 'open') }
    if($open.Count -gt 0){ Add-Content $ins "  - One or more WLANs appear open. Enforce WPA2/WPA3 and enable PMF where compatible." }
    $nopmf = $W | Where-Object { (TryProp $_ @('pmf_mode','pmf') -in @($null,'disabled','optional','0')) }
    if($nopmf.Count -gt 0){ Add-Content $ins "  - PMF not required on some WLANs. Consider setting PMF Required on trusted SSIDs." }
    $guestish = $W | Where-Object { (TryProp $_ @('is_guest','guest','isolation') -in @($null,$false)) }
    if($guestish.Count -gt 0){ Add-Content $ins "  - Guest isolation not detected on some SSIDs. Consider guest policies for visitor WLANs." }
  }
  if($N.Count -le 1){ Add-Content $ins "  - Single flat network detected. Consider a separate IoT VLAN and inter-VLAN rules." }
  if($fw.Keys.Count -gt 1){ Add-Content $ins "  - Mixed firmware versions present. Plan a maintenance window to align firmware." }
  if($band24 -gt ($band5*2)){ Add-Content $ins "  - Many clients on 2.4GHz. Consider a 5GHz-preferred SSID or band-steering." }

  ("Config insights -> {0}" -f $ins) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{
  Add-Content -LiteralPath $Summary -Value ("Insights error: {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ---------------- Zip bundle ----------------
$Bundle = Join-Path $Reports "$Prefix.zip"
try{
  $toZip = Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -like "$Prefix*" -or $_.Name -like "config_insights_$Stamp.txt" }
  if($toZip){ Compress-Archive -Path ($toZip | Select-Object -ExpandProperty FullName) -DestinationPath $Bundle -Force }
  ("Bundle -> {0}" -f $Bundle) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{
  Add-Content -LiteralPath $Summary -Value ("Bundle error: {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ---------------- Optional Gist upload ----------------
try{
  if($GID -and $GTOK){
    $files=@{}
    Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -like "$Prefix*" -or $_.Name -eq ("config_insights_{0}.txt" -f $Stamp) } | ForEach-Object {
      $files[$_.Name] = @{ content = (Get-Content -LiteralPath $_.FullName -Raw) }
    }
    if($files.Count -gt 0){
      $payload=@{ files=$files } | ConvertTo-Json -Depth 7
      $uri="https://api.github.com/gists/$GID"
      $hdr=@{ Authorization=("token {0}" -f $GTOK); 'User-Agent'='UDM-AllInOne-Auditor-v2.1' }
      $resp=Invoke-WebRequest -Uri $uri -Method Patch -Headers $hdr -Body $payload -ContentType 'application/json' -UseBasicParsing
      if($resp.StatusCode -ge 200 -and $resp.StatusCode -lt 300){ Add-Content -LiteralPath $Summary -Value ("Attached to Gist {0}" -f $GID) -Encoding UTF8 }
    }
  }
}catch{
  Add-Content -LiteralPath $Summary -Value ("Gist upload skipped: {0}" -f $_.Exception.Message) -Encoding UTF8
}

Say ("Audit complete -> {0}" -f $Summary) "Green"
Get-Content -LiteralPath $Summary

[19:13:37] Audit complete -> D:\PlexTools\reports\udm_audit_20251006_191129.summary.txt
UDM All-in-One Auditor v2.1 - 10/06/2025 19:11:29
UDM IP: 192.168.1.1
Integration /sites -> 200
Integration siteId: 88f7af54-98f8-306a-a1c7-c9349722b1f6
Integration /sites/88f7af54-98f8-306a-a1c7-c9349722b1f6/devices -> 200
Integration /sites/88f7af54-98f8-306a-a1c7-c9349722b1f6/clients -> 200
Cookie login failed HTTP -1. Skipping config export.
Top talkers -> D:\PlexTools\reports\udm_audit_20251006_191129.top_talkers.csv
Insights error: The property 'Count' cannot be found on this object. Verify that the property exists.
Bundle -> D:\PlexTools\reports\udm_audit_20251006_191129.zip
Attached to Gist 5b621abce653010601f1cacbbf3bc249
PS C:\Windows\System32> cls
PS C:\Windows\System32> # UDM All-in-One Auditor v2.2 â€” SNI-safe Cookie Login + Robust Insights (single run, copy/paste)
# - Integration API (X-API-KEY) for sites/devices/clients
# - Cookie session (Network app) with SNI-safe hostname probing (unifi/udm/etc via --resolve)
# - Generates top_talkers.csv + config_insights_<ts>.txt; bundles; optional Gist upload
# - Hardens all counts and collections to avoid 'Count' property errors

$ErrorActionPreference='Stop'
Set-StrictMode -Version Latest

function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'), $m) -ForegroundColor $c }
function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
function HasProp($o,$n){ return ($o -ne $null) -and ($o.PSObject.Properties.Name -contains $n) -and ($o.$n -ne $null -and $o.$n -ne '') }
function TryProp { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ return $o.$n } } return $null }
function TryNum  { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ try{ return [double]$o.$n }catch{} } } return $null }
function ReadJsonFlex($p){
  if(-not (Test-Path $p)){ return @() }
  try{
    $j = Get-Content -LiteralPath $p -Raw | ConvertFrom-Json
    if($j -eq $null){ return @() }
    if($j.data){ return @($j.data) }
    elseif($j.items){ return @($j.items) }
    elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){ return @($j) }
    else { return @($j) }
  }catch{ return @() }
}
function SafeCount($x){ return @($x).Count }

# Paths
$Vault   = 'C:\Users\jason\OneDrive\Public\TOKENS'
$Root    = 'D:\PlexTools'
$Reports = Join-Path $Root 'reports'
$Cache   = Join-Path $Root 'cache'
Ensure-Dir $Reports; Ensure-Dir $Cache

$Stamp   = Get-Date -Format 'yyyyMMdd_HHmmss'
$Prefix  = "udm_audit_$Stamp"
$Summary = Join-Path $Reports "$Prefix.summary.txt"
"UDM All-in-One Auditor v2.2 - $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

# Load tokens
$UDM_IP    = ReadIf (Join-Path $Vault 'udm_ip.txt')
$API_KEY   = ***REDACTED*** (Join-Path $Vault 'udm_token.txt')
$USER      = ReadIf (Join-Path $Vault 'udm_user.txt')
$PASS      = ReadIf (Join-Path $Vault 'udm_pass.txt')
$GID       = ReadIf (Join-Path $Vault 'gist_id.txt')
$GTOK      = ReadIf (Join-Path $Vault 'gist_token.txt')
$UDM_HOSTF = ReadIf (Join-Path $Vault 'udm_hostname.txt')  # optional preferred hostname
if(-not $GTOK -and (Test-Path (Join-Path $Vault 'gist_token.bin'))){
  try{
    $bytes=[IO.File]::ReadAllBytes((Join-Path $Vault 'gist_token.bin'))
    $dec=[System.Security.Cryptography.ProtectedData]::Unprotect($bytes,$null,[System.Security.Cryptography.DataProtectionScope]::CurrentUser)
    $GTOK=[Text.Encoding]::UTF8.GetString($dec).Trim()
  }catch{}
}

# Auto-detect IP if missing
if([string]::IsNullOrWhiteSpace($UDM_IP)){
  $gw = (Get-NetIPConfiguration | Where-Object { $_.IPv4DefaultGateway -and $_.IPv4Address } | Select-Object -First 1)
  if($gw -and $gw.IPv4DefaultGateway){
    $UDM_IP = $gw.IPv4DefaultGateway.NextHop
    Set-Content -LiteralPath (Join-Path $Vault 'udm_ip.txt') -Value $UDM_IP -Encoding ASCII
  }
}
("UDM IP: {0}" -f ($(if($UDM_IP){$UDM_IP}else{'<missing>'}))) | Add-Content -LiteralPath $Summary -Encoding UTF8

# If controller creds missing, prompt once and persist
if([string]::IsNullOrWhiteSpace($USER)){
  $USER = Read-Host "Enter controller username"
  if(-not [string]::IsNullOrWhiteSpace($USER)){ Set-Content -LiteralPath (Join-Path $Vault 'udm_user.txt') -Value $USER -Encoding ASCII }
}
if([string]::IsNullOrWhiteSpace($PASS)){
  $sec = Read-Host "Enter controller password" -AsSecureString
  try{
    $bstr=[Runtime.InteropServices.Marshal]::SecureStringToBSTR($sec)
    $plain=[Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr)
    if(-not [string]::IsNullOrWhiteSpace($plain)){ Set-Content -LiteralPath (Join-Path $Vault 'udm_pass.txt') -Value $plain -Encoding ASCII }
  }finally{
    if($bstr){ [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr) }
  }
  $PASS = ReadIf (Join-Path $Vault 'udm_pass.txt')
}

# Environment hardening
$env:HTTP_PROXY=''; $env:HTTPS_PROXY=''; $env:ALL_PROXY=''
[System.Net.WebRequest]::DefaultWebProxy = $null
try{
  [System.Net.ServicePointManager]::Expect100Continue = $false
  $sp=[System.Net.ServicePointManager]::SecurityProtocol
  if(($sp -band [Net.SecurityProtocolType]::Tls12) -eq 0){ [System.Net.ServicePointManager]::SecurityProtocol = $sp -bor [Net.SecurityProtocolType]::Tls12 }
}catch{}

# curl
$curl = Get-Command curl.exe -ErrorAction SilentlyContinue
if(-not $curl){ Add-Content -LiteralPath $Summary -Value 'curl.exe not found in PATH.' -Encoding UTF8; throw 'curl missing' }

# ---------------- Integration API (X-API-KEY) ----------------
$F_sites = $null; $F_devs = $null; $F_clis = $null; $siteId = 'default'
if(-not [string]::IsNullOrWhiteSpace($UDM_IP) -and -not [string]::IsNullOrWhiteSpace($API_KEY)){
  $BaseInteg = "https://$UDM_IP/proxy/network/integration/v1"
  function CurlJsonInteg { param([string]$path,[string]$outfile)
    $url = "$BaseInteg$path"
    $args = @('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20',
              '-H','Accept: application/json','-H',("X-API-KEY: $API_KEY"),
              '-H','User-Agent: UDM-Audit-Integ','-o',$outfile,'-w','%{http_code}', $url)
    try{
      $codeRaw = & $curl.Source $args 2>$null
      if($codeRaw -match '^\d{3}$'){ [int]$codeRaw } else { -1 }
    }catch{ -1 }
  }
  function FetchInteg { param([string]$path,[string]$name)
    $outfile = Join-Path $Reports ("$Prefix.$name.json")
    $code = CurlJsonInteg $path $outfile
    ("Integration {0} -> {1}" -f $path, $(if($code -ge 0){$code}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($code -ge 200 -and $code -lt 300){ return $outfile } else { return $null }
  }

  $F_sites = FetchInteg '/sites' 'sites'
  if($F_sites){
    try{
      $sj = Get-Content -LiteralPath $F_sites -Raw | ConvertFrom-Json
      $first = $null
      if($sj -is [System.Collections.IEnumerable] -and -not ($sj -is [string])){ $first = $sj | Select-Object -First 1 }
      elseif($sj.data){ $first = $sj.data | Select-Object -First 1 }
      elseif($sj.items){ $first = $sj.items | Select-Object -First 1 }
      if($first){
        if(HasProp $first 'id'){ $siteId = $first.id }
        elseif(HasProp $first 'site'){ $siteId = $first.site }
        elseif(HasProp $first 'name'){ $siteId = ($first.name.ToString()).ToLowerInvariant() }
      }
    }catch{}
    ("Integration siteId: {0}" -f $siteId) | Add-Content -LiteralPath $Summary -Encoding UTF8
    $F_devs = FetchInteg "/sites/$siteId/devices" 'devices'
    $F_clis = FetchInteg "/sites/$siteId/clients" 'clients'
  } else {
    Add-Content -LiteralPath $Summary -Value 'Integration sites call failed (check X-API-KEY).' -Encoding UTF8
  }
} else {
  Add-Content -LiteralPath $Summary -Value 'Skipping Integration API: missing IP or X-API-KEY.' -Encoding UTF8
}

# ---------------- Cookie session (Network app) with SNI-safe host probing ----------------
$CookieJar = Join-Path $Cache ("udm_cookie_{0}.txt" -f $Stamp)
$F_selfSites = $null
$siteShort = 'default'
$loginOK = $false
$CookieHost = $null

$HostCandidates = @()
if($UDM_HOSTF){ $HostCandidates += $UDM_HOSTF }
$HostCandidates += @('unifi','udm','unifi.localdomain','unifi.home','udm.home','udm.local')
$HostCandidates = $HostCandidates | Select-Object -Unique

function CurlLoginHost { param([string]$host)
  if(Test-Path $CookieJar){ Remove-Item -LiteralPath $CookieJar -Force -ErrorAction SilentlyContinue }
  $loginUrl = "https://$host/api/auth/login"
  $payload  = "{`"username`":`"$USER`",`"password`":`"$PASS`",`"rememberMe`":true}"
  $args = @('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20',
            '--resolve',("$host:443:$UDM_IP"),
            '-H','Accept: application/json','-H','Content-Type: application/json','-H','User-Agent: UDM-Audit-Cookie',
            '-c',$CookieJar,'-b',$CookieJar,'--data-binary',$payload,$loginUrl,'-w','%{http_code}')
  try{
    $code = & $curl.Source $args 2>$null
    if($code -match '^\d{3}$'){ [int]$code } else { -1 }
  }catch{ -1 }
}
function GetCsrfFromCookie(){
  if(Test-Path $CookieJar){
    try{
      $lines = Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII
      $m = [regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)')
      if($m.Count -gt 0){ return $m[$m.Count-1].Groups[1].Value.Trim() }
    }catch{}
  }
  return $null
}
function CurlJsonCookieHost([string]$host,[string]$path,[string]$outfile){
  $url = "https://$host$path"
  $csrf = GetCsrfFromCookie
  $args = @('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','25',
            '--resolve',("$host:443:$UDM_IP"),
            '-H','Accept: application/json','-H','User-Agent: UDM-Audit-Cookie',
            '-c',$CookieJar,'-b',$CookieJar,'-o',$outfile,'-w','%{http_code}', $url)
  if($csrf){ $args = @('-H',("X-Csrf-Token: {0}" -f $csrf)) + $args }
  try{
    $code = & $curl.Source $args 2>$null
    if($code -match '^\d{3}$'){ [int]$code } else { -1 }
  }catch{ -1 }
}
function FetchCookieHost([string]$host,[string]$path,[string]$label,[string]$name){
  $outfile = Join-Path $Reports ("$Prefix.$name.json")
  $code = CurlJsonCookieHost $host $path $outfile
  ("Cookie {0} via '{1}' -> {2}" -f $path,$host,$(if($code -ge 0){$code}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
  if($code -ge 200 -and $code -lt 300){ return $outfile } else { return $null }
}

if(-not [string]::IsNullOrWhiteSpace($UDM_IP) -and -not [string]::IsNullOrWhiteSpace($USER) -and -not [string]::IsNullOrWhiteSpace($PASS)){
  foreach($h in $HostCandidates){
    $lc = CurlLoginHost $h
    ("Cookie login try host '{0}' -> {1}" -f $h, $(if($lc -ge 0){$lc}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($lc -eq 200){ $loginOK=$true; $CookieHost=$h; break }
  }
  if($loginOK){
    Add-Content -LiteralPath $Summary -Value ("Cookie login OK using host '{0}'." -f $CookieHost) -Encoding UTF8
    $F_selfSites = FetchCookieHost $CookieHost "/proxy/network/api/self/sites" "self_sites" "self_sites"
    if($F_selfSites){
      try{
        $sj = Get-Content -LiteralPath $F_selfSites -Raw | ConvertFrom-Json
        $first = $null
        if($sj.data){ $first = $sj.data | Select-Object -First 1 }
        elseif($sj -is [System.Collections.IEnumerable] -and -not ($sj -is [string])){ $first = $sj | Select-Object -First 1 }
        if($first -and (HasProp $first 'name')){ $siteShort = $first.name }
      }catch{}
    }
    ("Network site short name: {0}" -f $siteShort) | Add-Content -LiteralPath $Summary -Encoding UTF8

    # Config and stats (read-only)
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/list/setting"        "list_setting"        "list_setting")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/rest/networkconf"    "rest_networkconf"    "rest_networkconf")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/list/wlanconf"       "list_wlanconf"       "list_wlanconf")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/rest/portconf"       "rest_portconf"       "rest_portconf")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/list/usergroup"      "list_usergroup"      "list_usergroup")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallrule"   "rest_firewallrule"   "rest_firewallrule")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallgroup"  "rest_firewallgroup"  "rest_firewallgroup")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/device"         "stat_device"         "stat_device")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/sta"            "stat_sta"            "stat_sta")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/health"         "stat_health"         "stat_health")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/sysinfo"        "stat_sysinfo"        "stat_sysinfo")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/event"          "stat_event"          "stat_event")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/alarm"          "stat_alarm"          "stat_alarm")
  } else {
    Add-Content -LiteralPath $Summary -Value "Cookie login failed on all hostnames. Skipping config export." -Encoding UTF8
  }
} else {
  Add-Content -LiteralPath $Summary -Value 'Skipping cookie login: missing udm_user.txt or udm_pass.txt (prompted above if absent).' -Encoding UTF8
}

# ---------------- Top talkers ----------------
$F_clients_for_top = $null
if($F_clis){ $F_clients_for_top = $F_clis }
elseif(Test-Path (Join-Path $Reports "$Prefix.stat_sta.json")){ $F_clients_for_top = (Join-Path $Reports "$Prefix.stat_sta.json") }

$TopCSV = Join-Path $Reports "$Prefix.top_talkers.csv"
try{
  $rows=@()
  if($F_clients_for_top){
    $arr = ReadJsonFlex $F_clients_for_top
    foreach($c in $arr){
      $name = TryProp $c @('hostname','host_name','name','displayName','display_name','device_name','deviceName','fingerprint_name','mac')
      $ip   = TryProp $c @('ip','ip_address','ipAddress','ipv4','primaryIp','primary_ip')
      $ssid = TryProp $c @('ssid','essid','wifiNetwork','wifi_ssid','wlan_name','wlan','ap_ssid')
      $net  = TryProp $c @('network','network_name','networkName','vlan_name','vlan')
      $wiredFlag = TryProp $c @('is_wired','wired','isWired')
      $wired = $null; if($wiredFlag -ne $null){ $wired = [bool]$wiredFlag }
      $tx = TryNum $c @('tx_bytes','txBytes','tx','tx_total','tx_total_bytes')
      $rx = TryNum $c @('rx_bytes','rxBytes','rx','rx_total','rx_total_bytes')
      if((-not $tx) -or (-not $rx)){
        $stats = TryProp $c @('statistics','stats')
        if($stats){
          if(-not $tx){ $tx = TryNum $stats @('tx_bytes','txBytes','tx','tx_total','bytes_tx') }
          if(-not $rx){ $rx = TryNum $stats @('rx_bytes','rxBytes','rx','rx_total','bytes_rx') }
        }
      }
      if(-not $tx){ $tx=0 }; if(-not $rx){ $rx=0 }
      $rows += [pscustomobject]@{
        name=$name; ip=$ip; mac=(TryProp $c @('mac')); wired=$wired; ssid=$ssid; network=$net;
        tx_bytes=[double]$tx; rx_bytes=[double]$rx; total_bytes=([double]$tx+[double]$rx)
      }
    }
  }
  $top = $rows | Sort-Object -Property total_bytes -Descending | Select-Object -First 20
  if($top){ $top | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8
    ("Top talkers -> {0}" -f $TopCSV) | Add-Content -LiteralPath $Summary -Encoding UTF8
  } else {
    Add-Content -LiteralPath $Summary -Value 'Top talkers -> no bytes available.' -Encoding UTF8
  }
}catch{
  Add-Content -LiteralPath $Summary -Value ("Top talkers error: {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ---------------- Insights (config + clients) ----------------
try{
  $F_devs_int = $F_devs
  if(-not $F_devs_int -and (Test-Path (Join-Path $Reports "$Prefix.stat_device.json"))){ $F_devs_int = (Join-Path $Reports "$Prefix.stat_device.json") }
  $D = if($F_devs_int){ ReadJsonFlex $F_devs_int } else { @() }
  $C = if($F_clis){ ReadJsonFlex $F_clis } elseif(Test-Path (Join-Path $Reports "$Prefix.stat_sta.json")){ ReadJsonFlex (Join-Path $Reports "$Prefix.stat_sta.json") } else { @() }

  $ins = Join-Path $Reports ("config_insights_{0}.txt" -f $Stamp)
  "Config Insights - $(Get-Date)" | Set-Content -LiteralPath $ins -Encoding UTF8

  # Device inventory and firmware
  $kinds=@{}; $fw=@{}; $offline=@()
  foreach($d in $D){
    $kind = TryProp $d @('type','productLine','deviceType','model','role'); if(-not $kind){ $kind='device' }
    if(-not $kinds.ContainsKey($kind)){ $kinds[$kind]=0 }; $kinds[$kind]++
    $ver = TryProp $d @('firmware_version','firmwareVersion','version'); if($ver){ if(-not $fw.ContainsKey($ver)){ $fw[$ver]=0 }; $fw[$ver]++ }
    $up = $null
    if(HasProp $d 'up'){ $up=[bool]$d.up }
    elseif(HasProp $d 'connected'){ $up=[bool]$d.connected }
    elseif(HasProp $d 'online'){ $up=[bool]$d.online }
    elseif(HasProp $d 'status'){ $up = ($d.status.ToString().ToLower() -match 'up|online|connected|ready') }
    if(($up -ne $true)){ $offline += $d }
  }
  Add-Content $ins 'Devices:'
  foreach($k in (@($kinds.Keys) | Sort-Object)){ Add-Content $ins ("  - {0}: {1}" -f $k,$kinds[$k]) }
  if(@($fw.Keys).Count -gt 0){
    Add-Content $ins 'Firmware mix:'
    foreach($v in (@($fw.Keys) | Sort-Object)){ Add-Content $ins ("  - {0}: {1}" -f $v,$fw[$v]) }
  }
  Add-Content $ins ''

  # Pull cookie-based config files if present
  $F_wlan   = Join-Path $Reports "$Prefix.list_wlanconf.json"
  $F_net    = Join-Path $Reports "$Prefix.rest_networkconf.json"
  $F_ports  = Join-Path $Reports "$Prefix.rest_portconf.json"
  $F_fwr    = Join-Path $Reports "$Prefix.rest_firewallrule.json"
  $F_fwg    = Join-Path $Reports "$Prefix.rest_firewallgroup.json"
  $F_events = Join-Path $Reports "$Prefix.stat_event.json"

  $W = ReadJsonFlex $F_wlan
  $N = ReadJsonFlex $F_net
  $PR= ReadJsonFlex $F_ports
  $FR= ReadJsonFlex $F_fwr
  $FG= ReadJsonFlex $F_fwg
  $EV= ReadJsonFlex $F_events

  # WLAN checks
  if(SafeCount $W -gt 0){
    Add-Content $ins 'WLANs:'
    foreach($w in $W){
      $nm = TryProp $w @('name','ssid'); if(-not $nm){ $nm='(unnamed)' }
      $sec = TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version')
      $iso = TryProp $w @('isolation','ap_isolation','is_guest','guest')
      $pmf = TryProp $w @('pmf_mode','pmf','ocpmf')
      Add-Content $ins ("  - {0} | security={1} | isolation={2} | pmf={3}" -f $nm,$sec,$iso,$pmf)
    }
    Add-Content $ins ''
  }

  # Network/VLAN summary
  if(SafeCount $N -gt 0){
    $vlanCount = 0; $netCount = SafeCount $N
    foreach($n in $N){
      $v = TryProp $n @('vlan','vlan_id','vlanId'); if($v){ $vlanCount++ }
    }
    Add-Content $ins ("Networks: {0} (with VLAN tag on {1})" -f $netCount,$vlanCount)
  }

  # Firewall summary
  if(SafeCount $FR -gt 0){
    $enabled = @($FR | Where-Object { HasProp $_ 'enabled' -and $_.enabled -eq $true }).Count
    Add-Content $ins ("Firewall rules: total={0}, enabled={1}" -f (SafeCount $FR),$enabled)
    # flag broad allow on WAN_IN or LAN_IN
    $broad = @()
    foreach($r in $FR){
      $ruleset = TryProp $r @('ruleset','rule_set','direction')
      $act = TryProp $r @('action')
      $dst = TryProp $r @('dst_address','dst','destination','dst_network')
      if(($act -eq 'accept' -or $act -eq 'allow') -and ($ruleset -match 'WAN_IN|LAN_IN') -and ((-not $dst) -or $dst -match 'Any|any|0\.0\.0\.0/0')){
        $broad += $r
      }
    }
    if(SafeCount $broad -gt 0){ Add-Content $ins ("Warning: {0} broad allow rule(s) detected in WAN_IN/LAN_IN." -f (SafeCount $broad)) }
  }

  # Clients overview
  $wired=0; $wifi=0; $band24=0; $band5=0; $stale=@()
  $now = [DateTimeOffset]::UtcNow
  foreach($c in $C){
    $isWired = TryProp $c @('is_wired','wired','isWired'); if($isWired -ne $null){ if([bool]$isWired){$wired++}else{$wifi++} } else { $wifi++ }
    $radio = TryProp $c @('radio','band','phy')
    if($radio){
      $r = $radio.ToString().ToLower()
      if($r -match 'n|g|2\.4'){ $band24++ }
      elseif($r -match 'a|ac|ax|5'){ $band5++ }
    }
    $last = TryNum $c @('last_seen','lastSeen','last_seen_time','lastSeenTime')
    if($last){
      try{
        $epoch = [DateTimeOffset]::FromUnixTimeSeconds([int64]$last).UtcDateTime
        if(($now.UtcDateTime - $epoch).TotalDays -ge 7){ $stale += $c }
      }catch{}
    }
  }
  Add-Content $ins ("Clients: total={0}, wired={1}, wifi={2}" -f (SafeCount $C),$wired,$wifi)
  if(($band24 -or $band5)){ Add-Content $ins ("Band mix approx: 2.4GHz={0}, 5GHz={1}" -f $band24,$band5) }
  if(SafeCount $stale -gt 0){ Add-Content $ins ("Stale clients (>7d not seen): {0}" -f (SafeCount $stale)) }

  # Suggestions
  Add-Content $ins ''
  Add-Content $ins 'Suggestions:'
  if(SafeCount $W -gt 0){
    $open = @($W | Where-Object { ($_.security -match 'open') -or (TryProp $_ @('security','auth','wpa_mode') -eq 'open') })
    if(SafeCount $open -gt 0){ Add-Content $ins "  - One or more WLANs appear open. Enforce WPA2/WPA3 and enable PMF where compatible." }
    $nopmf = @($W | Where-Object { (TryProp $_ @('pmf_mode','pmf') -in @($null,'disabled','optional','0')) })
    if(SafeCount $nopmf -gt 0){ Add-Content $ins "  - PMF not required on some WLANs. Consider setting PMF Required on trusted SSIDs." }
    $guestish = @($W | Where-Object { (TryProp $_ @('is_guest','guest','isolation') -in @($null,$false)) })
    if(SafeCount $guestish -gt 0){ Add-Content $ins "  - Guest isolation not detected on some SSIDs. Consider guest policies for visitor WLANs." }
  }
  if((SafeCount $N) -le 1 -and (SafeCount $N) -ge 0){ Add-Content $ins "  - Single flat network detected (or not reported). Consider a separate IoT VLAN and inter-VLAN rules." }
  if(@($fw.Keys).Count -gt 1){ Add-Content $ins "  - Mixed firmware versions present. Plan a maintenance window to align firmware." }
  if($band24 -gt ($band5*2)){ Add-Content $ins "  - Many clients on 2.4GHz. Consider a 5GHz-preferred SSID or band-steering." }

  ("Config insights -> {0}" -f $ins) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{
  Add-Content -LiteralPath $Summary -Value ("Insights error: {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ---------------- Zip bundle ----------------
$Bundle = Join-Path $Reports "$Prefix.zip"
try{
  $toZip = Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -like "$Prefix*" -or $_.Name -like "config_insights_$Stamp.txt" }
  if($toZip){ Compress-Archive -Path ($toZip | Select-Object -ExpandProperty FullName) -DestinationPath $Bundle -Force }
  ("Bundle -> {0}" -f $Bundle) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{
  Add-Content -LiteralPath $Summary -Value ("Bundle error: {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ---------------- Optional Gist upload ----------------
try{
  if($GID -and $GTOK){
    $files=@{}
    Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -like "$Prefix*" -or $_.Name -eq ("config_insights_{0}.txt" -f $Stamp) } | ForEach-Object {
      $files[$_.Name] = @{ content = (Get-Content -LiteralPath $_.FullName -Raw) }
    }
    if($files.Count -gt 0){
      $payload=@{ files=$files } | ConvertTo-Json -Depth 7
      $uri="https://api.github.com/gists/$GID"
      $hdr=@{ Authorization=("token {0}" -f $GTOK); 'User-Agent'='UDM-AllInOne-Auditor-v2.2' }
      $resp=Invoke-WebRequest -Uri $uri -Method Patch -Headers $hdr -Body $payload -ContentType 'application/json' -UseBasicParsing
      if($resp.StatusCode -ge 200 -and $resp.StatusCode -lt 300){ Add-Content -LiteralPath $Summary -Value ("Attached to Gist {0}" -f $GID) -Encoding UTF8 }
    }
  }
}catch{
  Add-Content -LiteralPath $Summary -Value ("Gist upload skipped: {0}" -f $_.Exception.Message) -Encoding UTF8
}

Say ("Audit complete -> {0}" -f $Summary) "Green"
Get-Content -LiteralPath $Summary

PS C:\Windows\System32> TerminatingError(): "Cannot overwrite variable host because it is read-only or constant."
>> TerminatingError(): "Cannot overwrite variable host because it is read-only or constant."
Cannot overwrite variable host because it is read-only or constant.
WriteError: 
Line |
 199 |      $lc = CurlLoginHost $h
     |      ~~~~~~~~~~~~~~~~~~~~~~
     | Cannot overwrite variable host because it is read-only or constant.
PS C:\Windows\System32> cls
PS C:\Windows\System32> # ==================== START: PLEX_QUICK_SNAPSHOT ====================
# Safe to run while Plex is up (no stop). Focuses on config, DB, logs, and manifests.
# Skips huge metadata caches for speed (can be recreated by Plex).

# Guardrails
$ErrorActionPreference = 'Continue'
$ProgressPreference    = 'Continue'

# Where to put the backup
$OutRoot     = 'D:\PlexBackups'           # change if you like
$ToolsRoot   = 'D:\PlexTools'             # where sqlite3.exe already lives from earlier work
$Stamp       = (Get-Date -Format 'yyyyMMdd-HHmmss')
$BackupDir   = Join-Path $OutRoot ("PlexSnapshot-$Stamp")
$MetaDir     = Join-Path $BackupDir 'manifest'
$StageFile   = Join-Path $BackupDir 'backup-stage.txt'
$Log         = Join-Path $BackupDir ('plex-backup-{0}.log' -f $Stamp)
$Sqlite      = Join-Path (Join-Path $ToolsRoot 'bin') 'sqlite3.exe'

# Helpers
function Ensure-Dir([string]$p){ if(-not (Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Force -Path $p | Out-Null } }
function Banner([string]$t){ Write-Host ""; Write-Host ("==================== {0} ====================" -f $t) -ForegroundColor Magenta }
function Log([string]$m){ $ts=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss'); $line="[${ts}] $m"; $line | Tee-Object -FilePath $Log -Append | Out-Host }
function Stage([string]$s){ $ts=(Get-Date).ToString('HH:mm:ss'); ("{0} {1}" -f $ts,$s) | Out-File -FilePath $StageFile -Append -Encoding UTF8; Log ("Stage => {0}" -f $s) }
function Test-SqliteHeader([string]$p){
  try{
    if(-not (Test-Path $p -PathType Leaf)){ return $false }
    $fs=[IO.File]::Open($p,[IO.FileMode]::Open,[IO.FileAccess]::Read,[IO.FileShare]::ReadWrite)
    $buf=New-Object byte[] 16; $null=$fs.Read($buf,0,16); $fs.Close()
    return ([Text.Encoding]::ASCII.GetString($buf) -like "SQLite format 3*")
  }catch{ return $false }
}
function Invoke-Sqlite([string]$db,[string]$sql){
  if(-not (Test-Path $Sqlite -PathType Leaf)){ return $null }
  try{
    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName  = $Sqlite
    $psi.Arguments = ('-batch -noheader "{0}" "{1}"' -f $db, $sql.Replace('"','""'))
    $psi.RedirectStandardOutput = $true; $psi.RedirectStandardError = $true; $psi.UseShellExecute = $false
    $p=[Diagnostics.Process]::Start($psi); $out=$p.StandardOutput.ReadToEnd(); $err=$p.StandardError.ReadToEnd(); $p.WaitForExit()
    if($err){ Log ("sqlite ERR: {0}" -f $err.Trim()) }
    return $out
  }catch{ Log ("sqlite EXC: {0}" -f $_.Exception.Message); return $null }
}
function Copy-Dir([string]$src,[string]$dst,[string]$filter='*'){
  if(Test-Path $src){
    Ensure-Dir $dst
    try{
      # robocopy is resilient, fast, and handles long paths
      & robocopy $src $dst $filter /e /r:1 /w:1 /np /ndl /nfl | Out-Null
      Log ("Copied dir -> {0}" -f $src)
    }catch{ Log ("Copy dir FAILED -> {0}" -f $src) }
  }else{
    Log ("Dir missing -> {0}" -f $src)
  }
}

# Prep folders
Ensure-Dir $OutRoot
Ensure-Dir $BackupDir
Ensure-Dir $MetaDir

# ---------- Locate Plex Support root + DB ----------
Banner "LOCATE PLEX"
Stage  "Locate"
function Find-PlexSupport {
  $roots = @()
  if($env:LOCALAPPDATA){ $roots += (Join-Path $env:LOCALAPPDATA 'Plex Media Server') }
  if($env:ProgramData){  $roots += (Join-Path $env:ProgramData  'Plex Media Server') }
  $roots += 'C:\Windows\System32\config\systemprofile\AppData\Local\Plex Media Server'

  if(Test-Path 'C:\Users'){
    try{ Get-ChildItem 'C:\Users' -Directory -ErrorAction SilentlyContinue | ForEach-Object { $roots += (Join-Path $_.FullName 'AppData\Local\Plex Media Server') } }catch{}
  }
  # Common D:\ spots
  $roots += 'D:\Plex Media Server'
  if(Test-Path 'D:\Users'){
    try{ Get-ChildItem 'D:\Users' -Directory -ErrorAction SilentlyContinue | ForEach-Object { $roots += (Join-Path $_.FullName 'AppData\Local\Plex Media Server') } }catch{}
  }

  $roots = $roots | Where-Object { $_ -and (Test-Path $_) } | Select-Object -Unique
  if(-not $roots){ return $null }

  $best=$null
  $i=0; $total=[double][Math]::Max(1,$roots.Count)
  foreach($r in $roots){
    $i++; Write-Progress -Activity "Searching for Plex DB" -Status $r -PercentComplete ([int](($i/$total)*100))
    try{
      $dbDirect = Join-Path $r 'Plug-in Support\Databases\com.plexapp.plugins.library.db'
      if(Test-Path $dbDirect -PathType Leaf){ $best=@{Root=$r;Db=$dbDirect}; break }
      $hit = Get-ChildItem -LiteralPath $r -Recurse -Filter 'com.plexapp.plugins.library.db' -ErrorAction SilentlyContinue | Select-Object -First 1
      if($hit){ $best=@{Root=$r;Db=$hit.FullName}; break }
    }catch{}
  }
  Write-Progress -Activity "Searching for Plex DB" -Completed
  if($best){ return $best } else { return @{Root=$roots[0];Db=$null} }
}

$found    = Find-PlexSupport
$PlexRoot = $null
$DbPath   = $null
if($found){ $PlexRoot = $found.Root; $DbPath = $found.Db }
if($PlexRoot){ Log ("PlexRoot => {0}" -f $PlexRoot) } else { Log "PlexRoot => (not found)" }
if($DbPath){   Log ("DB Path  => {0}" -f $DbPath)   } else { Log "DB Path  => (not found)" }

# ---------- Identity & quick facts ----------
Banner "CAPTURE IDENTITY"
Stage  "Identity"
try{
  $iden = Invoke-WebRequest -Uri 'http://127.0.0.1:32400/identity' -UseBasicParsing -TimeoutSec 3
  if($iden -and $iden.Content){ $iden.Content | Set-Content -LiteralPath (Join-Path $MetaDir 'identity.xml') -Encoding UTF8; Log "Saved identity.xml" }
}catch{ Log "identity fetch skipped/failed (server might be busy)" }

# ---------- Copy core config & DB ----------
Banner "COPY CORE"
Stage  "CopyCore"

# Preferences + root files
if($PlexRoot){
  foreach($f in @('Preferences.xml','Services.xml','Network.xml')){
    $src = Join-Path $PlexRoot $f
    if(Test-Path $src -PathType Leaf){
      $dst = Join-Path $BackupDir ('_root_' + $f)
      try{ Copy-Item -LiteralPath $src -Destination $dst -Force; Log ("Copied -> {0}" -f $f) }catch{ Log ("Copy failed -> {0}" -f $f) }
    }
  }
}

# Databases folder (small + essential)
if($PlexRoot){
  $dbDirSrc = Join-Path $PlexRoot 'Plug-in Support\Databases'
  $dbDirDst = Join-Path $BackupDir 'Databases'
  Copy-Dir $dbDirSrc $dbDirDst
}

# Preferences & Profiles (small and useful)
if($PlexRoot){
  Copy-Dir (Join-Path $PlexRoot 'Plug-in Support\Preferences') (Join-Path $BackupDir 'Preferences')
  Copy-Dir (Join-Path $PlexRoot 'Plug-in Support\Profiles')    (Join-Path $BackupDir 'Profiles')
}

# Logs (handy for restore triage)
if($PlexRoot){
  Copy-Dir (Join-Path $PlexRoot 'Logs') (Join-Path $BackupDir 'Logs')
}

# Your existing DB backups from tools (these saved us tonight)
$ToolBackups = Join-Path $ToolsRoot 'DB-Backups'
if(Test-Path $ToolBackups -PathType Container){
  Copy-Dir $ToolBackups (Join-Path $BackupDir 'PlexTools-DB-Backups')
}

# Stremio service folders (tiny .strm trees)
$SvcRoot = 'D:\StremioCatalog'
if(Test-Path $SvcRoot -PathType Container){
  Copy-Dir $SvcRoot (Join-Path $BackupDir 'StremioCatalog')
}

# ---------- Manifests from DB (libraries & locations) ----------
Banner "EXPORT MANIFESTS"
Stage  "Manifests"

if( (Test-Path $DbPath -PathType Leaf) -and (Test-SqliteHeader $DbPath) -and (Test-Path $Sqlite -PathType Leaf) ){
  # Columns present?
  $pragmaSec = Invoke-Sqlite $DbPath "PRAGMA table_info(library_sections);"
  $pragmaLoc = Invoke-Sqlite $DbPath "PRAGMA table_info(section_locations);"

  function Parse-ColNames([string]$t){
    $names=@()
    foreach($line in ($t -split "`n")){
      if($line -match '^\|?(\d+)\|([^|]+)\|'){ $names += $matches[2].Trim() }
    }
    return $names
  }
  $secColsAvail = Parse-ColNames $pragmaSec
  $locColsAvail = Parse-ColNames $pragmaLoc

  # Prefer informative columns; intersect with availability
  $secWanted = @('id','name','section_type','agent','scanner','language','uuid')
  $locWanted = @('id','library_section_id','root_path')
  $secCols = @(); foreach($c in $secWanted){ if($secColsAvail -contains $c){ $secCols += $c } }
  $locCols = @(); foreach($c in $locWanted){ if($locColsAvail -contains $c){ $locCols += $c } }

  if($secCols.Count -lt 1){ $secCols = $secColsAvail }  # fallback
  if($locCols.Count -lt 1){ $locCols = $locColsAvail }

  $secCsv = ($secCols -join ',')
  $locCsv = ($locCols -join ',')

  $libs = Invoke-Sqlite $DbPath ("SELECT {0} FROM library_sections;" -f $secCsv)
  $locs = Invoke-Sqlite $DbPath ("SELECT {0} FROM section_locations;" -f $locCsv)

  if($libs){ $libs | Set-Content -LiteralPath (Join-Path $MetaDir 'libraries.pipe') -Encoding UTF8; Log "Exported libraries.pipe" }
  if($locs){ $locs | Set-Content -LiteralPath (Join-Path $MetaDir 'section_locations.pipe') -Encoding UTF8; Log "Exported section_locations.pipe" }
}else{
  Log "Skipped manifests (sqlite not available or DB not readable)."
}

# ---------- Hashes of key files (quick integrity check) ----------
Banner "HASH KEY FILES"
Stage  "Hashes"
try{
  $hashOut = Join-Path $MetaDir 'hashes.txt'
  $targets = @()
  if($DbPath -and (Test-Path $DbPath)){ $targets += $DbPath }
  $dbCopy = Join-Path $BackupDir 'Databases\com.plexapp.plugins.library.db'
  if(Test-Path $dbCopy){ $targets += $dbCopy }
  $prefCopy = Join-Path $BackupDir '_root_Preferences.xml'
  if(Test-Path $prefCopy){ $targets += $prefCopy }

  foreach($t in $targets){
    try{
      $h = Get-FileHash -Algorithm SHA256 -LiteralPath $t
      "{0}  {1}" -f $h.Hash,$t | Add-Content -LiteralPath $hashOut -Encoding UTF8
    }catch{}
  }
  if(Test-Path $hashOut){ Log "Wrote hashes.txt" }
}catch{ Log "Hash generation skipped." }

# ---------- Zip it up ----------
Banner "PACKAGE"
Stage  "Zip"
$ZipPath = "$BackupDir.zip"
try{
  if(Test-Path $ZipPath){ Remove-Item $ZipPath -Force -ErrorAction SilentlyContinue }
  Compress-Archive -Path (Join-Path $BackupDir '*') -DestinationPath $ZipPath -Force
  Log ("ZIP -> {0}" -f $ZipPath)
}catch{ Log ("ZIP failed -> {0}" -f $_.Exception.Message) }

# ---------- Pointers ----------
Banner "DONE"
Log ("Backup folder -> {0}" -f $BackupDir)
if(Test-Path $ZipPath){ Log ("Backup ZIP    -> {0}" -f $ZipPath) }
Write-Host ("Stage file     -> {0}" -f $StageFile) -ForegroundColor Green
Write-Host ("Log file       -> {0}" -f $Log)       -ForegroundColor Green
# ==================== END: PLEX_QUICK_SNAPSHOT ====================


==================== LOCATE PLEX ====================
[2025-10-06 19:28:17] Stage => Locate
[2025-10-06 19:28:18] PlexRoot => C:\Users\jason\AppData\Local\Plex Media Server
[2025-10-06 19:28:18] DB Path  => C:\Users\jason\AppData\Local\Plex Media Server\Plug-in Support\Databases\com.plexapp.plugins.library.db

==================== CAPTURE IDENTITY ====================
[2025-10-06 19:28:18] Stage => Identity
[2025-10-06 19:28:18] Saved identity.xml

==================== COPY CORE ====================
[2025-10-06 19:28:18] Stage => CopyCore
[2025-10-06 19:28:18] Copied -> Preferences.xml
[2025-10-06 19:28:35] Copied dir -> C:\Users\jason\AppData\Local\Plex Media Server\Plug-in Support\Databases
[2025-10-06 19:28:35] Copied dir -> C:\Users\jason\AppData\Local\Plex Media Server\Plug-in Support\Preferences
[2025-10-06 19:28:35] Dir missing -> C:\Users\jason\AppData\Local\Plex Media Server\Plug-in Support\Profiles
[2025-10-06 19:28:41] Copied dir -> C:\Users\jason\AppData\Local\Plex Media Server\Logs
[2025-10-06 19:28:55] Copied dir -> D:\PlexTools\DB-Backups
[2025-10-06 19:29:01] Copied dir -> D:\StremioCatalog

==================== EXPORT MANIFESTS ====================
[2025-10-06 19:29:01] Stage => Manifests
[2025-10-06 19:29:02] Exported libraries.pipe
[2025-10-06 19:29:02] Exported section_locations.pipe

==================== HASH KEY FILES ====================
[2025-10-06 19:29:02] Stage => Hashes
Get-FileHash: 
Line |
 212 |        $h = Get-FileHash -Algorithm SHA256 -LiteralPath $t
     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | The process cannot access the file 'C:\Users\jason\AppData\Local\Plex Media Server\Plug-in Support\Databases\com.plexapp.plugins.library.db' because it is being used by another process.
Get-FileHash: 
Line |
 212 |        $h = Get-FileHash -Algorithm SHA256 -LiteralPath $t
     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | The process cannot access the file 'C:\Users\jason\AppData\Local\Plex Media Server\Plug-in Support\Databases\com.plexapp.plugins.library.db' because it is being used by another process.
[2025-10-06 19:29:03] Wrote hashes.txt

==================== PACKAGE ====================
[2025-10-06 19:29:03] Stage => Zip
[2025-10-06 19:32:07] ZIP -> D:\PlexBackups\PlexSnapshot-20251006-192817.zip

==================== DONE ====================
[2025-10-06 19:32:07] Backup folder -> D:\PlexBackups\PlexSnapshot-20251006-192817
[2025-10-06 19:32:07] Backup ZIP    -> D:\PlexBackups\PlexSnapshot-20251006-192817.zip
Stage file     -> D:\PlexBackups\PlexSnapshot-20251006-192817\backup-stage.txt
Log file       -> D:\PlexBackups\PlexSnapshot-20251006-192817\plex-backup-20251006-192817.log
PS C:\Windows\System32> cls
PS C:\Windows\System32> # UDM All-in-One Auditor v2.3 â€” fix: avoid $host collision (renamed param to $sniHost)
# Integration API (X-API-KEY) + SNI-safe Cookie Config + Insights (single run, copy/paste)

$ErrorActionPreference='Stop'
Set-StrictMode -Version Latest

function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'), $m) -ForegroundColor $c }
function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
function HasProp($o,$n){ return ($o -ne $null) -and ($o.PSObject.Properties.Name -contains $n) -and ($o.$n -ne $null -and $o.$n -ne '') }
function TryProp { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ return $o.$n } } return $null }
function TryNum  { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ try{ return [double]$o.$n }catch{} } } return $null }
function ReadJsonFlex($p){
  if(-not (Test-Path $p)){ return @() }
  try{
    $j = Get-Content -LiteralPath $p -Raw | ConvertFrom-Json
    if($j -eq $null){ return @() }
    if($j.data){ return @($j.data) }
    elseif($j.items){ return @($j.items) }
    elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){ return @($j) }
    else { return @($j) }
  }catch{ return @() }
}
function SafeCount($x){ return @($x).Count }

# Paths
$Vault   = 'C:\Users\jason\OneDrive\Public\TOKENS'
$Root    = 'D:\PlexTools'
$Reports = Join-Path $Root 'reports'
$Cache   = Join-Path $Root 'cache'
Ensure-Dir $Reports; Ensure-Dir $Cache

$Stamp   = Get-Date -Format 'yyyyMMdd_HHmmss'
$Prefix  = "udm_audit_$Stamp"
$Summary = Join-Path $Reports "$Prefix.summary.txt"
"UDM All-in-One Auditor v2.3 - $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

# Load tokens
$UDM_IP    = ReadIf (Join-Path $Vault 'udm_ip.txt')
$API_KEY   = ***REDACTED*** (Join-Path $Vault 'udm_token.txt')
$USER      = ReadIf (Join-Path $Vault 'udm_user.txt')
$PASS      = ReadIf (Join-Path $Vault 'udm_pass.txt')
$GID       = ReadIf (Join-Path $Vault 'gist_id.txt')
$GTOK      = ReadIf (Join-Path $Vault 'gist_token.txt')
$UDM_HOSTF = ReadIf (Join-Path $Vault 'udm_hostname.txt')  # optional preferred hostname
if(-not $GTOK -and (Test-Path (Join-Path $Vault 'gist_token.bin'))){
  try{
    $bytes=[IO.File]::ReadAllBytes((Join-Path $Vault 'gist_token.bin'))
    $dec=[System.Security.Cryptography.ProtectedData]::Unprotect($bytes,$null,[System.Security.Cryptography.DataProtectionScope]::CurrentUser)
    $GTOK=[Text.Encoding]::UTF8.GetString($dec).Trim()
  }catch{}
}

# Auto-detect IP if missing
if([string]::IsNullOrWhiteSpace($UDM_IP)){
  $gw = (Get-NetIPConfiguration | Where-Object { $_.IPv4DefaultGateway -and $_.IPv4Address } | Select-Object -First 1)
  if($gw -and $gw.IPv4DefaultGateway){
    $UDM_IP = $gw.IPv4DefaultGateway.NextHop
    Set-Content -LiteralPath (Join-Path $Vault 'udm_ip.txt') -Value $UDM_IP -Encoding ASCII
  }
}
("UDM IP: {0}" -f ($(if($UDM_IP){$UDM_IP}else{'<missing>'}))) | Add-Content -LiteralPath $Summary -Encoding UTF8

# If controller creds missing, prompt once and persist
if([string]::IsNullOrWhiteSpace($USER)){
  $USER = Read-Host "Enter controller username"
  if(-not [string]::IsNullOrWhiteSpace($USER)){ Set-Content -LiteralPath (Join-Path $Vault 'udm_user.txt') -Value $USER -Encoding ASCII }
}
if([string]::IsNullOrWhiteSpace($PASS)){
  $sec = Read-Host "Enter controller password" -AsSecureString
  try{
    $bstr=[Runtime.InteropServices.Marshal]::SecureStringToBSTR($sec)
    $plain=[Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr)
    if(-not [string]::IsNullOrWhiteSpace($plain)){ Set-Content -LiteralPath (Join-Path $Vault 'udm_pass.txt') -Value $plain -Encoding ASCII }
  }finally{
    if($bstr){ [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr) }
  }
  $PASS = ReadIf (Join-Path $Vault 'udm_pass.txt')
}

# Environment hardening
$env:HTTP_PROXY=''; $env:HTTPS_PROXY=''; $env:ALL_PROXY=''
[System.Net.WebRequest]::DefaultWebProxy = $null
try{
  [System.Net.ServicePointManager]::Expect100Continue = $false
  $sp=[System.Net.ServicePointManager]::SecurityProtocol
  if(($sp -band [Net.SecurityProtocolType]::Tls12) -eq 0){ [System.Net.ServicePointManager]::SecurityProtocol = $sp -bor [Net.SecurityProtocolType]::Tls12 }
}catch{}

# curl
$curl = Get-Command curl.exe -ErrorAction SilentlyContinue
if(-not $curl){ Add-Content -LiteralPath $Summary -Value 'curl.exe not found in PATH.' -Encoding UTF8; throw 'curl missing' }

# ---------------- Integration API (X-API-KEY) ----------------
$F_sites = $null; $F_devs = $null; $F_clis = $null; $siteId = 'default'
if(-not [string]::IsNullOrWhiteSpace($UDM_IP) -and -not [string]::IsNullOrWhiteSpace($API_KEY)){
  $BaseInteg = "https://$UDM_IP/proxy/network/integration/v1"
  function CurlJsonInteg { param([string]$path,[string]$outfile)
    $url = "$BaseInteg$path"
    $args = @('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20',
              '-H','Accept: application/json','-H',("X-API-KEY: $API_KEY"),
              '-H','User-Agent: UDM-Audit-Integ','-o',$outfile,'-w','%{http_code}', $url)
    try{
      $codeRaw = & $curl.Source $args 2>$null
      if($codeRaw -match '^\d{3}$'){ [int]$codeRaw } else { -1 }
    }catch{ -1 }
  }
  function FetchInteg { param([string]$path,[string]$name)
    $outfile = Join-Path $Reports ("$Prefix.$name.json")
    $code = CurlJsonInteg $path $outfile
    ("Integration {0} -> {1}" -f $path, $(if($code -ge 0){$code}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($code -ge 200 -and $code -lt 300){ return $outfile } else { return $null }
  }

  $F_sites = FetchInteg '/sites' 'sites'
  if($F_sites){
    try{
      $sj = Get-Content -LiteralPath $F_sites -Raw | ConvertFrom-Json
      $first = $null
      if($sj -is [System.Collections.IEnumerable] -and -not ($sj -is [string])){ $first = $sj | Select-Object -First 1 }
      elseif($sj.data){ $first = $sj.data | Select-Object -First 1 }
      elseif($sj.items){ $first = $sj.items | Select-Object -First 1 }
      if($first){
        if(HasProp $first 'id'){ $siteId = $first.id }
        elseif(HasProp $first 'site'){ $siteId = $first.site }
        elseif(HasProp $first 'name'){ $siteId = ($first.name.ToString()).ToLowerInvariant() }
      }
    }catch{}
    ("Integration siteId: {0}" -f $siteId) | Add-Content -LiteralPath $Summary -Encoding UTF8
    $F_devs = FetchInteg "/sites/$siteId/devices" 'devices'
    $F_clis = FetchInteg "/sites/$siteId/clients" 'clients'
  } else {
    Add-Content -LiteralPath $Summary -Value 'Integration sites call failed (check X-API-KEY).' -Encoding UTF8
  }
} else {
  Add-Content -LiteralPath $Summary -Value 'Skipping Integration API: missing IP or X-API-KEY.' -Encoding UTF8
}

# ---------------- Cookie session (Network app) with SNI-safe host probing ----------------
$CookieJar = Join-Path $Cache ("udm_cookie_{0}.txt" -f $Stamp)
$F_selfSites = $null
$siteShort = 'default'
$loginOK = $false
$CookieHost = $null

$HostCandidates = @()
if($UDM_HOSTF){ $HostCandidates += $UDM_HOSTF }
$HostCandidates += @('unifi','udm','unifi.localdomain','unifi.home','udm.home','udm.local')
$HostCandidates = $HostCandidates | Select-Object -Unique

function CurlLoginHost { param([string]$sniHost)
  if(Test-Path $CookieJar){ Remove-Item -LiteralPath $CookieJar -Force -ErrorAction SilentlyContinue }
  $loginUrl = "https://$sniHost/api/auth/login"
  $payload  = "{`"username`":`"$USER`",`"password`":`"$PASS`",`"rememberMe`":true}"
  $args = @('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20',
            '--resolve',("$sniHost:443:$UDM_IP"),
            '-H','Accept: application/json','-H','Content-Type: application/json','-H','User-Agent: UDM-Audit-Cookie',
            '-c',$CookieJar,'-b',$CookieJar,'--data-binary',$payload,$loginUrl,'-w','%{http_code}')
  try{
    $code = & $curl.Source $args 2>$null
    if($code -match '^\d{3}$'){ [int]$code } else { -1 }
  }catch{ -1 }
}
function GetCsrfFromCookie(){
  if(Test-Path $CookieJar){
    try{
      $lines = Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII
      $m = [regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)')
      if($m.Count -gt 0){ return $m[$m.Count-1].Groups[1].Value.Trim() }
    }catch{}
  }
  return $null
}
function CurlJsonCookieHost([string]$sniHost,[string]$path,[string]$outfile){
  $url = "https://$sniHost$path"
  $csrf = GetCsrfFromCookie
  $args = @('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','25',
            '--resolve',("$sniHost:443:$UDM_IP"),
            '-H','Accept: application/json','-H','User-Agent: UDM-Audit-Cookie',
            '-c',$CookieJar,'-b',$CookieJar,'-o',$outfile,'-w','%{http_code}', $url)
  if($csrf){ $args = @('-H',("X-Csrf-Token: {0}" -f $csrf)) + $args }
  try{
    $code = & $curl.Source $args 2>$null
    if($code -match '^\d{3}$'){ [int]$code } else { -1 }
  }catch{ -1 }
}
function FetchCookieHost([string]$sniHost,[string]$path,[string]$label,[string]$name){
  $outfile = Join-Path $Reports ("$Prefix.$name.json")
  $code = CurlJsonCookieHost $sniHost $path $outfile
  ("Cookie {0} via '{1}' -> {2}" -f $path,$sniHost,$(if($code -ge 0){$code}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
  if($code -ge 200 -and $code -lt 300){ return $outfile } else { return $null }
}

if(-not [string]::IsNullOrWhiteSpace($UDM_IP) -and -not [string]::IsNullOrWhiteSpace($USER) -and -not [string]::IsNullOrWhiteSpace($PASS)){
  foreach($h in $HostCandidates){
    $lc = CurlLoginHost $h
    ("Cookie login try host '{0}' -> {1}" -f $h, $(if($lc -ge 0){$lc}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($lc -eq 200){ $loginOK=$true; $CookieHost=$h; break }
  }
  if($loginOK){
    Add-Content -LiteralPath $Summary -Value ("Cookie login OK using host '{0}'." -f $CookieHost) -Encoding UTF8
    $F_selfSites = FetchCookieHost $CookieHost "/proxy/network/api/self/sites" "self_sites" "self_sites"
    if($F_selfSites){
      try{
        $sj = Get-Content -LiteralPath $F_selfSites -Raw | ConvertFrom-Json
        $first = $null
        if($sj.data){ $first = $sj.data | Select-Object -First 1 }
        elseif($sj -is [System.Collections.IEnumerable] -and -not ($sj -is [string])){ $first = $sj | Select-Object -First 1 }
        if($first -and (HasProp $first 'name')){ $siteShort = $first.name }
      }catch{}
    }
    ("Network site short name: {0}" -f $siteShort) | Add-Content -LiteralPath $Summary -Encoding UTF8

    # Config and stats (read-only)
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/list/setting"        "list_setting"        "list_setting")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/rest/networkconf"    "rest_networkconf"    "rest_networkconf")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/list/wlanconf"       "list_wlanconf"       "list_wlanconf")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/rest/portconf"       "rest_portconf"       "rest_portconf")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/list/usergroup"      "list_usergroup"      "list_usergroup")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallrule"   "rest_firewallrule"   "rest_firewallrule")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallgroup"  "rest_firewallgroup"  "rest_firewallgroup")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/device"         "stat_device"         "stat_device")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/sta"            "stat_sta"            "stat_sta")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/health"         "stat_health"         "stat_health")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/sysinfo"        "stat_sysinfo"        "stat_sysinfo")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/event"          "stat_event"          "stat_event")
    [void](FetchCookieHost $CookieHost "/proxy/network/api/s/$siteShort/stat/alarm"          "stat_alarm"          "stat_alarm")
  } else {
    Add-Content -LiteralPath $Summary -Value "Cookie login failed on all hostnames. Skipping config export." -Encoding UTF8
  }
} else {
  Add-Content -LiteralPath $Summary -Value 'Skipping cookie login: missing udm_user.txt or udm_pass.txt (prompted above if absent).' -Encoding UTF8
}

# ---------------- Top talkers ----------------
$F_clients_for_top = $null
if($F_clis){ $F_clients_for_top = $F_clis }
elseif(Test-Path (Join-Path $Reports "$Prefix.stat_sta.json")){ $F_clients_for_top = (Join-Path $Reports "$Prefix.stat_sta.json") }

$TopCSV = Join-Path $Reports "$Prefix.top_talkers.csv"
try{
  $rows=@()
  if($F_clients_for_top){
    $arr = ReadJsonFlex $F_clients_for_top
    foreach($c in $arr){
      $name = TryProp $c @('hostname','host_name','name','displayName','display_name','device_name','deviceName','fingerprint_name','mac')
      $ip   = TryProp $c @('ip','ip_address','ipAddress','ipv4','primaryIp','primary_ip')
      $ssid = TryProp $c @('ssid','essid','wifiNetwork','wifi_ssid','wlan_name','wlan','ap_ssid')
      $net  = TryProp $c @('network','network_name','networkName','vlan_name','vlan')
      $wiredFlag = TryProp $c @('is_wired','wired','isWired')
      $wired = $null; if($wiredFlag -ne $null){ $wired = [bool]$wiredFlag }
      $tx = TryNum $c @('tx_bytes','txBytes','tx','tx_total','tx_total_bytes')
      $rx = TryNum $c @('rx_bytes','rxBytes','rx','rx_total','rx_total_bytes')
      if((-not $tx) -or (-not $rx)){
        $stats = TryProp $c @('statistics','stats')
        if($stats){
          if(-not $tx){ $tx = TryNum $stats @('tx_bytes','txBytes','tx','tx_total','bytes_tx') }
          if(-not $rx){ $rx = TryNum $stats @('rx_bytes','rxBytes','rx','rx_total','bytes_rx') }
        }
      }
      if(-not $tx){ $tx=0 }; if(-not $rx){ $rx=0 }
      $rows += [pscustomobject]@{
        name=$name; ip=$ip; mac=(TryProp $c @('mac')); wired=$wired; ssid=$ssid; network=$net;
        tx_bytes=[double]$tx; rx_bytes=[double]$rx; total_bytes=([double]$tx+[double]$rx)
      }
    }
  }
  $top = $rows | Sort-Object -Property total_bytes -Descending | Select-Object -First 20
  if($top){ $top | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8
    ("Top talkers -> {0}" -f $TopCSV) | Add-Content -LiteralPath $Summary -Encoding UTF8
  } else {
    Add-Content -LiteralPath $Summary -Value 'Top talkers -> no bytes available.' -Encoding UTF8
  }
}catch{
  Add-Content -LiteralPath $Summary -Value ("Top talkers error: {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ---------------- Insights (config + clients) ----------------
try{
  $F_devs_int = $F_devs
  if(-not $F_devs_int -and (Test-Path (Join-Path $Reports "$Prefix.stat_device.json"))){ $F_devs_int = (Join-Path $Reports "$Prefix.stat_device.json") }
  $D = if($F_devs_int){ ReadJsonFlex $F_devs_int } else { @() }
  $C = if($F_clis){ ReadJsonFlex $F_clis } elseif(Test-Path (Join-Path $Reports "$Prefix.stat_sta.json")){ ReadJsonFlex (Join-Path $Reports "$Prefix.stat_sta.json") } else { @() }

  $ins = Join-Path $Reports ("config_insights_{0}.txt" -f $Stamp)
  "Config Insights - $(Get-Date)" | Set-Content -LiteralPath $ins -Encoding UTF8

  # Device inventory and firmware
  $kinds=@{}; $fw=@{}; $offline=@()
  foreach($d in $D){
    $kind = TryProp $d @('type','productLine','deviceType','model','role'); if(-not $kind){ $kind='device' }
    if(-not $kinds.ContainsKey($kind)){ $kinds[$kind]=0 }; $kinds[$kind]++
    $ver = TryProp $d @('firmware_version','firmwareVersion','version'); if($ver){ if(-not $fw.ContainsKey($ver)){ $fw[$ver]=0 }; $fw[$ver]++ }
    $up = $null
    if(HasProp $d 'up'){ $up=[bool]$d.up }
    elseif(HasProp $d 'connected'){ $up=[bool]$d.connected }
    elseif(HasProp $d 'online'){ $up=[bool]$d.online }
    elseif(HasProp $d 'status'){ $up = ($d.status.ToString().ToLower() -match 'up|online|connected|ready') }
    if(($up -ne $true)){ $offline += $d }
  }
  Add-Content $ins 'Devices:'
  foreach($k in (@($kinds.Keys) | Sort-Object)){ Add-Content $ins ("  - {0}: {1}" -f $k,$kinds[$k]) }
  if(@($fw.Keys).Count -gt 0){
    Add-Content $ins 'Firmware mix:'
    foreach($v in (@($fw.Keys) | Sort-Object)){ Add-Content $ins ("  - {0}: {1}" -f $v,$fw[$v]) }
  }
  Add-Content $ins ''

  # Pull cookie-based config files if present
  $F_wlan   = Join-Path $Reports "$Prefix.list_wlanconf.json"
  $F_net    = Join-Path $Reports "$Prefix.rest_networkconf.json"
  $F_ports  = Join-Path $Reports "$Prefix.rest_portconf.json"
  $F_fwr    = Join-Path $Reports "$Prefix.rest_firewallrule.json"
  $F_fwg    = Join-Path $Reports "$Prefix.rest_firewallgroup.json"
  $F_events = Join-Path $Reports "$Prefix.stat_event.json"

  $W = ReadJsonFlex $F_wlan
  $N = ReadJsonFlex $F_net
  $PR= ReadJsonFlex $F_ports
  $FR= ReadJsonFlex $F_fwr
  $FG= ReadJsonFlex $F_fwg
  $EV= ReadJsonFlex $F_events

  # WLAN checks
  if(SafeCount $W -gt 0){
    Add-Content $ins 'WLANs:'
    foreach($w in $W){
      $nm = TryProp $w @('name','ssid'); if(-not $nm){ $nm='(unnamed)' }
      $sec = TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version')
      $iso = TryProp $w @('isolation','ap_isolation','is_guest','guest')
      $pmf = TryProp $w @('pmf_mode','pmf','ocpmf')
      Add-Content $ins ("  - {0} | security={1} | isolation={2} | pmf={3}" -f $nm,$sec,$iso,$pmf)
    }
    Add-Content $ins ''
  }

  # Network/VLAN summary
  if(SafeCount $N -gt 0){
    $vlanCount = 0; $netCount = SafeCount $N
    foreach($n in $N){
      $v = TryProp $n @('vlan','vlan_id','vlanId'); if($v){ $vlanCount++ }
    }
    Add-Content $ins ("Networks: {0} (with VLAN tag on {1})" -f $netCount,$vlanCount)
  }

  # Firewall summary
  if(SafeCount $FR -gt 0){
    $enabled = @($FR | Where-Object { HasProp $_ 'enabled' -and $_.enabled -eq $true }).Count
    Add-Content $ins ("Firewall rules: total={0}, enabled={1}" -f (SafeCount $FR),$enabled)
    # flag broad allow on WAN_IN or LAN_IN
    $broad = @()
    foreach($r in $FR){
      $ruleset = TryProp $r @('ruleset','rule_set','direction')
      $act = TryProp $r @('action')
      $dst = TryProp $r @('dst_address','dst','destination','dst_network')
      if(($act -eq 'accept' -or $act -eq 'allow') -and ($ruleset -match 'WAN_IN|LAN_IN') -and ((-not $dst) -or $dst -match 'Any|any|0\.0\.0\.0/0')){
        $broad += $r
      }
    }
    if(SafeCount $broad -gt 0){ Add-Content $ins ("Warning: {0} broad allow rule(s) detected in WAN_IN/LAN_IN." -f (SafeCount $broad)) }
  }

  # Clients overview
  $wired=0; $wifi=0; $band24=0; $band5=0; $stale=@()
  $now = [DateTimeOffset]::UtcNow
  foreach($c in $C){
    $isWired = TryProp $c @('is_wired','wired','isWired'); if($isWired -ne $null){ if([bool]$isWired){$wired++}else{$wifi++} } else { $wifi++ }
    $radio = TryProp $c @('radio','band','phy')
    if($radio){
      $r = $radio.ToString().ToLower()
      if($r -match 'n|g|2\.4'){ $band24++ }
      elseif($r -match 'a|ac|ax|5'){ $band5++ }
    }
    $last = TryNum $c @('last_seen','lastSeen','last_seen_time','lastSeenTime')
    if($last){
      try{
        $epoch = [DateTimeOffset]::FromUnixTimeSeconds([int64]$last).UtcDateTime
        if(($now.UtcDateTime - $epoch).TotalDays -ge 7){ $stale += $c }
      }catch{}
    }
  }
  Add-Content $ins ("Clients: total={0}, wired={1}, wifi={2}" -f (SafeCount $C),$wired,$wifi)
  if(($band24 -or $band5)){ Add-Content $ins ("Band mix approx: 2.4GHz={0}, 5GHz={1}" -f $band24,$band5) }
  if(SafeCount $stale -gt 0){ Add-Content $ins ("Stale clients (>7d not seen): {0}" -f (SafeCount $stale)) }

  # Suggestions
  Add-Content $ins ''
  Add-Content $ins 'Suggestions:'
  if(SafeCount $W -gt 0){
    $open = @($W | Where-Object { ($_.security -match 'open') -or (TryProp $_ @('security','auth','wpa_mode') -eq 'open') })
    if(SafeCount $open -gt 0){ Add-Content $ins "  - One or more WLANs appear open. Enforce WPA2/WPA3 and enable PMF where compatible." }
    $nopmf = @($W | Where-Object { (TryProp $_ @('pmf_mode','pmf') -in @($null,'disabled','optional','0')) })
    if(SafeCount $nopmf -gt 0){ Add-Content $ins "  - PMF not required on some WLANs. Consider setting PMF Required on trusted SSIDs." }
    $guestish = @($W | Where-Object { (TryProp $_ @('is_guest','guest','isolation') -in @($null,$false)) })
    if(SafeCount $guestish -gt 0){ Add-Content $ins "  - Guest isolation not detected on some SSIDs. Consider guest policies for visitor WLANs." }
  }
  if((SafeCount $N) -le 1 -and (SafeCount $N) -ge 0){ Add-Content $ins "  - Single flat network detected (or not reported). Consider a separate IoT VLAN and inter-VLAN rules." }
  if(@($fw.Keys).Count -gt 1){ Add-Content $ins "  - Mixed firmware versions present. Plan a maintenance window to align firmware." }
  if($band24 -gt ($band5*2)){ Add-Content $ins "  - Many clients on 2.4GHz. Consider a 5GHz-preferred SSID or band-steering." }

  ("Config insights -> {0}" -f $ins) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{
  Add-Content -LiteralPath $Summary -Value ("Insights error: {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ---------------- Zip bundle ----------------
$Bundle = Join-Path $Reports "$Prefix.zip"
try{
  $toZip = Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -like "$Prefix*" -or $_.Name -like "config_insights_$Stamp.txt" }
  if($toZip){ Compress-Archive -Path ($toZip | Select-Object -ExpandProperty FullName) -DestinationPath $Bundle -Force }
  ("Bundle -> {0}" -f $Bundle) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{
  Add-Content -LiteralPath $Summary -Value ("Bundle error: {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ---------------- Optional Gist upload ----------------
try{
  if($GID -and $GTOK){
    $files=@{}
    Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -like "$Prefix*" -or $_.Name -eq ("config_insights_{0}.txt" -f $Stamp) } | ForEach-Object {
      $files[$_.Name] = @{ content = (Get-Content -LiteralPath $_.FullName -Raw) }
    }
    if($files.Count -gt 0){
      $payload=@{ files=$files } | ConvertTo-Json -Depth 7
      $uri="https://api.github.com/gists/$GID"
      $hdr=@{ Authorization=("token {0}" -f $GTOK); 'User-Agent'='UDM-AllInOne-Auditor-v2.3' }
      $resp=Invoke-WebRequest -Uri $uri -Method Patch -Headers $hdr -Body $payload -ContentType 'application/json' -UseBasicParsing
      if($resp.StatusCode -ge 200 -and $resp.StatusCode -lt 300){ Add-Content -LiteralPath $Summary -Value ("Attached to Gist {0}" -f $GID) -Encoding UTF8 }
    }
  }
}catch{
  Add-Content -LiteralPath $Summary -Value ("Gist upload skipped: {0}" -f $_.Exception.Message) -Encoding UTF8
}

Say ("Audit complete -> {0}" -f $Summary) "Green"
Get-Content -LiteralPath $Summary

curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
PS C:\Windows\System32> CommandInvocation(Out-Null): "Out-Null"
PS C:\Windows\System32> CommandInvocation(Out-Null): "Out-Null"
PS C:\Windows\System32> CommandInvocation(Out-Null): "Out-Null"
PS C:\Windows\System32> CommandInvocation(Out-Null): "Out-Null"
[19:35:46] Audit complete -> D:\PlexTools\reports\udm_audit_20251006_193544.summary.txt
UDM All-in-One Auditor v2.3 - 10/06/2025 19:35:44
UDM IP: 192.168.1.1
Integration /sites -> 200
Integration siteId: 88f7af54-98f8-306a-a1c7-c9349722b1f6
Integration /sites/88f7af54-98f8-306a-a1c7-c9349722b1f6/devices -> 200
Integration /sites/88f7af54-98f8-306a-a1c7-c9349722b1f6/clients -> 200
Cookie login try host 'unifi' -> 0
Cookie login try host 'udm' -> 0
Cookie login try host 'unifi.localdomain' -> 0
Cookie login try host 'unifi.home' -> 0
Cookie login try host 'udm.home' -> 0
Cookie login try host 'udm.local' -> 0
Cookie login failed on all hostnames. Skipping config export.
Top talkers -> D:\PlexTools\reports\udm_audit_20251006_193544.top_talkers.csv
Config insights -> D:\PlexTools\reports\config_insights_20251006_193544.txt
Bundle -> D:\PlexTools\reports\udm_audit_20251006_193544.zip
Attached to Gist 5b621abce653010601f1cacbbf3bc249
PS C:\Windows\System32> cls
PS C:\Windows\System32> cls
PS C:\Windows\System32> # UDM All-in-One Auditor v2.4 â€” CSRF + Redirect-safe cookie login, Integration API, Insights (single run)
$ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
function HasProp($o,$n){ ($o -ne $null) -and ($o.PSObject.Properties.Name -contains $n) -and ($o.$n -ne $null -and $o.$n -ne '') }
function TryProp { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ return $o.$n } } return $null }
function TryNum  { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ try{ return [double]$o.$n }catch{} } } return $null }
function ReadJsonFlex($p){ if(-not (Test-Path $p)){ return @() }; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json
  if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }
function SafeCount($x){ @($x).Count }

# Paths/vars
$Vault='C:\Users\jason\OneDrive\Public\TOKENS'; $Root='D:\PlexTools'; $Reports=Join-Path $Root 'reports'; $Cache=Join-Path $Root 'cache'
Ensure-Dir $Reports; Ensure-Dir $Cache
$Stamp=Get-Date -Format 'yyyyMMdd_HHmmss'; $Prefix="udm_audit_$Stamp"; $Summary=Join-Path $Reports "$Prefix.summary.txt"
"UDM All-in-One Auditor v2.4 - $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

# Secrets
$UDM_IP=ReadIf (Join-Path $Vault 'udm_ip.txt'); $API_KEY=***REDACTED*** (Join-Path $Vault 'udm_token.txt')
$USER=ReadIf (Join-Path $Vault 'udm_user.txt'); $PASS=ReadIf (Join-Path $Vault 'udm_pass.txt')
$UDM_HOSTF=ReadIf (Join-Path $Vault 'udm_hostname.txt')
$GID=ReadIf (Join-Path $Vault 'gist_id.txt'); $GTOK=ReadIf (Join-Path $Vault 'gist_token.txt')
if(-not $GTOK -and (Test-Path (Join-Path $Vault 'gist_token.bin'))){ try{$bytes=[IO.File]::ReadAllBytes((Join-Path $Vault 'gist_token.bin'))
  $dec=[Security.Cryptography.ProtectedData]::Unprotect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
  $GTOK=[Text.Encoding]::UTF8.GetString($dec).Trim() }catch{} }

# Auto-detect UDM IP if missing
if([string]::IsNullOrWhiteSpace($UDM_IP)){
  $gw=(Get-NetIPConfiguration|?{ $_.IPv4DefaultGateway -and $_.IPv4Address }|Select-Object -First 1)
  if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII }
}
("UDM IP: {0}" -f ($(if($UDM_IP){$UDM_IP}else{'<missing>'}))) | Add-Content -LiteralPath $Summary -Encoding UTF8

# Prompt once for controller creds if missing
if([string]::IsNullOrWhiteSpace($USER)){ $USER=Read-Host "Enter controller username"; if($USER){ Set-Content (Join-Path $Vault 'udm_user.txt') $USER -Encoding ASCII } }
if([string]::IsNullOrWhiteSpace($PASS)){
  $sec=Read-Host "Enter controller password" -AsSecureString
  try{$b=[Runtime.InteropServices.Marshal]::SecureStringToBSTR($sec); $plain=[Runtime.InteropServices.Marshal]::PtrToStringBSTR($b)
    if($plain){ Set-Content (Join-Path $Vault 'udm_pass.txt') $plain -Encoding ASCII } }finally{ if($b){ [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($b) } }
  $PASS=ReadIf (Join-Path $Vault 'udm_pass.txt')
}

# Env hardening
$env:HTTP_PROXY=''; $env:HTTPS_PROXY=''; $env:ALL_PROXY=''; [Net.WebRequest]::DefaultWebProxy=$null
try{ [Net.ServicePointManager]::Expect100Continue=$false; $sp=[Net.ServicePointManager]::SecurityProtocol
  if(($sp -band [Net.SecurityProtocolType]::Tls12) -eq 0){ [Net.ServicePointManager]::SecurityProtocol=$sp -bor [Net.SecurityProtocolType]::Tls12 } }catch{}

# curl present?
$curl=Get-Command curl.exe -ErrorAction SilentlyContinue
if(-not $curl){ Add-Content -LiteralPath $Summary -Value 'curl.exe not found in PATH.' -Encoding UTF8; throw 'curl missing' }

# ---------------- Integration API (X-API-KEY) ----------------
$F_sites=$null; $F_devs=$null; $F_clis=$null; $siteId='default'
if($UDM_IP -and $API_KEY){
  $BaseInteg="https://$UDM_IP/proxy/network/integration/v1"
  function CurlJsonInteg([string]$path,[string]$outfile){
    $url="$BaseInteg$path"
    $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20',
      '-H','Accept: application/json','-H',("X-API-KEY: $API_KEY"),'-H','User-Agent: UDM-Audit-Integ',
      '-o',$outfile,'-w','%{http_code}', $url)
    try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
  }
  function FetchInteg([string]$path,[string]$name){
    $outfile=Join-Path $Reports ("$Prefix.$name.json"); $code=CurlJsonInteg $path $outfile
    ("Integration {0} -> {1}" -f $path, $(if($code -ge 0){$code}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($code -ge 200 -and $code -lt 300){ $outfile } else { $null }
  }
  $F_sites=FetchInteg '/sites' 'sites'
  if($F_sites){
    try{ $sj=Get-Content -LiteralPath $F_sites -Raw|ConvertFrom-Json; $first=$null
      if($sj -is [Collections.IEnumerable] -and -not ($sj -is [string])){ $first=$sj|Select-Object -First 1 }
      elseif($sj.data){ $first=$sj.data|Select-Object -First 1 } elseif($sj.items){ $first=$sj.items|Select-Object -First 1 }
      if($first){ if(HasProp $first 'id'){ $siteId=$first.id } elseif(HasProp $first 'site'){ $siteId=$first.site } elseif(HasProp $first 'name'){ $siteId=($first.name.ToString()).ToLowerInvariant() } }
    }catch{}
    ("Integration siteId: {0}" -f $siteId) | Add-Content -LiteralPath $Summary -Encoding UTF8
    $F_devs=FetchInteg "/sites/$siteId/devices" 'devices'
    $F_clis=FetchInteg "/sites/$siteId/clients" 'clients'
  } else { Add-Content -LiteralPath $Summary -Value 'Integration sites call failed (check X-API-KEY).' -Encoding UTF8 }
} else { Add-Content -LiteralPath $Summary -Value 'Skipping Integration API: missing IP or X-API-KEY.' -Encoding UTF8 }

# ---------------- Cookie session with CSRF + redirect-safe + SNI ----------------
$CookieJar=Join-Path $Cache ("udm_cookie_{0}.txt" -f $Stamp); $loginOK=$false; $CookieHost=$null; $siteShort='default'
$Hosts=@(); if($UDM_HOSTF){$Hosts+=$UDM_HOSTF}; $Hosts+=@('unifi','udm','unifi.localdomain','unifi.home','udm.home','udm.local'); if($UDM_IP){$Hosts+=$UDM_IP}
$Hosts=$Hosts|Select-Object -Unique
# Prebuild --resolve for all candidate names (helps redirects that point to another name)
$ResolveArgs=@(); foreach($h in $Hosts){ if($h -notmatch '^\d+\.\d+\.\d+\.\d+$' -and $UDM_IP){ $ResolveArgs += @('--resolve',("$h:443:$UDM_IP")) } }
if($UDM_IP){ $ResolveArgs += @('--resolve',("$UDM_IP:443:$UDM_IP")) }

function CurlGetCsrf([string]$h,[string]$csrfOut){
  if(Test-Path $CookieJar){ Remove-Item -LiteralPath $CookieJar -Force -ErrorAction SilentlyContinue }
  $url="https://$h/api/auth/csrf"
  $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','12','-L') + $ResolveArgs +
        @('-H','Accept: application/json','-H','User-Agent: UDM-Audit-Cookie','-c',$CookieJar,'-b',$CookieJar,'-o',$csrfOut,'-w','%{http_code}', $url)
  try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
}
function CurlLogin([string]$h,[string]$token){
  $loginUrl="https://$h/api/auth/login"
  $payload="{`"username`":`"$USER`",`"password`":`"$PASS`",`"rememberMe`":true}"
  $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20','-L') + $ResolveArgs +
        @('-H','Accept: application/json','-H','Content-Type: application/json','-H','User-Agent: UDM-Audit-Cookie',
          '-H',("Origin: https://$h"),'-H',("Referer: https://$h/"),'-H',("X-Csrf-Token: $token"),
          '-c',$CookieJar,'-b',$CookieJar,'--data-binary',$payload,$loginUrl,'-w','%{http_code}')
  try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
}
function CurlJsonCookie([string]$h,[string]$path,[string]$outfile){
  $url="https://$h$path"
  # read latest CSRF cookie if any
  $csrf=$null; if(Test-Path $CookieJar){ try{ $lines=Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII; $m=[regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)'); if($m.Count -gt 0){ $csrf=$m[$m.Count-1].Groups[1].Value.Trim() } }catch{} }
  $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','25','-L') + $ResolveArgs +
        @('-H','Accept: application/json','-H','User-Agent: UDM-Audit-Cookie','-c',$CookieJar,'-b',$CookieJar,
          '-o',$outfile,'-w','%{http_code}', $url)
  if($csrf){ $args = @('-H',("X-Csrf-Token: $csrf")) + $args }
  try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
}
function FetchCookie([string]$h,[string]$path,[string]$name){
  $outfile=Join-Path $Reports ("$Prefix.$name.json"); $code=CurlJsonCookie $h $path $outfile
  $show = if($code -eq 0){'000 (TLS/redirect/DNS)'}elseif($code -lt 0){'tls/err'}else{$code}
  ("Cookie {0} via '{1}' -> {2}" -f $path,$h,$show) | Add-Content -LiteralPath $Summary -Encoding UTF8
  if($code -ge 200 -and $code -lt 300){ $outfile } else { $null }
}

if($UDM_IP -and $USER -and $PASS){
  foreach($h in $Hosts){
    $csrfFile=Join-Path $Cache "csrf_$($h)_$Stamp.json"
    $c=CurlGetCsrf $h $csrfFile
    $show = if($c -eq 0){'000 (TLS/redirect/DNS)'}elseif($c -lt 0){'tls/err'}else{$c}
    ("CSRF try host '{0}' -> {1}" -f $h,$show) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($c -eq 200){
      $tok=$null; try{ $cj=Get-Content -LiteralPath $csrfFile -Raw|ConvertFrom-Json; $tok = TryProp $cj @('token','csrfToken','csrf','csrf_token') }catch{}
      if(-not $tok){ # sometimes only cookie is set; try cookie jar
        try{ $lines=Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII; $m=[regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)'); if($m.Count -gt 0){ $tok=$m[$m.Count-1].Groups[1].Value.Trim() } }catch{}
      }
      if($tok){
        $lc=CurlLogin $h $tok
        $show2 = if($lc -eq 0){'000 (TLS/redirect/DNS)'}elseif($lc -lt 0){'tls/err'}else{$lc}
        ("Cookie login try host '{0}' -> {1}" -f $h,$show2) | Add-Content -LiteralPath $Summary -Encoding UTF8
        if($lc -eq 200){ $loginOK=$true; $CookieHost=$h; break }
      } else {
        ("Host '{0}' returned CSRF 200 but no token; continuing." -f $h) | Add-Content -LiteralPath $Summary -Encoding UTF8
      }
    }
  }

  if($loginOK){
    Add-Content -LiteralPath $Summary -Value ("Cookie login OK using host '{0}'." -f $CookieHost) -Encoding UTF8
    # Discover site short name
    $F_self=FetchCookie $CookieHost "/proxy/network/api/self/sites" "self_sites"
    $siteShort='default'
    if($F_self){ try{ $sj=Get-Content -LiteralPath $F_self -Raw|ConvertFrom-Json; $first=$null
      if($sj.data){ $first=$sj.data|Select-Object -First 1 } elseif($sj -is [Collections.IEnumerable] -and -not ($sj -is [string])){ $first=$sj|Select-Object -First 1 }
      if($first -and (HasProp $first 'name')){ $siteShort=$first.name } }catch{} }
    ("Network site short name: {0}" -f $siteShort) | Add-Content -LiteralPath $Summary -Encoding UTF8

    # Pull config & stats (legacy API still richest)
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/list/setting"        "list_setting")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/networkconf"    "rest_networkconf")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/list/wlanconf"       "list_wlanconf")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/portconf"       "rest_portconf")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/list/usergroup"      "list_usergroup")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallrule"   "rest_firewallrule")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallgroup"  "rest_firewallgroup")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/device"         "stat_device")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/sta"            "stat_sta")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/health"         "stat_health")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/sysinfo"        "stat_sysinfo")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/event"          "stat_event")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/alarm"          "stat_alarm")
  } else {
    Add-Content -LiteralPath $Summary -Value "Cookie login failed after CSRF/redirect attempts. Skipping config export." -Encoding UTF8
  }
} else {
  Add-Content -LiteralPath $Summary -Value 'Skipping cookie login: missing IP/creds.' -Encoding UTF8
}

# ---------------- Top talkers from Integration/legacy ----------------
$F_clients_for_top=$null
if($F_clis){ $F_clients_for_top=$F_clis } elseif(Test-Path (Join-Path $Reports "$Prefix.stat_sta.json")){ $F_clients_for_top=(Join-Path $Reports "$Prefix.stat_sta.json") }
$TopCSV=Join-Path $Reports "$Prefix.top_talkers.csv"
try{
  $rows=@(); if($F_clients_for_top){ $arr=ReadJsonFlex $F_clients_for_top
    foreach($c in $arr){
      $name=TryProp $c @('hostname','host_name','name','displayName','display_name','device_name','deviceName','fingerprint_name','mac')
      $ip=TryProp $c @('ip','ip_address','ipAddress','ipv4','primaryIp','primary_ip')
      $ssid=TryProp $c @('ssid','essid','wifiNetwork','wifi_ssid','wlan_name','wlan','ap_ssid')
      $net=TryProp $c @('network','network_name','networkName','vlan_name','vlan')
      $wiredFlag=TryProp $c @('is_wired','wired','isWired'); $wired=$null; if($wiredFlag -ne $null){ $wired=[bool]$wiredFlag }
      $tx=TryNum $c @('tx_bytes','txBytes','tx','tx_total','tx_total_bytes'); $rx=TryNum $c @('rx_bytes','rxBytes','rx','rx_total','rx_total_bytes')
      if((-not $tx) -or (-not $rx)){ $stats=TryProp $c @('statistics','stats'); if($stats){ if(-not $tx){ $tx=TryNum $stats @('tx_bytes','txBytes','tx','tx_total','bytes_tx') }; if(-not $rx){ $rx=TryNum $stats @('rx_bytes','rxBytes','rx','rx_total','bytes_rx') } } }
      if(-not $tx){$tx=0}; if(-not $rx){$rx=0}
      $rows += [pscustomobject]@{ name=$name; ip=$ip; mac=(TryProp $c @('mac')); wired=$wired; ssid=$ssid; network=$net; tx_bytes=[double]$tx; rx_bytes=[double]$rx; total_bytes=([double]$tx+[double]$rx) }
    } }
  $top=$rows|Sort-Object total_bytes -Descending|Select-Object -First 20
  if($top){ $top|Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8; ("Top talkers -> {0}" -f $TopCSV)|Add-Content -LiteralPath $Summary -Encoding UTF8 }
  else { Add-Content -LiteralPath $Summary -Value 'Top talkers -> no bytes available.' -Encoding UTF8 }
}catch{ Add-Content -LiteralPath $Summary -Value ("Top talkers error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

# ---------------- Insights (uses what we have) ----------------
try{
  $F_devs_int=$F_devs; if(-not $F_devs_int -and (Test-Path (Join-Path $Reports "$Prefix.stat_device.json"))){ $F_devs_int=(Join-Path $Reports "$Prefix.stat_device.json") }
  $D=if($F_devs_int){ ReadJsonFlex $F_devs_int } else { @() }
  $C=if($F_clis){ ReadJsonFlex $F_clis } elseif(Test-Path (Join-Path $Reports "$Prefix.stat_sta.json")){ ReadJsonFlex (Join-Path $Reports "$Prefix.stat_sta.json") } else { @() }
  $ins=Join-Path $Reports ("config_insights_{0}.txt" -f $Stamp); "Config Insights - $(Get-Date)"|Set-Content -LiteralPath $ins -Encoding UTF8

  $kinds=@{}; $fw=@{}; foreach($d in $D){ $kind=TryProp $d @('type','productLine','deviceType','model','role'); if(-not $kind){$kind='device'}
    if(-not $kinds.ContainsKey($kind)){ $kinds[$kind]=0 }; $kinds[$kind]++
    $ver=TryProp $d @('firmware_version','firmwareVersion','version'); if($ver){ if(-not $fw.ContainsKey($ver)){ $fw[$ver]=0 }; $fw[$ver]++ } }
  Add-Content $ins 'Devices:'; foreach($k in (@($kinds.Keys)|Sort-Object)){ Add-Content $ins ("  - {0}: {1}" -f $k,$kinds[$k]) }
  if(@($fw.Keys).Count -gt 0){ Add-Content $ins 'Firmware mix:'; foreach($v in (@($fw.Keys)|Sort-Object)){ Add-Content $ins ("  - {0}: {1}" -f $v,$fw[$v]) } }
  Add-Content $ins ''

  $F_wlan=Join-Path $Reports "$Prefix.list_wlanconf.json"; $F_net=Join-Path $Reports "$Prefix.rest_networkconf.json"
  $F_ports=Join-Path $Reports "$Prefix.rest_portconf.json"; $F_fwr=Join-Path $Reports "$Prefix.rest_firewallrule.json"
  $W=ReadJsonFlex $F_wlan; $N=ReadJsonFlex $F_net; $FR=ReadJsonFlex $F_fwr
  if(SafeCount $W -gt 0){ Add-Content $ins 'WLANs:'; foreach($w in $W){ $nm=TryProp $w @('name','ssid'); if(-not $nm){$nm='(unnamed)'}
      $sec=TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version'); $iso=TryProp $w @('isolation','ap_isolation','is_guest','guest'); $pmf=TryProp $w @('pmf_mode','pmf','ocpmf')
      Add-Content $ins ("  - {0} | security={1} | isolation={2} | pmf={3}" -f $nm,$sec,$iso,$pmf) } ; Add-Content $ins '' }
  if(SafeCount $N -gt 0){ $v=0; foreach($n in $N){ if(TryProp $n @('vlan','vlan_id','vlanId')){$v++} }; Add-Content $ins ("Networks: {0} (with VLAN tag on {1})" -f (SafeCount $N),$v) }
  if(SafeCount $FR -gt 0){ $enabled=@($FR|?{ HasProp $_ 'enabled' -and $_.enabled -eq $true }).Count
    Add-Content $ins ("Firewall rules: total={0}, enabled={1}" -f (SafeCount $FR),$enabled) }

  $wired=0; $wifi=0; $band24=0; $band5=0; $stale=@(); $now=[DateTimeOffset]::UtcNow
  foreach($c in $C){
    $isWired=TryProp $c @('is_wired','wired','isWired'); if($isWired -ne $null){ if([bool]$isWired){$wired++}else{$wifi++} } else {$wifi++}
    $radio=TryProp $c @('radio','band','phy'); if($radio){ $r=$radio.ToString().ToLower(); if($r -match 'n|g|2\.4'){$band24++} elseif($r -match 'a|ac|ax|5'){$band5++} }
    $last=TryNum $c @('last_seen','lastSeen','last_seen_time','lastSeenTime'); if($last){ try{ $t=[DateTimeOffset]::FromUnixTimeSeconds([int64]$last).UtcDateTime; if(($now.UtcDateTime-$t).TotalDays -ge 7){ $stale+=$c } }catch{} }
  }
  Add-Content $ins ("Clients: total={0}, wired={1}, wifi={2}" -f (SafeCount $C),$wired,$wifi)
  if(($band24 -or $band5)){ Add-Content $ins ("Band mix approx: 2.4GHz={0}, 5GHz={1}" -f $band24,$band5) }
  if(SafeCount $stale -gt 0){ Add-Content $ins ("Stale clients (>7d not seen): {0}" -f (SafeCount $stale)) }

  Add-Content $ins ''; Add-Content $ins 'Suggestions:'
  if(SafeCount $W -gt 0){
    $open=@($W|?{ ($_.security -match 'open') -or (TryProp $_ @('security','auth','wpa_mode') -eq 'open') })
    if(SafeCount $open -gt 0){ Add-Content $ins "  - One or more WLANs appear open. Enforce WPA2/WPA3 and enable PMF where compatible." }
  }
  if((SafeCount $N) -le 1){ Add-Content $ins "  - Single flat network detected (or not reported). Consider a separate IoT VLAN and inter-VLAN rules." }
  if($band24 -gt ($band5*2)){ Add-Content $ins "  - Many clients on 2.4GHz. Consider a 5GHz-preferred SSID or band-steering." }
  ("Config insights -> {0}" -f $ins) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{ Add-Content -LiteralPath $Summary -Value ("Insights error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

# ---------------- Bundle + optional Gist ----------------
$Bundle=Join-Path $Reports "$Prefix.zip"
try{ $toZip=Get-ChildItem -LiteralPath $Reports -File | ?{ $_.Name -like "$Prefix*" -or $_.Name -like "config_insights_$Stamp.txt" }
     if($toZip){ Compress-Archive -Path ($toZip|Select-Object -ExpandProperty FullName) -DestinationPath $Bundle -Force }
     ("Bundle -> {0}" -f $Bundle)|Add-Content -LiteralPath $Summary -Encoding UTF8 }catch{
     Add-Content -LiteralPath $Summary -Value ("Bundle error: {0}" -f $_.Exception.Message) -Encoding UTF8 }
try{
  if($GID -and $GTOK){
    $files=@{}; Get-ChildItem -LiteralPath $Reports -File | ?{ $_.Name -like "$Prefix*" -or $_.Name -eq ("config_insights_{0}.txt" -f $Stamp) } | %{
      $files[$_.Name]=@{ content=(Get-Content -LiteralPath $_.FullName -Raw) } }
    if($files.Count -gt 0){
      $payload=@{ files=$files }|ConvertTo-Json -Depth 7; $uri="https://api.github.com/gists/$GID"
      $hdr=@{ Authorization=("token {0}" -f $GTOK); 'User-Agent'='UDM-AllInOne-Auditor-v2.4' }
      $resp=Invoke-WebRequest -Uri $uri -Method Patch -Headers $hdr -Body $payload -ContentType 'application/json' -UseBasicParsing
      if($resp.StatusCode -ge 200 -and $resp.StatusCode -lt 300){ Add-Content -LiteralPath $Summary -Value ("Attached to Gist {0}" -f $GID) -Encoding UTF8 }
    }
  }
}catch{ Add-Content -LiteralPath $Summary -Value ("Gist upload skipped: {0}" -f $_.Exception.Message) -Encoding UTF8 }

Say ("Audit complete -> {0}" -f $Summary) 'Green'
Get-Content -LiteralPath $Summary

curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
PS C:\Windows\System32> CommandInvocation(Out-Null): "Out-Null"
PS C:\Windows\System32> CommandInvocation(Out-Null): "Out-Null"
[19:52:40] Audit complete -> D:\PlexTools\reports\udm_audit_20251006_195238.summary.txt
UDM All-in-One Auditor v2.4 - 10/06/2025 19:52:38
UDM IP: 192.168.1.1
Integration /sites -> 200
Integration siteId: 88f7af54-98f8-306a-a1c7-c9349722b1f6
Integration /sites/88f7af54-98f8-306a-a1c7-c9349722b1f6/devices -> 200
Integration /sites/88f7af54-98f8-306a-a1c7-c9349722b1f6/clients -> 200
CSRF try host 'unifi' -> 000 (TLS/redirect/DNS)
CSRF try host 'udm' -> 000 (TLS/redirect/DNS)
CSRF try host 'unifi.localdomain' -> 000 (TLS/redirect/DNS)
CSRF try host 'unifi.home' -> 000 (TLS/redirect/DNS)
CSRF try host 'udm.home' -> 000 (TLS/redirect/DNS)
CSRF try host 'udm.local' -> 000 (TLS/redirect/DNS)
CSRF try host '192.168.1.1' -> 000 (TLS/redirect/DNS)
Cookie login failed after CSRF/redirect attempts. Skipping config export.
Top talkers -> D:\PlexTools\reports\udm_audit_20251006_195238.top_talkers.csv
Config insights -> D:\PlexTools\reports\config_insights_20251006_195238.txt
Bundle -> D:\PlexTools\reports\udm_audit_20251006_195238.zip
Attached to Gist 5b621abce653010601f1cacbbf3bc249
PS C:\Windows\System32> cls
PS C:\Windows\System32> # ==================== START: PLEX_NIGHTLY_SNAPSHOT_SETUP ====================
$ErrorActionPreference='Continue'; $ProgressPreference='Continue'

# --- Config (change time if you want) ---
$DailyAt   = '03:30'                        # HH:MM 24h
$ToolsRoot = 'D:\PlexTools'
$OutRoot   = 'D:\PlexBackups'
$BinDir    = Join-Path $ToolsRoot 'bin'
$Sqlite    = Join-Path $BinDir 'sqlite3.exe'
$TaskName  = 'Plex Nightly Snapshot'
$SnapPS1   = Join-Path $ToolsRoot 'plex_quick_snapshot.ps1'
$KeepCount = 14                             # how many snapshots to retain

# --- Helpers ---
function Ensure-Dir([string]$p){ if(-not (Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Force -Path $p | Out-Null } }
function Is-Admin {
  try {
    $id=[Security.Principal.WindowsIdentity]::GetCurrent()
    $p = New-Object Security.Principal.WindowsPrincipal($id)
    return $p.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
  } catch { return $false }
}

Ensure-Dir $ToolsRoot; Ensure-Dir $OutRoot; Ensure-Dir $BinDir

# --- Write/Refresh the snapshot script (idempotent) ---
$script = @'
# ===== PLEX_QUICK_SNAPSHOT (nightly safe) =====
$ErrorActionPreference='Continue'; $ProgressPreference='Continue'
function Ensure-Dir([string]$p){ if(-not (Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Force -Path $p | Out-Null } }
function Banner([string]$t){ Write-Host ""; Write-Host ("==================== {0} ====================" -f $t) -ForegroundColor Magenta }
function Log([string]$m){ $ts=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss'); $line="[${ts}] $m"; $line | Tee-Object -FilePath $Global:Log -Append | Out-Host }
function Stage([string]$s){ $ts=(Get-Date).ToString('HH:mm:ss'); ("{0} {1}" -f $ts,$s) | Set-Content -LiteralPath $Global:StageFile }
function Find-PlexDb {
  $roots=@()
  if($env:LOCALAPPDATA){ $roots += (Join-Path $env:LOCALAPPDATA 'Plex Media Server') }
  if($env:ProgramData){  $roots += (Join-Path $env:ProgramData  'Plex Media Server') }
  $roots += 'C:\Windows\System32\config\systemprofile\AppData\Local\Plex Media Server'
  if(Test-Path 'C:\Users'){ try{ Get-ChildItem 'C:\Users' -Directory -ErrorAction SilentlyContinue | % { $roots += (Join-Path $_.FullName 'AppData\Local\Plex Media Server') } }catch{} }
  $roots += 'D:\Plex Media Server'
  if(Test-Path 'D:\Users'){ try{ Get-ChildItem 'D:\Users' -Directory -ErrorAction SilentlyContinue | % { $roots += (Join-Path $_.FullName 'AppData\Local\Plex Media Server') } }catch{} }
  $roots = $roots | ? { $_ -and (Test-Path $_) } | Select-Object -Unique
  foreach($r in $roots){
    $db = Join-Path $r 'Plug-in Support\Databases\com.plexapp.plugins.library.db'
    if(Test-Path $db -PathType Leaf){ return @{Root=$r;Db=$db} }
  }
  return $null
}
function Ensure-Sqlite([string]$sqlitePath,[string]$binDir){
  if(Test-Path $sqlitePath -PathType Leaf){ return $true }
  try{
    $zip = Join-Path $binDir 'sqlite-tools.zip'
    $urls=@(
      'https://www.sqlite.org/2024/sqlite-tools-win-x64-3450200.zip',
      'https://github.com/pinalbf/portable-sqlite/releases/download/3.45.2/sqlite-tools-win-x64-3450200.zip'
    )
    $ok=$false; foreach($u in $urls){ try{ Invoke-WebRequest -Uri $u -OutFile $zip -UseBasicParsing -TimeoutSec 60; $ok=$true; break }catch{} }
    if($ok){
      try{ Expand-Archive -Path $zip -DestinationPath $binDir -Force }catch{
        try{ Add-Type -AssemblyName System.IO.Compression.FileSystem; [IO.Compression.ZipFile]::ExtractToDirectory($zip,$binDir) }catch{}
      }
      $cand = Get-ChildItem -LiteralPath $binDir -Recurse -Filter 'sqlite3.exe' -ErrorAction SilentlyContinue | Select-Object -First 1
      if($cand){ Copy-Item $cand.FullName $sqlitePath -Force }
      Remove-Item $zip -Force -ErrorAction SilentlyContinue
    }
  }catch{}
  return (Test-Path $sqlitePath -PathType Leaf)
}

# Paths
$ToolsRoot = 'D:\PlexTools'
$OutRoot   = 'D:\PlexBackups'
$BinDir    = Join-Path $ToolsRoot 'bin'
$Sqlite    = Join-Path $BinDir 'sqlite3.exe'
$ts        = Get-Date -Format 'yyyyMMdd-HHmmss'
$DestRoot  = Join-Path $OutRoot ("PlexSnapshot-$ts")
$Global:StageFile = Join-Path $DestRoot 'backup-stage.txt'
$Global:Log       = Join-Path $DestRoot ("plex-backup-$ts.log")

Ensure-Dir $OutRoot; Ensure-Dir $ToolsRoot; Ensure-Dir $BinDir; Ensure-Dir $DestRoot

# Stage: Locate
Banner "LOCATE PLEX"; Stage "Locate"
$found = Find-PlexDb
$PlexRoot = $null; $DbPath = $null
if($found){ $PlexRoot = $found.Root; $DbPath = $found.Db }
if($PlexRoot){ Log ("PlexRoot => {0}" -f $PlexRoot) } else { Log "PlexRoot => (not found)" }
if($DbPath){   Log ("DB Path  => {0}" -f $DbPath)   } else { Log "DB Path  => (not found)" }

# Stage: Identity (non-fatal if Plex is down)
Banner "CAPTURE IDENTITY"; Stage "Identity"
try{
  $idFile = Join-Path $DestRoot 'identity.xml'
  Invoke-WebRequest -Uri 'http://127.0.0.1:32400/identity' -UseBasicParsing -TimeoutSec 3 -OutFile $idFile
  Log "Saved identity.xml"
}catch{ Log "Identity capture skipped (Plex offline or blocked)." }

# Stage: Copy core
Banner "COPY CORE"; Stage "CopyCore"
try{
  if($PlexRoot){
    $pref = Join-Path $PlexRoot 'Preferences.xml'
    if(Test-Path $pref -PathType Leaf){
      Copy-Item -LiteralPath $pref -Destination (Join-Path $DestRoot '_root_Preferences.xml') -Force
      Log "Copied -> Preferences.xml"
    }
    $pairs = @(
      @{s=(Join-Path $PlexRoot 'Plug-in Support\Databases'); d=(Join-Path $DestRoot 'Databases')},
      @{s=(Join-Path $PlexRoot 'Plug-in Support\Preferences'); d=(Join-Path $DestRoot 'Preferences')},
      @{s=(Join-Path $PlexRoot 'Plug-in Support\Profiles');   d=(Join-Path $DestRoot 'Profiles')},
      @{s=(Join-Path $PlexRoot 'Logs');                       d=(Join-Path $DestRoot 'Logs')}
    )
    foreach($p in $pairs){
      if(Test-Path $p.s){
        Copy-Item -LiteralPath $p.s -Destination $p.d -Recurse -Force -ErrorAction SilentlyContinue
        Log ("Copied dir -> {0}" -f $p.s)
      }else{
        Log ("Dir missing -> {0}" -f $p.s)
      }
    }
  }
  # Also grab our tools backups & Stremio catalog roots if present
  $extraPairs = @('D:\PlexTools\DB-Backups','D:\StremioCatalog')
  foreach($ep in $extraPairs){
    if(Test-Path $ep){
      $dst = Join-Path $DestRoot ([IO.Path]::GetFileName($ep))
      Copy-Item -LiteralPath $ep -Destination $dst -Recurse -Force -ErrorAction SilentlyContinue
      Log ("Copied dir -> {0}" -f $ep)
    }
  }
}catch{ Log ("Copy core note -> {0}" -f $_.Exception.Message) }

# Stage: Manifests (library list + locations)
Banner "EXPORT MANIFESTS"; Stage "Manifests"
$manifest = Join-Path $DestRoot 'manifest'; Ensure-Dir $manifest
function Invoke-Sqlite([string]$db,[string]$sql){
  try{
    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName  = $Sqlite
    $psi.Arguments = ('-batch -noheader "{0}" "{1}"' -f $db, $sql.Replace('"','""'))
    $psi.RedirectStandardOutput = $true; $psi.RedirectStandardError = $true; $psi.UseShellExecute=$false
    $p=[Diagnostics.Process]::Start($psi); $out=$p.StandardOutput.ReadToEnd(); $err=$p.StandardError.ReadToEnd(); $p.WaitForExit()
    if($err){ Log ("sqlite ERR: {0}" -f $err.Trim()) }
    return $out
  }catch{ return $null }
}
$haveSql = Ensure-Sqlite $Sqlite $BinDir
if($DbPath -and (Test-Path $DbPath -PathType Leaf) -and $haveSql){
  try{
    $libs = Invoke-Sqlite $DbPath "SELECT id,name,section_type,agent,scanner,language FROM library_sections;"
    if($libs){ $libs | Set-Content -LiteralPath (Join-Path $manifest 'libraries.pipe') -Encoding UTF8; Log "Exported libraries.pipe" }
    $locs = Invoke-Sqlite $DbPath "SELECT library_section_id,root_path FROM section_locations;"
    if($locs){ $locs | Set-Content -LiteralPath (Join-Path $manifest 'section_locations.pipe') -Encoding UTF8; Log "Exported section_locations.pipe" }
  }catch{}
}else{
  Log "Skipping manifest export (no DB or sqlite)."
}

# Stage: Consistent DB copy via .backup + Hashes (snapshot files only)
Banner "HASH KEY FILES"; Stage "Hashes"
$hashes = Join-Path $manifest 'hashes.txt'
"Built at $(Get-Date)" | Set-Content -LiteralPath $hashes -Encoding UTF8
try{
  if($DbPath -and $haveSql){
    $snapDbDir = Join-Path $DestRoot 'Databases'
    Ensure-Dir $snapDbDir
    $clean = Join-Path $snapDbDir 'com.plexapp.plugins.library.clean.db'
    # Consistent copy even if live DB locked
    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName  = $Sqlite
    $psi.Arguments = ('"{0}" ".timeout 5000" ".backup ''{1}''"' -f $DbPath.Replace('"','""'), $clean.Replace("'","''"))
    $psi.RedirectStandardOutput=$true; $psi.RedirectStandardError=$true; $psi.UseShellExecute=$false
    $p=[Diagnostics.Process]::Start($psi); $null=$p.StandardOutput.ReadToEnd(); $err=$p.StandardError.ReadToEnd(); $p.WaitForExit()
    if($err){ Log ("sqlite backup note: {0}" -f $err) }
  }
  $targets=@()
  $copyDb = Join-Path (Join-Path $DestRoot 'Databases') 'com.plexapp.plugins.library.db'
  if(Test-Path $copyDb){ $targets += $copyDb }
  $cleanDb = Join-Path (Join-Path $DestRoot 'Databases') 'com.plexapp.plugins.library.clean.db'
  if(Test-Path $cleanDb){ $targets += $cleanDb }
  $prefSnap = Join-Path $DestRoot '_root_Preferences.xml'
  if(Test-Path $prefSnap){ $targets += $prefSnap }
  foreach($t in $targets){
    try{ $h=Get-FileHash -Algorithm SHA256 -LiteralPath $t; "{0}  {1}" -f $h.Hash,$t | Add-Content -LiteralPath $hashes -Encoding UTF8 }catch{}
  }
  Log "Wrote hashes.txt"
}catch{ Log ("Hash step note -> {0}" -f $_.Exception.Message) }

# Stage: ZIP + retention
Banner "PACKAGE"; Stage "Zip"
try{
  $zip = "$DestRoot.zip"
  if(Test-Path $zip){ Remove-Item $zip -Force -ErrorAction SilentlyContinue }
  Compress-Archive -Path (Join-Path $DestRoot '*') -DestinationPath $zip -Force
  Log ("ZIP -> {0}" -f $zip)
}catch{ Log ("ZIP note -> {0}" -f $_.Exception.Message) }

# Retention (folders + zips)
try{
  $items = Get-ChildItem -LiteralPath $OutRoot -ErrorAction SilentlyContinue |
           Where-Object { $_.Name -like 'PlexSnapshot-*' } |
           Sort-Object LastWriteTime -Descending
  $keep = { param($arr,$n) if($arr.Count -gt $n){ $arr[$n..($arr.Count-1)] } else { @() } }
  $delete = & $keep $items $([int]"__KEEP__")
  foreach($d in $delete){ try{ if($d.PSIsContainer){ Remove-Item -LiteralPath $d.FullName -Recurse -Force } else { Remove-Item -LiteralPath $d.FullName -Force } }catch{} }
}catch{}

# Done
Banner "DONE"
Log ("Backup folder -> {0}" -f $DestRoot)
Log ("Backup ZIP    -> {0}" -f "$DestRoot.zip")
Log ("Stage file     -> {0}" -f $Global:StageFile)
Log ("Log file       -> {0}" -f $Global:Log)
# ===== END =====
'@ -replace '__KEEP__', $KeepCount

Set-Content -LiteralPath $SnapPS1 -Value $script -Encoding UTF8
Write-Host ("Snapshot script written -> {0}" -f $SnapPS1) -ForegroundColor Green

# --- Create/refresh Scheduled Task ---
# Clean old task if present (ignore errors)
try{ schtasks /Delete /TN "$TaskName" /F | Out-Null }catch{}

# Build command
$runCmd = 'powershell.exe -NoProfile -ExecutionPolicy Bypass -File "' + $SnapPS1 + '"'

if(Is-Admin){
  # Create as SYSTEM, highest, no password needed
  schtasks /Create /TN "$TaskName" /TR "$runCmd" /SC DAILY /ST $DailyAt /RU SYSTEM /RL HIGHEST /F | Out-Null
  Write-Host ("Scheduled task (SYSTEM) -> {0} at {1}" -f $TaskName,$DailyAt) -ForegroundColor Green
}else{
  # Create under current user (runs when logged on)
  schtasks /Create /TN "$TaskName" /TR "$runCmd" /SC DAILY /ST $DailyAt /F | Out-Null
  Write-Host ("Scheduled task (Current User) -> {0} at {1}" -f $TaskName,$DailyAt) -ForegroundColor Yellow
  Write-Host "Tip: Run this in an elevated PowerShell later to install as SYSTEM for background runs even when logged off." -ForegroundColor DarkYellow
}

# --- Kick off an initial run now (non-blocking) ---
try{ schtasks /Run /TN "$TaskName"  | Out-Null }catch{}
Write-Host "First snapshot kicked off. Watch D:\PlexBackups for a new PlexSnapshot-YYYYMMDD-HHMMSS folder/zip." -ForegroundColor Green

# --- â€œWhat changed & whyâ€ (inline note) ---
<# 
Enhancements included by default:
- Consistent DB copy (sqlite .backup) -> avoids lock/hashing errors while Plex is running.
- Staged logging & identity capture -> easier triage if anything hangs.
- Manifests (library_sections & section_locations) -> lets us restore real libraries if ever lost.
- Hashes of snapshot files (not live DB) -> reliable integrity check.
- ZIP packaging + retention (keep last 14) -> simple off-site copy and disk control.
- SYSTEM scheduled task when elevated -> runs even if youâ€™re logged off; falls back to per-user otherwise.
#>
# ==================== END: PLEX_NIGHTLY_SNAPSHOT_SETUP ====================

Snapshot script written -> D:\PlexTools\plex_quick_snapshot.ps1
Scheduled task (SYSTEM) -> Plex Nightly Snapshot at 03:30
First snapshot kicked off. Watch D:\PlexBackups for a new PlexSnapshot-YYYYMMDD-HHMMSS folder/zip.
PS C:\Windows\System32> cls
PS C:\Windows\System32> # UDM Setup Helper â€” store UI creds (encrypted), pin hostname, attempt config pull (one paste)
# Writes: TOKENS\ui_user.txt, TOKENS\ui_pass.bin, TOKENS\ui_ro_key.txt, TOKENS\udm_hostname.txt
# Updates hosts: maps 'unifi' -> UDM IP; Pulls config via cookie login if possible.

$ErrorActionPreference='Stop'
Set-StrictMode -Version Latest

function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
function HasProp($o,$n){ ($o -ne $null) -and ($o.PSObject.Properties.Name -contains $n) -and ($o.$n -ne $null -and $o.$n -ne '') }
function TryProp { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ return $o.$n } } return $null }
function ReadJsonFlex($p){ if(-not (Test-Path $p)){ return @() }; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json
  if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }

# ====== HARD-CODED (per your request) â€” ROTATE after we finish onboarding ======
$UI_User = 'jasonscarlett@optusnet.com.au'
$UI_PlainPass = 'W1ll0w17!!'
$UI_RO_Key = '9pW5DS3DDyze_0oDIir9vhufJVY1mWRL'   # Read-only API key (cloud); kept separate from local Integration key
$PreferredHostname = 'unifi'                        # the friendly name weâ€™ll pin to your UDM IP

# ====== Paths ======
$Vault   = 'C:\Users\jason\OneDrive\Public\TOKENS'
$Root    = 'D:\PlexTools'
$Reports = Join-Path $Root 'reports'
$Cache   = Join-Path $Root 'cache'
Ensure-Dir $Vault; Ensure-Dir $Reports; Ensure-Dir $Cache
$Stamp   = Get-Date -Format 'yyyyMMdd_HHmmss'
$Prefix  = "udm_setup_$Stamp"
$Summary = Join-Path $Reports "$Prefix.summary.txt"
"UDM Setup Helper â€” $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

# ====== 1) Persist creds & key (password encrypted, no Gist upload) ======
try{
  Set-Content -LiteralPath (Join-Path $Vault 'ui_user.txt') -Value $UI_User -Encoding ASCII
  $bytes=[Text.Encoding]::UTF8.GetBytes($UI_PlainPass)
  $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
  [IO.File]::WriteAllBytes((Join-Path $Vault 'ui_pass.bin'),$enc)
  Set-Content -LiteralPath (Join-Path $Vault 'ui_ro_key.txt') -Value $UI_RO_Key -Encoding ASCII
  Add-Content -LiteralPath $Summary -Value "Saved UI creds -> ui_user.txt, ui_pass.bin (encrypted), ui_ro_key.txt" -Encoding UTF8
}catch{ Add-Content -LiteralPath $Summary -Value ("Cred save error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

# Keep existing local Integration key (udm_token.txt) if present â€” we won't overwrite it with cloud RO key.
if(-not (Test-Path (Join-Path $Vault 'udm_token.txt'))){
  Add-Content -LiteralPath $Summary -Value "Note: no local Integration key (udm_token.txt) found; keeping only ui_ro_key.txt for now." -Encoding UTF8
}

# ====== 2) Determine UDM IP; pin hostname; save udm_hostname.txt ======
$UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt')
if([string]::IsNullOrWhiteSpace($UDM_IP)){
  $gw=(Get-NetIPConfiguration | Where-Object { $_.IPv4DefaultGateway -and $_.IPv4Address } | Select-Object -First 1)
  if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP = $gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') -Value $UDM_IP -Encoding ASCII }
}
("UDM IP: {0}" -f ($(if($UDM_IP){$UDM_IP}else{'<missing>'}))) | Add-Content -LiteralPath $Summary -Encoding UTF8

try{
  if(-not [string]::IsNullOrWhiteSpace($UDM_IP)){
    $hostsPath = "$env:SystemRoot\System32\drivers\etc\hosts"
    $line = "$UDM_IP`t$PreferredHostname"
    $content = if(Test-Path $hostsPath){ Get-Content -LiteralPath $hostsPath -Raw -Encoding ASCII } else { "" }
    $pattern = "^\s*\d{1,3}(\.\d{1,3}){3}\s+$([regex]::Escape($PreferredHostname))\s*$"
    if($content -match $pattern){
      $new = [regex]::Replace($content,$pattern,[System.Text.RegularExpressions.MatchEvaluator]{ param($m) $line },1,[System.Text.RegularExpressions.RegexOptions]::Multiline)
      Set-Content -LiteralPath $hostsPath -Value $new -Encoding ASCII
    } else {
      Add-Content -LiteralPath $hostsPath -Value $line -Encoding ASCII
    }
    Add-Content -LiteralPath $Summary -Value ("Hosts pinned: {0} -> {1}" -f $PreferredHostname,$UDM_IP) -Encoding UTF8
    Set-Content -LiteralPath (Join-Path $Vault 'udm_hostname.txt') -Value $PreferredHostname -Encoding ASCII
  } else {
    Add-Content -LiteralPath $Summary -Value "Could not determine UDM IP; skipping hosts pin." -Encoding UTF8
  }
}catch{
  Add-Content -LiteralPath $Summary -Value ("Hosts edit failed (need Admin PowerShell): {0}" -f $_.Exception.Message) -Encoding UTF8
}

# ====== 3) Try CSRF + cookie login to local controller and pull config ======
$curl = Get-Command curl.exe -ErrorAction SilentlyContinue
if(-not $curl){ Add-Content -LiteralPath $Summary -Value 'curl.exe not found; skipping config pull.' -Encoding UTF8; goto FINISH }

# Prepare cookie jar and resolve map (SNI-safe + redirects)
$CookieJar = Join-Path $Cache ("udm_cookie_{0}.txt" -f $Stamp)
$Hosts=@($PreferredHostname); if($UDM_IP){ $Hosts += $UDM_IP }
$ResolveArgs=@(); foreach($h in $Hosts){ if($h -notmatch '^\d+\.\d+\.\d+\.\d+$' -and $UDM_IP){ $ResolveArgs += @('--resolve',("$h:443:$UDM_IP")) } }
if($UDM_IP){ $ResolveArgs += @('--resolve',("$UDM_IP:443:$UDM_IP")) }

function CurlGetCsrf([string]$sniHost,[string]$csrfOut){
  if(Test-Path $CookieJar){ Remove-Item -LiteralPath $CookieJar -Force -ErrorAction SilentlyContinue }
  $url="https://$sniHost/api/auth/csrf"
  $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','15','-L') + $ResolveArgs +
        @('-H','Accept: application/json','-H','User-Agent: UDM-Setup','-c',$CookieJar,'-b',$CookieJar,'-o',$csrfOut,'-w','%{http_code}', $url)
  try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
}
function CurlLogin([string]$sniHost,[string]$token){
  $url="https://$sniHost/api/auth/login"
  $payload="{`"username`":`"$UI_User`",`"password`":`"$UI_PlainPass`",`"rememberMe`":true}"
  $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20','-L') + $ResolveArgs +
        @('-H','Accept: application/json','-H','Content-Type: application/json','-H','User-Agent: UDM-Setup',
          '-H',("Origin: https://$sniHost"),'-H',("Referer: https://$sniHost/"),'-H',("X-Csrf-Token: $token"),
          '-c',$CookieJar,'-b',$CookieJar,'--data-binary',$payload,$url,'-w','%{http_code}')
  try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
}
function CurlJsonCookie([string]$sniHost,[string]$path,[string]$outfile){
  $url="https://$sniHost$path"
  $csrf=$null; if(Test-Path $CookieJar){ try{ $lines=Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII; $m=[regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)'); if($m.Count -gt 0){ $csrf=$m[$m.Count-1].Groups[1].Value.Trim() } }catch{} }
  $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','25','-L') + $ResolveArgs +
        @('-H','Accept: application/json','-H','User-Agent: UDM-Setup','-c',$CookieJar,'-b',$CookieJar,'-o',$outfile,'-w','%{http_code}', $url)
  if($csrf){ $args=@('-H',("X-Csrf-Token: $csrf")) + $args }
  try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
}
function Fetch([string]$host,[string]$path,[string]$name){
  $file=Join-Path $Reports ("$Prefix.$name.json")
  $code=CurlJsonCookie $host $path $file
  $show = if($code -eq 0){'000 (TLS/redirect/DNS)'}elseif($code -lt 0){'tls/err'}else{$code}
  ("GET {0} via '{1}' -> {2}" -f $path,$host,$show) | Add-Content -LiteralPath $Summary -Encoding UTF8
  if($code -ge 200 -and $code -lt 300){ $file } else { $null }
}

$CookieOK=$false; $CookieHost=$PreferredHostname
if($UDM_IP){
  $csrfFile=Join-Path $Cache "csrf_$($PreferredHostname)_$Stamp.json"
  $c=CurlGetCsrf $PreferredHostname $csrfFile
  $show = if($c -eq 0){'000 (TLS/redirect/DNS)'}elseif($c -lt 0){'tls/err'}else{$c}
  ("CSRF {0} -> {1}" -f $PreferredHostname,$show) | Add-Content -LiteralPath $Summary -Encoding UTF8
  if($c -eq 200){
    $tok=$null; try{ $cj=Get-Content -LiteralPath $csrfFile -Raw|ConvertFrom-Json; $tok = TryProp $cj @('token','csrfToken','csrf','csrf_token') }catch{}
    if(-not $tok){
      try{ $lines=Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII; $m=[regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)'); if($m.Count -gt 0){ $tok=$m[$m.Count-1].Groups[1].Value.Trim() } }catch{}
    }
    if($tok){ $lc=CurlLogin $PreferredHostname $tok; $show2 = if($lc -eq 0){'000 (TLS/redirect/DNS)'}elseif($lc -lt 0){'tls/err'}else{$lc}
      ("LOGIN {0} -> {1}" -f $PreferredHostname,$show2) | Add-Content -LiteralPath $Summary -Encoding UTF8
      if($lc -eq 200){ $CookieOK=$true }
    }
  } else {
    Add-Content -LiteralPath $Summary -Value "CSRF did not return 200; cookie login may fail." -Encoding UTF8
  }
}

if($CookieOK){
  Add-Content -LiteralPath $Summary -Value "Cookie login OK; pulling config..." -Encoding UTF8
  # Discover site short name
  $F_self = Fetch $CookieHost "/proxy/network/api/self/sites" "self_sites"
  $siteShort='default'
  if($F_self){ try{ $sj=Get-Content -LiteralPath $F_self -Raw|ConvertFrom-Json; $first=$null
    if($sj.data){ $first=$sj.data|Select-Object -First 1 } elseif($sj -is [Collections.IEnumerable] -and -not ($sj -is [string])){ $first=$sj|Select-Object -First 1 }
    if($first -and (HasProp $first 'name')){ $siteShort=$first.name } }catch{} }
  ("Site (short): {0}" -f $siteShort) | Add-Content -LiteralPath $Summary -Encoding UTF8

  # Pull key config + stats
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/list/setting"        "list_setting")
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/rest/networkconf"    "rest_networkconf")
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/list/wlanconf"       "list_wlanconf")
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/rest/portconf"       "rest_portconf")
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallrule"   "rest_firewallrule")
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallgroup"  "rest_firewallgroup")
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/stat/device"         "stat_device")
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/stat/sta"            "stat_sta")
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/stat/health"         "stat_health")
  [void](Fetch $CookieHost "/proxy/network/api/s/$siteShort/stat/event"          "stat_event")
} else {
  Add-Content -LiteralPath $Summary -Value "Cookie login still blocked. Hostname pin done; if UDM requires a **local** admin, create one (no MFA) and rerun." -Encoding UTF8
}

Say ("Setup complete -> {0}" -f $Summary) 'Green'
Get-Content -LiteralPath $Summary

curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
[20:09:03] Setup complete -> D:\PlexTools\reports\udm_setup_20251006_200902.summary.txt
UDM Setup Helper â€” 10/06/2025 20:09:02
Saved UI creds -> ui_user.txt, ui_pass.bin (encrypted), ui_ro_key.txt
UDM IP: 192.168.1.1
Hosts pinned: unifi -> 192.168.1.1
CSRF unifi -> 000 (TLS/redirect/DNS)
CSRF did not return 200; cookie login may fail.
Cookie login still blocked. Hostname pin done; if UDM requires a **local** admin, create one (no MFA) and rerun.
PS C:\Windows\System32> cls
PS C:\Windows\System32> # ==================== START: PLEX_S1001_FIRSTAID_v2 ====================
$ErrorActionPreference='Continue'; $ProgressPreference='Continue'

# Paths & outputs
$ToolsRoot = 'D:\PlexTools'
$OutRoot   = 'D:\PlexFirstAid'
$BinDir    = Join-Path $ToolsRoot 'bin'
$ts        = Get-Date -Format 'yyyyMMdd-HHmmss'
$WorkDir   = Join-Path $OutRoot ("FirstAid-$ts")
$StageFile = Join-Path $WorkDir 'stage.txt'
$Log       = Join-Path $WorkDir ("plex-firstaid-$ts.log")
$ZipPath   = "$WorkDir.zip"
$Sqlite    = Join-Path $BinDir 'sqlite3.exe'

function Ensure-Dir([string]$p){ if(-not (Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Force -Path $p | Out-Null } }
function Banner([string]$t){ Write-Host ""; Write-Host ("==================== {0} ====================" -f $t) -ForegroundColor Magenta }
function Log([string]$m){ $ts=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss'); $line="[${ts}] $m"; $line | Tee-Object -FilePath $Log -Append | Out-Host }
function Stage([string]$s){ $ts=(Get-Date).ToString('HH:mm:ss'); ("{0} {1}" -f $ts,$s) | Set-Content -LiteralPath $StageFile }

function Find-PlexSupport {
  $roots=@()
  if($env:LOCALAPPDATA){ $roots += (Join-Path $env:LOCALAPPDATA 'Plex Media Server') }
  if($env:ProgramData){  $roots += (Join-Path $env:ProgramData  'Plex Media Server') }
  $roots += 'C:\Windows\System32\config\systemprofile\AppData\Local\Plex Media Server'
  if(Test-Path 'C:\Users'){ try{ Get-ChildItem 'C:\Users' -Directory -ErrorAction SilentlyContinue | % { $roots += (Join-Path $_.FullName 'AppData\Local\Plex Media Server') } }catch{} }
  $roots += 'D:\Plex Media Server'
  if(Test-Path 'D:\Users'){ try{ Get-ChildItem 'D:\Users' -Directory -ErrorAction SilentlyContinue | % { $roots += (Join-Path $_.FullName 'AppData\Local\Plex Media Server') } }catch{} }
  $roots = $roots | ? { $_ -and (Test-Path $_) } | Select-Object -Unique
  if(-not $roots){ return $null }
  $i=0
  foreach($r in $roots){
    $i++; Write-Progress -Activity "Searching for Plex DB" -Status $r -PercentComplete ([int](($i/[double][Math]::Max(1,$roots.Count))*100))
    try{
      $db = Join-Path $r 'Plug-in Support\Databases\com.plexapp.plugins.library.db'
      if(Test-Path $db -PathType Leaf){ Write-Progress -Activity "Searching for Plex DB" -Completed; return @{Root=$r;Db=$db} }
      $hit = Get-ChildItem -LiteralPath $r -Recurse -Filter 'com.plexapp.plugins.library.db' -ErrorAction SilentlyContinue | Select-Object -First 1
      if($hit){ Write-Progress -Activity "Searching for Plex DB" -Completed; return @{Root=$r;Db=$hit.FullName} }
    }catch{}
  }
  Write-Progress -Activity "Searching for Plex DB" -Completed
  return @{Root=$roots[0]; Db=$null}
}

function Find-PlexExe {
  $c=@()
  if($env:LOCALAPPDATA){ $c += (Join-Path $env:LOCALAPPDATA 'Plex Media Server\Plex Media Server.exe') }
  if(${env:ProgramFiles})      { $c += (Join-Path ${env:ProgramFiles}      'Plex\Plex Media Server\Plex Media Server.exe') }
  if(${env:ProgramFiles(x86)}) { $c += (Join-Path ${env:ProgramFiles(x86)} 'Plex\Plex Media Server\Plex Media Server.exe') }
  $c += 'D:\Plex Media Server\Plex Media Server.exe'
  $hit = $c | ? { $_ -and (Test-Path $_ -PathType Leaf) } | Select-Object -First 1
  if($hit){ return $hit }
  $searchRoots = @('C:\Program Files','C:\Program Files (x86)')
  if($env:LOCALAPPDATA){ $searchRoots += $env:LOCALAPPDATA }
  if(Test-Path 'D:\'){ $searchRoots += 'D:\' }
  foreach($sr in $searchRoots){
    try{
      $f = Get-ChildItem -LiteralPath $sr -Recurse -Filter 'Plex Media Server.exe' -ErrorAction SilentlyContinue | Select-Object -First 1
      if($f){ return $f.FullName }
    }catch{}
  }
  return $null
}

function Stop-Plex {
  Write-Progress -Activity "Stopping Plex" -Status "Stopping services + processes" -PercentComplete 10
  foreach($sn in @('Plex Media Server','PlexUpdateService','PlexUpdate Service')){ try{ if(Get-Service -Name $sn -ErrorAction SilentlyContinue){ Stop-Service -Name $sn -Force -ErrorAction SilentlyContinue } }catch{} }
  foreach($n in @('Plex Media Server','PlexTranscoder','Plex Tuner Service','PlexTunerService','Plex DLNA','Plex Media Scanner','PlexScriptHost')){ Stop-Process -Name $n -Force -ErrorAction SilentlyContinue }
  Start-Sleep -Milliseconds 750
  Write-Progress -Activity "Stopping Plex" -Completed
  Log "Plex stopped (best-effort)."
}

function Start-Plex([string]$PlexExe){
  foreach($sn in @('Plex Media Server','PlexUpdateService','PlexUpdate Service')){ try{ if(Get-Service -Name $sn -ErrorAction SilentlyContinue){ Start-Service -Name $sn -ErrorAction SilentlyContinue } }catch{} }
  if($PlexExe -and -not (Get-Process -Name 'Plex Media Server' -ErrorAction SilentlyContinue)){
    try{ $wd = Split-Path $PlexExe -Parent; Start-Process -FilePath $PlexExe -WorkingDirectory $wd -WindowStyle Hidden -ErrorAction SilentlyContinue; Log ("Started Plex exe -> {0}" -f $PlexExe) }catch{ Log ("Start-Process failed -> {0}" -f $_.Exception.Message) }
  }
}

function Wait-PlexReady([int]$sec=120){
  $sw=[Diagnostics.Stopwatch]::StartNew()
  while($sw.Elapsed.TotalSeconds -lt $sec){
    try{
      $r = Invoke-WebRequest -Uri 'http://127.0.0.1:32400/identity' -UseBasicParsing -TimeoutSec 2
      if($r.StatusCode -ge 200 -and $r.StatusCode -lt 500){ Write-Progress -Activity "Waiting for Plex HTTP (32400)" -Completed; return $true }
    }catch{}
    $pct=[int][Math]::Min(100, ($sw.Elapsed.TotalSeconds/$sec)*100)
    Write-Progress -Activity "Waiting for Plex HTTP (32400)" -Status "Startingâ€¦" -PercentComplete $pct
    Start-Sleep -Milliseconds 500
  }
  Write-Progress -Activity "Waiting for Plex HTTP (32400)" -Completed
  return $false
}

function SafeReplace-InFile([string]$path,[string]$pattern,[string]$replacement){
  try{
    if(-not (Test-Path $path -PathType Leaf)){ return $false }
    $text = Get-Content -LiteralPath $path -Raw
    $new  = [regex]::Replace($text,$pattern,$replacement)
    if($new -ne $text){
      Set-Content -LiteralPath $path -Value $new -Encoding UTF8
      return $true
    }
  }catch{}
  return $false
}

# Begin -------------------------------------------------------------------
Ensure-Dir $ToolsRoot; Ensure-Dir $OutRoot; Ensure-Dir $BinDir; Ensure-Dir $WorkDir
Banner "LOCATE PLEX"; Stage "Locate"
$found   = Find-PlexSupport
$PlexRoot= $null; $DbPath = $null
if($found){ $PlexRoot = $found.Root; $DbPath = $found.Db }
$__pr='(not found)'; if($PlexRoot){$__pr=$PlexRoot}; Log ("PlexRoot => {0}" -f $__pr)
$__db='(not found)'; if($DbPath){$__db=$DbPath};   Log ("DB Path  => {0}" -f $__db)
$PlexExe = Find-PlexExe; $__px='(not found)'; if($PlexExe){$__px=$PlexExe}; Log ("PlexExe  => {0}" -f $__px)

# Snapshot key files
Banner "SNAPSHOT"; Stage "Snapshot"
try{
  if($PlexRoot){
    $snap = Join-Path $WorkDir 'snapshot'; Ensure-Dir $snap
    $pref = Join-Path $PlexRoot 'Preferences.xml'
    if(Test-Path $pref){ Copy-Item -LiteralPath $pref -Destination (Join-Path $snap 'Preferences.xml.bak') -Force; Log "Backed up Preferences.xml" }
    if($DbPath -and (Test-Path $DbPath)){
      $dbLeaf = Split-Path $DbPath -Leaf
      Copy-Item -LiteralPath $DbPath -Destination (Join-Path $snap ($dbLeaf + '.bak')) -Force
      Log "Backed up library DB"
    }
    $logs = Join-Path $PlexRoot 'Logs'
    if(Test-Path $logs){ Copy-Item -LiteralPath $logs -Destination (Join-Path $snap 'Logs') -Recurse -Force -ErrorAction SilentlyContinue }
  }
}catch{ Log ("Snapshot note -> {0}" -f $_.Exception.Message) }

# Stop Plex & clear journals
Banner "STOP & CLEAN"; Stage "StopClean"
Stop-Plex
if($DbPath){
  foreach($j in @("$DbPath-shm","$DbPath-wal")){
    try{ if(Test-Path $j){ Move-Item -LiteralPath $j -Destination ($j + '.old.' + (Get-Date -Format 'yyyyMMdd-HHmmss')) -Force; Log ("Moved stale -> {0}" -f ([IO.Path]::GetFileName($j))) } }catch{}
  }
}

# Preferences first-aid
Banner "PREFERENCES FIXUPS"; Stage "PrefsFix"
if($PlexRoot){
  $pref = Join-Path $PlexRoot 'Preferences.xml'
  if(Test-Path $pref -PathType Leaf){
    $changed1 = SafeReplace-InFile $pref 'secureConnections="(required|disabled)"' 'secureConnections="preferred"'
    if($changed1){ Log 'Adjusted secureConnections => preferred' }
    try{
      $text = Get-Content -LiteralPath $pref -Raw
      $m = [regex]::Match($text,'allowedNetworks="([^"]*)"')
      if($m.Success){
        $orig = $m.Groups[1].Value
        $parts = $orig -split ','
        $keep  = @()
        foreach($p in $parts){
          $pp = $p.Trim()
          if($pp -match '^\d{1,3}(\.\d{1,3}){3}(/\d{1,2}|/\d{1,3}(\.\d{1,3}){3})?$'){ $keep += $pp }
        }
        $newVal = ($keep -join ',')
        if($newVal -ne $orig){
          $safe = [regex]::Escape($newVal).Replace('\\','\')
          if(SafeReplace-InFile $pref 'allowedNetworks="[^"]*"' ('allowedNetworks="' + $safe + '"')){
            Log ("Cleaned allowedNetworks (was '{0}')" -f $orig)
          }
        }
      }
      $text = Get-Content -LiteralPath $pref -Raw
      $sc = ([regex]::Match($text,'secureConnections="([^"]*)"').Groups[1].Value)
      $an = ([regex]::Match($text,'allowedNetworks="([^"]*)"').Groups[1].Value)
      $pni= ([regex]::Match($text,'PreferredNetworkInterface="([^"]*)"').Groups[1].Value)
      # Clear PNI if set
      if($pni){ if(SafeReplace-InFile $pref 'PreferredNetworkInterface="[^"]*"' 'PreferredNetworkInterface=""'){ Log 'Cleared PreferredNetworkInterface' } }
      Log ("Prefs now => secureConnections={0} ; allowedNetworks='{1}' ; PreferredNetworkInterface='{2}'" -f $sc,$an,$pni)
    }catch{ Log ("Prefs parse note -> {0}" -f $_.Exception.Message) }
  }else{
    Log "Preferences.xml not found; skipping preference tweaks."
  }
}

# Firewall
Banner "FIREWALL"; Stage "Firewall"
try{
  $ruleName = 'Plex 32400 TCP'
  $exists = (netsh advfirewall firewall show rule name="$ruleName" 2>&1 | Select-String -SimpleMatch "$ruleName")
  if(-not $exists){ netsh advfirewall firewall add rule name="$ruleName" dir=in action=allow protocol=TCP localport=32400 | Out-Null; Log "Firewall rule added for TCP 32400" }
  else{ Log "Firewall rule already present for TCP 32400" }
}catch{ Log ("Firewall note -> {0}" -f $_.Exception.Message) }

# Start Plex & wait
Banner "RESTART PLEX"; Stage "Start"
Start-Plex $PlexExe
$ready = Wait-PlexReady -sec 120
Log ("Plex HTTP ready: {0}" -f $ready)

# One-click revert for Preferences
Banner "WRITE REVERT"; Stage "Revert"
try{
  $revert = Join-Path $WorkDir 'revert_prefs.ps1'
  $bk = Join-Path (Join-Path $WorkDir 'snapshot') 'Preferences.xml.bak'
  $prefLive = if($PlexRoot){ Join-Path $PlexRoot 'Preferences.xml' } else { $null }
  $body = @"
# ===== REVERT PLEX PREFERENCES (generated) =====
`$ErrorActionPreference='Continue'
`$bk = '$bk'
`$live = '$prefLive'
if((Test-Path `$bk) -and (Test-Path `$live)){
  try{ Copy-Item -LiteralPath `$bk -Destination `$live -Force; Write-Host 'Preferences reverted from backup.' -ForegroundColor Green }catch{ Write-Host "Revert failed: `$($_.Exception.Message)" -ForegroundColor Red }
}else{ Write-Host 'Backup or live Preferences not found.' -ForegroundColor Yellow }
# ===== END =====
"@
  Set-Content -LiteralPath $revert -Value $body -Encoding UTF8
  Log ("Revert script -> {0}" -f $revert)
}catch{}

# QA zip
Banner "PACKAGE"; Stage "Zip"
try{
  if(Test-Path $ZipPath){ Remove-Item $ZipPath -Force -ErrorAction SilentlyContinue }
  Compress-Archive -Path (Join-Path $WorkDir '*') -DestinationPath $ZipPath -Force
  Log ("Bundle -> {0}" -f $ZipPath)
}catch{ Log ("ZIP note -> {0}" -f $_.Exception.Message) }

Banner "DONE"
Log ("Work dir -> {0}" -f $WorkDir)
Log ("Stage    -> {0}" -f $StageFile)
Log ("Log      -> {0}" -f $Log)
# ==================== END: PLEX_S1001_FIRSTAID_v2 ====================


==================== LOCATE PLEX ====================
[2025-10-06 20:46:50] PlexRoot => C:\Users\jason\AppData\Local\Plex Media Server
[2025-10-06 20:46:50] DB Path  => C:\Users\jason\AppData\Local\Plex Media Server\Plug-in Support\Databases\com.plexapp.plugins.library.db
[2025-10-06 20:46:50] PlexExe  => C:\Program Files\Plex\Plex Media Server\Plex Media Server.exe

==================== SNAPSHOT ====================
[2025-10-06 20:46:50] Backed up Preferences.xml
[2025-10-06 20:46:51] Backed up library DB

==================== STOP & CLEAN ====================
[2025-10-06 20:47:06] Plex stopped (best-effort).
[2025-10-06 20:47:06] Moved stale -> com.plexapp.plugins.library.db-shm
[2025-10-06 20:47:06] Moved stale -> com.plexapp.plugins.library.db-wal

==================== PREFERENCES FIXUPS ====================
[2025-10-06 20:47:06] Prefs now => secureConnections= ; allowedNetworks='127.0.0.1/8,192.168.1.0/24' ; PreferredNetworkInterface=''

==================== FIREWALL ====================
[2025-10-06 20:47:06] Firewall rule already present for TCP 32400

==================== RESTART PLEX ====================
[2025-10-06 20:47:06] Started Plex exe -> C:\Program Files\Plex\Plex Media Server\Plex Media Server.exe
PS C:\Windows\System32> TerminatingError(Invoke-WebRequest): "
<Response
  code="503"
  title="Maintenance"
  status="Plex Media Server is currently running startup maintenance tasks." />"
PS C:\Windows\System32> TerminatingError(Invoke-WebRequest): "
<Response
  code="503"
  title="Maintenance"
  status="Plex Media Server is currently running startup maintenance tasks." />"
PS C:\Windows\System32> TerminatingError(Invoke-WebRequest): "
<Response
  code="503"
  title="Maintenance"
  status="Plex Media Server is currently running startup maintenance tasks." />"
[2025-10-06 20:47:10] Plex HTTP ready: True

==================== WRITE REVERT ====================

==================== PACKAGE ====================
[2025-10-06 20:47:25] Bundle -> D:\PlexFirstAid\FirstAid-20251006-204650.zip

==================== DONE ====================
[2025-10-06 20:47:25] Work dir -> D:\PlexFirstAid\FirstAid-20251006-204650
[2025-10-06 20:47:25] Stage    -> D:\PlexFirstAid\FirstAid-20251006-204650\stage.txt
[2025-10-06 20:47:25] Log      -> D:\PlexFirstAid\FirstAid-20251006-204650\plex-firstaid-20251006-204650.log
PS C:\Windows\System32> cls
PS C:\Windows\System32> # UDM All-in-One Auditor v2.5 â€” hardcode LOCAL admin, store creds, full snapshot (single paste)
# - Saves local admin creds to TOKENS (plain + DPAPI-encrypted)
# - Uses Integration API (X-API-KEY) if present AND cookie login via local admin
# - Pulls WLAN/Network/Firewall/Port profiles, stats, top talkers, insights; bundles and optional Gist
# - SNI/redirect safe (curl with --resolve and -L). Avoids $host collision.

$ErrorActionPreference='Stop'
Set-StrictMode -Version Latest

# ---------- helpers ----------
function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
function HasProp($o,$n){ ($o -ne $null) -and ($o.PSObject.Properties.Name -contains $n) -and ($o.$n -ne $null -and $o.$n -ne '') }
function TryProp { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ return $o.$n } } return $null }
function TryNum  { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ try{ return [double]$o.$n }catch{} } } return $null }
function ReadJsonFlex($p){ if(-not (Test-Path $p)){ return @() }; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json
  if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }
function SafeCount($x){ @($x).Count }
function Mask($s){ if([string]::IsNullOrWhiteSpace($s)){'<empty>'} elseif($s.Length -le 6){'*'*$s.Length} else {'*'*($s.Length-6)+$s.Substring($s.Length-6)} }

# ---------- HARD-CODED LOCAL ADMIN (per your request) ----------
$LOCAL_USER = 'udm_Local_api'
$LOCAL_PASS = 'W1ll0w1703!!'

# ---------- paths ----------
$Vault   = 'C:\Users\jason\OneDrive\Public\TOKENS'
$Root    = 'D:\PlexTools'
$Reports = Join-Path $Root 'reports'
$Cache   = Join-Path $Root 'cache'
Ensure-Dir $Vault; Ensure-Dir $Reports; Ensure-Dir $Cache

$Stamp   = Get-Date -Format 'yyyyMMdd_HHmmss'
$Prefix  = "udm_audit_$Stamp"
$Summary = Join-Path $Reports "$Prefix.summary.txt"
"UDM All-in-One Auditor v2.5 - $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

# ---------- save creds (plain for compat + encrypted DPAPI) ----------
try{
  Set-Content -LiteralPath (Join-Path $Vault 'udm_user.txt') -Value $LOCAL_USER -Encoding ASCII
  Set-Content -LiteralPath (Join-Path $Vault 'udm_pass.txt') -Value $LOCAL_PASS -Encoding ASCII
  $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
  $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
  [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)
  ("Saved local admin -> udm_user.txt (user), udm_pass.txt (plain), udm_pass.bin (encrypted)") | Add-Content -LiteralPath $Summary -Encoding UTF8
  ("User: {0}" -f $LOCAL_USER) | Add-Content -LiteralPath $Summary -Encoding UTF8
  ("Pass(masked): {0}" -f (Mask $LOCAL_PASS)) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{ Add-Content -LiteralPath $Summary -Value ("Cred save error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

# ---------- load other tokens ----------
$UDM_IP   = ReadIf (Join-Path $Vault 'udm_ip.txt')
$API_KEY  = ***REDACTED*** (Join-Path $Vault 'udm_token.txt')          # Integration API key (X-API-KEY) if you saved earlier
$HOSTNAME = ReadIf (Join-Path $Vault 'udm_hostname.txt')       # preferred SNI host (e.g., 'unifi'). If missing we still try defaults.

$GID      = ReadIf (Join-Path $Vault 'gist_id.txt')
$GTOK     = ReadIf (Join-Path $Vault 'gist_token.txt')
if(-not $GTOK -and (Test-Path (Join-Path $Vault 'gist_token.bin'))){
  try{
    $b=[IO.File]::ReadAllBytes((Join-Path $Vault 'gist_token.bin'))
    $d=[Security.Cryptography.ProtectedData]::Unprotect($b,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
    $GTOK=[Text.Encoding]::UTF8.GetString($d).Trim()
  }catch{}
}

# ---------- detect IP if missing ----------
if([string]::IsNullOrWhiteSpace($UDM_IP)){
  $gw=(Get-NetIPConfiguration | Where-Object { $_.IPv4DefaultGateway -and $_.IPv4Address } | Select-Object -First 1)
  if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') -Value $UDM_IP -Encoding ASCII }
}
("UDM IP: {0}" -f ($(if($UDM_IP){$UDM_IP}else{'<missing>'}))) | Add-Content -LiteralPath $Summary -Encoding UTF8

# ---------- environment ----------
$env:HTTP_PROXY=''; $env:HTTPS_PROXY=''; $env:ALL_PROXY=''
[Net.WebRequest]::DefaultWebProxy = $null
try{
  [Net.ServicePointManager]::Expect100Continue=$false
  $sp=[Net.ServicePointManager]::SecurityProtocol
  if(($sp -band [Net.SecurityProtocolType]::Tls12) -eq 0){ [Net.ServicePointManager]::SecurityProtocol=$sp -bor [Net.SecurityProtocolType]::Tls12 }
}catch{}

# ---------- curl presence ----------
$curl=Get-Command curl.exe -ErrorAction SilentlyContinue
if(-not $curl){ Add-Content -LiteralPath $Summary -Value 'curl.exe not found in PATH.' -Encoding UTF8; throw 'curl missing' }

# ===================================================================
#  A) Integration API (X-API-KEY) â€” inventory/clients (works already)
# ===================================================================
$F_sites=$null; $F_devs=$null; $F_clis=$null; $siteId='default'
if($UDM_IP -and $API_KEY){
  $BaseInteg="https://$UDM_IP/proxy/network/integration/v1"
  function CurlJsonInteg([string]$path,[string]$outfile){
    $url="$BaseInteg$path"
    $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20',
      '-H','Accept: application/json','-H',("X-API-KEY: $API_KEY"),'-H','User-Agent: UDM-Audit-Integ',
      '-o',$outfile,'-w','%{http_code}', $url)
    try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
  }
  function FetchInteg([string]$path,[string]$name){
    $outfile=Join-Path $Reports ("$Prefix.$name.json"); $code=CurlJsonInteg $path $outfile
    ("Integration {0} -> {1}" -f $path, $(if($code -ge 0){$code}else{'tls/err'})) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($code -ge 200 -and $code -lt 300){ $outfile } else { $null }
  }
  $F_sites=FetchInteg '/sites' 'sites'
  if($F_sites){
    try{
      $sj=Get-Content -LiteralPath $F_sites -Raw|ConvertFrom-Json
      $first=$null
      if($sj -is [Collections.IEnumerable] -and -not ($sj -is [string])){ $first=$sj|Select-Object -First 1 }
      elseif($sj.data){ $first=$sj.data|Select-Object -First 1 }
      elseif($sj.items){ $first=$sj.items|Select-Object -First 1 }
      if($first){ if(HasProp $first 'id'){ $siteId=$first.id } elseif(HasProp $first 'site'){ $siteId=$first.site } elseif(HasProp $first 'name'){ $siteId=($first.name.ToString()).ToLowerInvariant() } }
    }catch{}
    ("Integration siteId: {0}" -f $siteId) | Add-Content -LiteralPath $Summary -Encoding UTF8
    $F_devs=FetchInteg "/sites/$siteId/devices" 'devices'
    $F_clis=FetchInteg "/sites/$siteId/clients" 'clients'
  } else { Add-Content -LiteralPath $Summary -Value 'Integration sites call failed (check X-API-KEY).' -Encoding UTF8 }
} else {
  Add-Content -LiteralPath $Summary -Value 'Skipping Integration API: missing udm_ip.txt or udm_token.txt.' -Encoding UTF8
}

# ===================================================================
#  B) Cookie login via LOCAL admin â€” full config export
# ===================================================================
#  Build SNI hostname list
$HostCandidates=@()
if($HOSTNAME){ $HostCandidates += $HOSTNAME }
$HostCandidates += @('unifi','udm','unifi.localdomain','unifi.home','udm.home','udm.local')
if($UDM_IP){ $HostCandidates += $UDM_IP }
$HostCandidates = $HostCandidates | Select-Object -Unique

#  Prebuild --resolve list so redirects still point to our IP
$ResolveArgs=@()
foreach($hn in $HostCandidates){
  if($UDM_IP -and $hn -notmatch '^\d+\.\d+\.\d+\.\d+$'){
    $ResolveArgs += @('--resolve',("$hn:443:$UDM_IP"))
  }
}
if($UDM_IP){ $ResolveArgs += @('--resolve',("$UDM_IP:443:$UDM_IP")) }

$CookieJar = Join-Path $Cache ("udm_cookie_{0}.txt" -f $Stamp)

function CurlGetCsrf([string]$sniHost,[string]$csrfOut){
  if(Test-Path $CookieJar){ Remove-Item -LiteralPath $CookieJar -Force -ErrorAction SilentlyContinue }
  $url="https://$sniHost/api/auth/csrf"
  $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','15','-L') + $ResolveArgs +
        @('-H','Accept: application/json','-H','User-Agent: UDM-Audit-Login','-c',$CookieJar,'-b',$CookieJar,'-o',$csrfOut,'-w','%{http_code}', $url)
  try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
}
function CurlLogin([string]$sniHost,[string]$token){
  $url="https://$sniHost/api/auth/login"
  $payload="{`"username`":`"$LOCAL_USER`",`"password`":`"$LOCAL_PASS`",`"rememberMe`":true}"
  $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20','-L') + $ResolveArgs +
        @('-H','Accept: application/json','-H','Content-Type: application/json','-H','User-Agent: UDM-Audit-Login',
          '-H',("Origin: https://$sniHost"),'-H',("Referer: https://$sniHost/"),'-H',("X-Csrf-Token: $token"),
          '-c',$CookieJar,'-b',$CookieJar,'--data-binary',$payload,$url,'-w','%{http_code}')
  try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
}
function CurlJsonCookie([string]$sniHost,[string]$path,[string]$outfile){
  $url="https://$sniHost$path"
  $csrf=$null
  if(Test-Path $CookieJar){
    try{
      $lines=Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII
      $m=[regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)')
      if($m.Count -gt 0){ $csrf=$m[$m.Count-1].Groups[1].Value.Trim() }
    }catch{}
  }
  $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','25','-L') + $ResolveArgs +
        @('-H','Accept: application/json','-H','User-Agent: UDM-Audit-GET','-c',$CookieJar,'-b',$CookieJar,'-o',$outfile,'-w','%{http_code}', $url)
  if($csrf){ $args = @('-H',("X-Csrf-Token: $csrf")) + $args }
  try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
}
function FetchCookie([string]$sniHost,[string]$path,[string]$name){
  $outfile=Join-Path $Reports ("$Prefix.$name.json")
  $code=CurlJsonCookie $sniHost $path $outfile
  $show = if($code -eq 0){'000 (TLS/redirect/DNS)'}elseif($code -lt 0){'tls/err'}else{$code}
  ("Cookie {0} via '{1}' -> {2}" -f $path,$sniHost,$show) | Add-Content -LiteralPath $Summary -Encoding UTF8
  if($code -ge 200 -and $code -lt 300){ $outfile } else { $null }
}

$loginOK=$false; $CookieHost=$null; $siteShort='default'
if($UDM_IP){
  foreach($sni in $HostCandidates){
    $csrfFile=Join-Path $Cache "csrf_$($sni)_$Stamp.json"
    $c=CurlGetCsrf $sni $csrfFile
    $show = if($c -eq 0){'000 (TLS/redirect/DNS)'}elseif($c -lt 0){'tls/err'}else{$c}
    ("CSRF try host '{0}' -> {1}" -f $sni,$show) | Add-Content -LiteralPath $Summary -Encoding UTF8
    if($c -eq 200){
      $tok=$null; try{ $cj=Get-Content -LiteralPath $csrfFile -Raw|ConvertFrom-Json; $tok = TryProp $cj @('token','csrfToken','csrf','csrf_token') }catch{}
      if(-not $tok){
        try{ $lines=Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII; $m=[regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)'); if($m.Count -gt 0){ $tok=$m[$m.Count-1].Groups[1].Value.Trim() } }catch{}
      }
      if($tok){
        $lc=CurlLogin $sni $tok
        $show2 = if($lc -eq 0){'000 (TLS/redirect/DNS)'}elseif($lc -lt 0){'tls/err'}else{$lc}
        ("Cookie login try host '{0}' -> {1}" -f $sni,$show2) | Add-Content -LiteralPath $Summary -Encoding UTF8
        if($lc -eq 200){ $loginOK=$true; $CookieHost=$sni; break }
      }
    }
  }

  if($loginOK){
    Add-Content -LiteralPath $Summary -Value ("Cookie login OK using host '{0}'." -f $CookieHost) -Encoding UTF8
    $F_self = FetchCookie $CookieHost "/proxy/network/api/self/sites" "self_sites"
    if($F_self){
      try{
        $sj=Get-Content -LiteralPath $F_self -Raw|ConvertFrom-Json
        $first=$null
        if($sj.data){ $first=$sj.data|Select-Object -First 1 }
        elseif($sj -is [Collections.IEnumerable] -and -not ($sj -is [string])){ $first=$sj|Select-Object -First 1 }
        if($first -and (HasProp $first 'name')){ $siteShort=$first.name }
      }catch{}
    }
    ("Network site short name: {0}" -f $siteShort) | Add-Content -LiteralPath $Summary -Encoding UTF8

    # config/stat pulls
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/list/setting"        "list_setting")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/networkconf"    "rest_networkconf")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/list/wlanconf"       "list_wlanconf")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/portconf"       "rest_portconf")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallrule"   "rest_firewallrule")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallgroup"  "rest_firewallgroup")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/device"         "stat_device")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/sta"            "stat_sta")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/health"         "stat_health")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/sysinfo"        "stat_sysinfo")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/event"          "stat_event")
    [void](FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/alarm"          "stat_alarm")
  } else {
    Add-Content -LiteralPath $Summary -Value "Cookie login failed after CSRF/redirect attempts. Skipping config export." -Encoding UTF8
  }
} else {
  Add-Content -LiteralPath $Summary -Value 'Skipping cookie login: missing UDM IP.' -Encoding UTF8
}

# ===================================================================
#  C) Top talkers
# ===================================================================
$F_clients_for_top=$null
if($F_clis){ $F_clients_for_top=$F_clis }
elseif(Test-Path (Join-Path $Reports "$Prefix.stat_sta.json")){ $F_clients_for_top=(Join-Path $Reports "$Prefix.stat_sta.json") }
$TopCSV=Join-Path $Reports "$Prefix.top_talkers.csv"
try{
  $rows=@()
  if($F_clients_for_top){
    $arr=ReadJsonFlex $F_clients_for_top
    foreach($c in $arr){
      $name=TryProp $c @('hostname','host_name','name','displayName','display_name','device_name','deviceName','fingerprint_name','mac')
      $ip=TryProp $c @('ip','ip_address','ipAddress','ipv4','primaryIp','primary_ip')
      $ssid=TryProp $c @('ssid','essid','wifiNetwork','wifi_ssid','wlan_name','wlan','ap_ssid')
      $ap=TryProp $c @('ap_mac','apMac','ap','apMacAddr')
      $wiredFlag=TryProp $c @('is_wired','wired','isWired'); $wired=$null; if($wiredFlag -ne $null){ $wired=[bool]$wiredFlag }
      $tx=TryNum $c @('tx_bytes','txBytes','tx','tx_total','tx_total_bytes'); $rx=TryNum $c @('rx_bytes','rxBytes','rx','rx_total','rx_total_bytes')
      if((-not $tx) -or (-not $rx)){ $stats=TryProp $c @('statistics','stats'); if($stats){ if(-not $tx){ $tx=TryNum $stats @('tx_bytes','txBytes','tx','tx_total','bytes_tx') }; if(-not $rx){ $rx=TryNum $stats @('rx_bytes','rxBytes','rx','rx_total','bytes_rx') } } }
      if(-not $tx){$tx=0}; if(-not $rx){$rx=0}
      $rows += [pscustomobject]@{ name=$name; ip=$ip; mac=(TryProp $c @('mac')); wired=$wired; ssid=$ssid; ap=$ap; tx_bytes=[double]$tx; rx_bytes=[double]$rx; total_bytes=([double]$tx+[double]$rx) }
    }
  }
  $top=$rows | Sort-Object total_bytes -Descending | Select-Object -First 20
  if($top){ $top|Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8; ("Top talkers -> {0}" -f $TopCSV)|Add-Content -LiteralPath $Summary -Encoding UTF8 }
  else { Add-Content -LiteralPath $Summary -Value 'Top talkers -> no bytes available.' -Encoding UTF8 }
}catch{ Add-Content -LiteralPath $Summary -Value ("Top talkers error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

# ===================================================================
#  D) Insights (WLAN, VLAN, Firewall) â€” uses cookie exports if present
# ===================================================================
try{
  $ins=Join-Path $Reports ("config_insights_{0}.txt" -f $Stamp); "Config Insights - $(Get-Date)" | Set-Content -LiteralPath $ins -Encoding UTF8

  $F_wlan  = Join-Path $Reports "$Prefix.list_wlanconf.json"
  $F_net   = Join-Path $Reports "$Prefix.rest_networkconf.json"
  $F_ports = Join-Path $Reports "$Prefix.rest_portconf.json"
  $F_fwr   = Join-Path $Reports "$Prefix.rest_firewallrule.json"

  $W=ReadJsonFlex $F_wlan; $N=ReadJsonFlex $F_net; $FR=ReadJsonFlex $F_fwr

  if(SafeCount $W -gt 0){
    Add-Content $ins 'WLANs:'
    foreach($w in $W){
      $nm=TryProp $w @('name','ssid'); if(-not $nm){ $nm='(unnamed)' }
      $sec=TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version')
      $iso=TryProp $w @('isolation','ap_isolation','is_guest','guest')
      $pmf=TryProp $w @('pmf_mode','pmf','ocpmf')
      Add-Content $ins ("  - {0} | security={1} | isolation={2} | pmf={3}" -f $nm,$sec,$iso,$pmf)
    }
    Add-Content $ins ''
  }

  if(SafeCount $N -gt 0){
    $vlanCount=0; foreach($n in $N){ if(TryProp $n @('vlan','vlan_id','vlanId')){ $vlanCount++ } }
    Add-Content $ins ("Networks reported: {0} (with VLAN tag on {1})" -f (SafeCount $N),$vlanCount)
  }

  if(SafeCount $FR -gt 0){
    $enabled=@($FR | Where-Object { HasProp $_ 'enabled' -and $_.enabled -eq $true }).Count
    Add-Content $ins ("Firewall rules: total={0}, enabled={1}" -f (SafeCount $FR),$enabled)
  }

  ("Config insights -> {0}" -f $ins) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{ Add-Content -LiteralPath $Summary -Value ("Insights error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

# ===================================================================
#  E) Bundle + optional Gist
# ===================================================================
$Bundle=Join-Path $Reports "$Prefix.zip"
try{
  $toZip=Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -like "$Prefix*" -or $_.Name -like "config_insights_$Stamp.txt" }
  if($toZip){ Compress-Archive -Path ($toZip|Select-Object -ExpandProperty FullName) -DestinationPath $Bundle -Force }
  ("Bundle -> {0}" -f $Bundle) | Add-Content -LiteralPath $Summary -Encoding UTF8
}catch{ Add-Content -LiteralPath $Summary -Value ("Bundle error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

try{
  if($GID -and $GTOK){
    $files=@{}
    Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -like "$Prefix*" -or $_.Name -eq ("config_insights_{0}.txt" -f $Stamp) } | ForEach-Object {
      $files[$_.Name] = @{ content = (Get-Content -LiteralPath $_.FullName -Raw) }
    }
    if($files.Count -gt 0){
      $payload=@{ files=$files } | ConvertTo-Json -Depth 7
      $uri="https://api.github.com/gists/$GID"
      $hdr=@{ Authorization=("token {0}" -f $GTOK); 'User-Agent'='UDM-AllInOne-Auditor-v2.5' }
      $resp=Invoke-WebRequest -Uri $uri -Method Patch -Headers $hdr -Body $payload -ContentType 'application/json' -UseBasicParsing
      if($resp.StatusCode -ge 200 -and $resp.StatusCode -lt 300){ Add-Content -LiteralPath $Summary -Value ("Attached to Gist {0}" -f $GID) -Encoding UTF8 }
    }
  }
}catch{ Add-Content -LiteralPath $Summary -Value ("Gist upload skipped: {0}" -f $_.Exception.Message) -Encoding UTF8 }

Say ("Audit complete -> {0}" -f $Summary) 'Green'
Get-Content -LiteralPath $Summary

curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
PS C:\Windows\System32> CommandInvocation(Out-Null): "Out-Null"
[20:55:10] Audit complete -> D:\PlexTools\reports\udm_audit_20251006_205508.summary.txt
UDM All-in-One Auditor v2.5 - 10/06/2025 20:55:08
Saved local admin -> udm_user.txt (user), udm_pass.txt (plain), udm_pass.bin (encrypted)
User: udm_Local_api
Pass(masked): ******1703!!
UDM IP: 192.168.1.1
Integration /sites -> 200
Integration siteId: 88f7af54-98f8-306a-a1c7-c9349722b1f6
Integration /sites/88f7af54-98f8-306a-a1c7-c9349722b1f6/devices -> 200
Integration /sites/88f7af54-98f8-306a-a1c7-c9349722b1f6/clients -> 200
CSRF try host 'unifi' -> 000 (TLS/redirect/DNS)
CSRF try host 'udm' -> 000 (TLS/redirect/DNS)
CSRF try host 'unifi.localdomain' -> 000 (TLS/redirect/DNS)
CSRF try host 'unifi.home' -> 000 (TLS/redirect/DNS)
CSRF try host 'udm.home' -> 000 (TLS/redirect/DNS)
CSRF try host 'udm.local' -> 000 (TLS/redirect/DNS)
CSRF try host '192.168.1.1' -> 000 (TLS/redirect/DNS)
Cookie login failed after CSRF/redirect attempts. Skipping config export.
Top talkers -> D:\PlexTools\reports\udm_audit_20251006_205508.top_talkers.csv
Config insights -> D:\PlexTools\reports\config_insights_20251006_205508.txt
Bundle -> D:\PlexTools\reports\udm_audit_20251006_205508.zip
Attached to Gist 5b621abce653010601f1cacbbf3bc249
PS C:\Windows\System32> cls
PS C:\Windows\System32> cls
PS C:\Windows\System32> # ==================== START: PLEX_S1001_FIRSTAID_ALLINONE ====================
$ErrorActionPreference='Continue'; $ProgressPreference='Continue'

# --- Paths / Work dirs ---
$BaseOut   = 'D:\PlexFirstAid'
$ToolsRoot = 'D:\PlexTools'
$BinDir    = Join-Path $ToolsRoot 'bin'
$Sqlite    = Join-Path $BinDir 'sqlite3.exe'
$ts        = Get-Date -Format 'yyyyMMdd-HHmmss'
$WorkDir   = Join-Path $BaseOut ("FirstAid-$ts")
$SnapDir   = Join-Path $WorkDir 'Snapshot'
$RptDir    = Join-Path $WorkDir 'Reports'
$StageFile = Join-Path $WorkDir 'stage.txt'
$Log       = Join-Path $WorkDir ("plex-firstaid-$ts.log")

# --- Helpers ---
function Ensure-Dir([string]$p){ if(-not (Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Force -Path $p | Out-Null } }
Ensure-Dir $BaseOut; Ensure-Dir $ToolsRoot; Ensure-Dir $BinDir; Ensure-Dir $WorkDir; Ensure-Dir $SnapDir; Ensure-Dir $RptDir

function Banner([string]$t){ Write-Host ""; Write-Host ("==================== {0} ====================" -f $t) -ForegroundColor Magenta }
function Log([string]$m){ $ts2=(Get-Date).ToString('yyyy-MM-dd HH:mm:ss'); $line="[${ts2}] $m"; $line | Tee-Object -FilePath $Log -Append | Out-Host }
function Stage([string]$s){ $ts2=(Get-Date).ToString('HH:mm:ss'); ("{0} {1}" -f $ts2,$s) | Set-Content -LiteralPath $StageFile }

# PS 5.1-safe TLS
try{ $names=[enum]::GetNames([Net.SecurityProtocolType]); $proto=0;
     if($names -contains 'Tls12'){ $proto = $proto -bor [Net.SecurityProtocolType]::Tls12 }
     if($names -contains 'Tls13'){ $proto = $proto -bor [Net.SecurityProtocolType]::Tls13 }
     if($proto -ne 0){ [Net.ServicePointManager]::SecurityProtocol = $proto } }catch{}

function Find-PlexSupport {
  $roots=@()
  if($env:LOCALAPPDATA){ $roots += (Join-Path $env:LOCALAPPDATA 'Plex Media Server') }
  if($env:ProgramData){  $roots += (Join-Path $env:ProgramData  'Plex Media Server') }
  $roots += 'C:\Windows\System32\config\systemprofile\AppData\Local\Plex Media Server'
  if(Test-Path 'C:\Users'){ try{ Get-ChildItem 'C:\Users' -Directory -ErrorAction SilentlyContinue | ForEach-Object { $roots += (Join-Path $_.FullName 'AppData\Local\Plex Media Server') } }catch{} }
  # D:\ common as well
  $roots += 'D:\Plex Media Server'
  if(Test-Path 'D:\Users'){ try{ Get-ChildItem 'D:\Users' -Directory -ErrorAction SilentlyContinue | ForEach-Object { $roots += (Join-Path $_.FullName 'AppData\Local\Plex Media Server') } }catch{} }
  $roots = $roots | Where-Object { $_ -and (Test-Path $_) } | Select-Object -Unique
  if(-not $roots){ return @{Root=$null; Db=$null} }

  foreach($r in $roots){
    $db = Join-Path $r 'Plug-in Support\Databases\com.plexapp.plugins.library.db'
    if(Test-Path $db -PathType Leaf){ return @{Root=$r; Db=$db} }
    try{ $hit = Get-ChildItem -LiteralPath $r -Recurse -Filter 'com.plexapp.plugins.library.db' -ErrorAction SilentlyContinue | Select-Object -First 1
         if($hit){ return @{Root=$r; Db=$hit.FullName} } }catch{}
  }
  return @{Root=$roots[0]; Db=$null}
}

function Find-PlexExe {
  $c=@()
  if($env:LOCALAPPDATA){ $c += (Join-Path $env:LOCALAPPDATA 'Plex Media Server\Plex Media Server.exe') }
  if(${env:ProgramFiles})     { $c += (Join-Path ${env:ProgramFiles}      'Plex\Plex Media Server\Plex Media Server.exe') }
  if(${env:ProgramFiles(x86)}){ $c += (Join-Path ${env:ProgramFiles(x86)} 'Plex\Plex Media Server\Plex Media Server.exe') }
  $c += 'D:\Plex Media Server\Plex Media Server.exe'
  $hit = $c | Where-Object { $_ -and (Test-Path $_ -PathType Leaf) } | Select-Object -First 1
  if($hit){ return $hit }
  $searchRoots=@('C:\Program Files','C:\Program Files (x86)')
  if($env:LOCALAPPDATA){ $searchRoots += $env:LOCALAPPDATA }
  if(Test-Path 'D:\'){ $searchRoots += 'D:\' }
  foreach($sr in $searchRoots){
    try{ $f = Get-ChildItem -LiteralPath $sr -Recurse -Filter 'Plex Media Server.exe' -ErrorAction SilentlyContinue | Select-Object -First 1
         if($f){ return $f.FullName } }catch{}
  }
  return $null
}

function Stop-Plex {
  Write-Progress -Activity "Stopping Plex" -Status "Stopping services + processes" -PercentComplete 10
  foreach($sn in @('Plex Media Server','PlexUpdateService','PlexUpdate Service')){ try{ if(Get-Service -Name $sn -ErrorAction SilentlyContinue){ Stop-Service -Name $sn -Force -ErrorAction SilentlyContinue } }catch{} }
  foreach($n in @('Plex Media Server','PlexTranscoder','Plex Tuner Service','PlexTunerService','Plex DLNA','Plex Media Scanner','PlexScriptHost')){ Stop-Process -Name $n -Force -ErrorAction SilentlyContinue }
  Start-Sleep -Milliseconds 800
  Write-Progress -Activity "Stopping Plex" -Completed
  Log "Plex stopped (best-effort)."
}

function Start-Plex([string]$PlexExe){
  foreach($sn in @('Plex Media Server','PlexUpdateService','PlexUpdate Service')){ try{ if(Get-Service -Name $sn -ErrorAction SilentlyContinue){ Start-Service -Name $sn -ErrorAction SilentlyContinue } }catch{} }
  if($PlexExe -and -not (Get-Process -Name 'Plex Media Server' -ErrorAction SilentlyContinue)){
    try{ $wd = Split-Path $PlexExe -Parent; if($wd){ Start-Process -FilePath $PlexExe -WorkingDirectory $wd -WindowStyle Hidden -ErrorAction SilentlyContinue; Log ("Started Plex exe -> {0}" -f $PlexExe) } }catch{ Log ("Start-Process failed -> {0}" -f $_.Exception.Message) }
  }
}

function Wait-PlexReady([int]$sec=120){
  $sw=[Diagnostics.Stopwatch]::StartNew(); $ready=$false
  while($sw.Elapsed.TotalSeconds -lt $sec){
    try{ $r=Invoke-WebRequest -Uri 'http://127.0.0.1:32400/identity' -UseBasicParsing -TimeoutSec 2; if($r.StatusCode -ge 200 -and $r.StatusCode -lt 500){ $ready=$true; break } }catch{}
    $pct=[int][Math]::Min(100, ($sw.Elapsed.TotalSeconds/$sec)*100)
    Write-Progress -Activity "Waiting for Plex HTTP (32400)" -Status "Startingâ€¦" -PercentComplete $pct
    Start-Sleep -Milliseconds 500
  }
  Write-Progress -Activity "Waiting for Plex HTTP (32400)" -Completed
  Log ("Plex HTTP ready: {0}" -f $ready)
  return $ready
}

function Ensure-Sqlite([string]$sqlitePath,[string]$binDir){
  if(Test-Path $sqlitePath -PathType Leaf){ return $true }
  try{
    Ensure-Dir $binDir
    $zip = Join-Path $binDir 'sqlite-tools.zip'
    $urls=@(
      'https://www.sqlite.org/2024/sqlite-tools-win-x64-3450200.zip',
      'https://github.com/pinalbf/portable-sqlite/releases/download/3.45.2/sqlite-tools-win-x64-3450200.zip'
    )
    $ok=$false; foreach($u in $urls){ try{ Invoke-WebRequest -Uri $u -OutFile $zip -UseBasicParsing -TimeoutSec 60; $ok=$true; break }catch{ Log ("Download failed -> {0}" -f $u) } }
    if($ok){
      try{ Expand-Archive -Path $zip -DestinationPath $binDir -Force }catch{
        try{ Add-Type -AssemblyName System.IO.Compression.FileSystem; [IO.Compression.ZipFile]::ExtractToDirectory($zip,$binDir) }catch{ Log ("Unzip failed -> {0}" -f $_.Exception.Message) }
      }
      $cand = Get-ChildItem -LiteralPath $binDir -Recurse -Filter 'sqlite3.exe' -ErrorAction SilentlyContinue | Select-Object -First 1
      if($cand){ Copy-Item $cand.FullName $sqlitePath -Force }
      Remove-Item $zip -Force -ErrorAction SilentlyContinue
    }
  }catch{}
  return (Test-Path $sqlitePath -PathType Leaf)
}

function Invoke-Sqlite([string]$db,[string]$sql){
  try{
    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName  = $Sqlite
    $psi.Arguments = ('-batch -noheader "{0}" "{1}"' -f $db, $sql.Replace('"','""'))
    $psi.RedirectStandardOutput = $true; $psi.RedirectStandardError  = $true; $psi.UseShellExecute=$false
    $p=[Diagnostics.Process]::Start($psi); $out=$p.StandardOutput.ReadToEnd(); $err=$p.StandardError.ReadToEnd(); $p.WaitForExit()
    if($err){ Log ("sqlite ERR: {0}" -f $err.Trim()) }
    return $out
  }catch{ Log ("sqlite EXC: {0}" -f $_.Exception.Message); return $null }
}

function FirstLine([string]$p){ try{ (Get-Content -LiteralPath $p -TotalCount 1 -ErrorAction Stop) }catch{ $null } }

# --- Locate ---
Banner "LOCATE PLEX"; Stage "Locate"
$found   = Find-PlexSupport
$PlexRoot= $found.Root
$DbPath  = $found.Db
$PlexExe = Find-PlexExe
if($PlexRoot){ Log ("PlexRoot => {0}" -f $PlexRoot) } else { Log "PlexRoot => (not found)" }
if($DbPath){   Log ("DB Path  => {0}" -f $DbPath)   } else { Log "DB Path  => (not found)" }
if($PlexExe){  Log ("PlexExe  => {0}" -f $PlexExe)  } else { Log "PlexExe  => (not found)" }

# --- Snapshot (consistent) ---
Banner "SNAPSHOT"; Stage "Snapshot"
try{
  if($PlexRoot){
    $pref = Join-Path $PlexRoot 'Preferences.xml'
    if(Test-Path $pref -PathType Leaf){
      Copy-Item -LiteralPath $pref -Destination (Join-Path $SnapDir '_root_Preferences.xml') -Force
      Log "Backed up Preferences.xml"
    }
    # copy logs (best-effort)
    $logs = Join-Path $PlexRoot 'Logs'
    if(Test-Path $logs){ Copy-Item -LiteralPath $logs -Destination (Join-Path $SnapDir 'Logs') -Recurse -Force -ErrorAction SilentlyContinue }
  }
  # identity.xml (non-fatal)
  try{ Invoke-WebRequest -Uri 'http://127.0.0.1:32400/identity' -UseBasicParsing -TimeoutSec 3 -OutFile (Join-Path $SnapDir 'identity.xml') }catch{}
  # consistent DB copy via sqlite .backup even if live DB is locked
  $haveSql = Ensure-Sqlite $Sqlite $BinDir
  if($haveSql -and $DbPath){
    $snapDbDir = Join-Path $SnapDir 'Databases'; Ensure-Dir $snapDbDir
    $clean = Join-Path $snapDbDir 'com.plexapp.plugins.library.clean.db'
    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName=$Sqlite; $psi.Arguments=('"{0}" ".timeout 5000" ".backup ''{1}''"' -f $DbPath.Replace('"','""'), $clean.Replace("'","''"))
    $psi.RedirectStandardOutput=$true; $psi.RedirectStandardError=$true; $psi.UseShellExecute=$false
    $p=[Diagnostics.Process]::Start($psi); $null=$p.StandardOutput.ReadToEnd(); $err=$p.StandardError.ReadToEnd(); $p.WaitForExit()
    if($err){ Log ("sqlite backup note: {0}" -f $err) } else { Log "Backed up library DB" }
  }
}catch{ Log ("Snapshot note -> {0}" -f $_.Exception.Message) }

# --- Stop & clean journals ---
Banner "STOP & CLEAN"; Stage "StopClean"
Stop-Plex
if($DbPath){
  foreach($j in @("$DbPath-shm","$DbPath-wal")){
    if(Test-Path $j){ try{ Move-Item -LiteralPath $j -Destination ($j + '.old.' + (Get-Date -Format 'yyyyMMdd-HHmmss')) -Force; Log ("Moved stale -> {0}" -f ([IO.Path]::GetFileName($j))) }catch{} }
  }
}

# --- Preferences fixups (safe defaults) ---
Banner "PREFERENCES FIXUPS"; Stage "Prefs"
if($PlexRoot){
  try{
    $pref = Join-Path $PlexRoot 'Preferences.xml'
    if(Test-Path $pref -PathType Leaf){
      $orig  = Get-Content -LiteralPath $pref -Raw
      $revert = Join-Path $WorkDir 'revert_prefs.ps1'
      $orig | Set-Content -LiteralPath (Join-Path $WorkDir 'Preferences.orig.xml') -Encoding UTF8
      # compute allowedNetworks from current adapters (fallback keeps your previous if looks sane)
      $subnets=@('127.0.0.1/8')
      try{
        $ifaces = Get-NetIPAddress -AddressFamily IPv4 -ErrorAction SilentlyContinue | Where-Object { $_.IPAddress -notlike '169.254.*' -and $_.PrefixLength -ge 8 }
        foreach($i in $ifaces){
          # derive x.y.z.0/24 for typical home nets; if prefix /16 or /24 we keep that
          $pl = [int]$i.PrefixLength
          if($pl -ge 24){ $subnets += ("{0}/{1}" -f $i.IPAddress,$pl) } else { # round to /24
            $oct = $i.IPAddress.Split('.'); if($oct.Count -eq 4){ $subnets += ("{0}.{1}.{2}.0/24" -f $oct[0],$oct[1],$oct[2]) }
          }
        }
      }catch{}
      $subnets = ($subnets | Select-Object -Unique) -join ','

      $text=$orig
      # secureConnections -> preferred (if missing/empty)
      if($text -notmatch 'secureConnections="[^"]+"'){ $text = $text -replace '<Preferences\s', '<Preferences secureConnections="preferred" ' }
      # allowedNetworks -> computed subnets if the existing looks invalid (wildcards or blanks)
      $m = [regex]::Match($text,'allowedNetworks="([^"]*)"')
      if($m.Success){
        $val = $m.Groups[1].Value
        if([string]::IsNullOrWhiteSpace($val) -or $val -match '[\*\s]'){ $text = $text -replace 'allowedNetworks="[^"]*"', ('allowedNetworks="{0}"' -f $subnets) }
      }else{
        $text = $text -replace '<Preferences\s', ('<Preferences allowedNetworks="{0}" ' -f $subnets)
      }
      # PreferredNetworkInterface -> remove (lets Plex auto-pick)
      $text = [regex]::Replace($text,'\s+PreferredNetworkInterface="[^"]*"','')

      Set-Content -LiteralPath $pref -Value $text -Encoding UTF8
      Log ("Prefs now => secureConnections=preferred ; allowedNetworks='{0}' ; PreferredNetworkInterface=''" -f $subnets)
      # write revert helper
      @"
# revert Preferences.xml
Copy-Item -LiteralPath '$($WorkDir.Replace("'", "''"))\Preferences.orig.xml' -Destination '$($pref.Replace("'", "''"))' -Force
"@ | Set-Content -LiteralPath $revert -Encoding UTF8
    }
  }catch{ Log ("Prefs fix note -> {0}" -f $_.Exception.Message) }
}else{ Log "Preferences step skipped (PlexRoot not found)." }

# --- Firewall 32400 (idempotent) ---
Banner "FIREWALL"; Stage "Firewall"
try{
  $ruleName='Plex 32400'
  $have = netsh advfirewall firewall show rule name="$ruleName" | Select-String -SimpleMatch "$ruleName"
  if(-not $have){ netsh advfirewall firewall add rule name="$ruleName" dir=in action=allow protocol=TCP localport=32400 profile=private | Out-Null; Log "Firewall rule added for TCP 32400" }
  else{ Log "Firewall rule already present for TCP 32400" }
}catch{ Log ("Firewall note -> {0}" -f $_.Exception.Message) }

# --- Restart + wait ---
Banner "RESTART PLEX"; Stage "Restart"
Start-Plex $PlexExe
$ready = Wait-PlexReady -sec 150

# --- Media health scan (recent items) + report ---
Banner "MEDIA HEALTH"; Stage "Health"
$csv = Join-Path $RptDir ("media-health-$ts.csv")
$txt = Join-Path $RptDir ("media-health-$ts.txt")

if($DbPath -and (Ensure-Sqlite $Sqlite $BinDir)){
  $sql=@"
SELECT m.id, m.metadata_type, COALESCE(m.title, m.original_title, m.guid) AS title, p.file
FROM metadata_items m
JOIN media_items  i ON i.metadata_item_id = m.id
JOIN media_parts  p ON p.media_item_id   = i.id
WHERE p.file IS NOT NULL
ORDER BY m.added_at DESC
LIMIT 800;
"@
  $raw = Invoke-Sqlite $DbPath $sql
  $rows = @()
  foreach($line in ($raw -split "`n")){
    if(-not $line.Trim()){ continue }
    $parts = $line -split '\|'
    if($parts.Count -lt 4){ continue }
    $id=$parts[0]; $mt=$parts[1]; $title=$parts[2]; $path=$parts[3]
    $kind='File'; if($path -match '^(?i)https?://'){ $kind='URL' } elseif($path -match '\.strm$'){ $kind='STRM' }
    $ok=$false; $detail=''
    if($kind -eq 'URL'){
      try{ $r=Invoke-WebRequest -Method Head -Uri $path -UseBasicParsing -TimeoutSec 6; $ok=($r.StatusCode -ge 200 -and $r.StatusCode -lt 400); $detail='HTTP '+$r.StatusCode }catch{ $ok=$false; $detail='HTTP fail: '+$_.Exception.Message }
    }elseif($kind -eq 'STRM'){
      $u=FirstLine $path
      if($u -and $u -match '^(?i)https?://'){ try{ $r=Invoke-WebRequest -Method Head -Uri $u -UseBasicParsing -TimeoutSec 6; $ok=($r.StatusCode -ge 200 -and $r.StatusCode -lt 400); $detail='STRM->HTTP '+$r.StatusCode }catch{ $ok=$false; $detail='STRM HTTP fail: '+$_.Exception.Message } }
      else{ $ok = Test-Path $u; $detail='STRM->File ' + ($(if($ok){'ok'}else{'missing'})) }
    }else{
      $ok = Test-Path $path
      if($ok){ try{ $len=(Get-Item -LiteralPath $path).Length; $detail="Exists, $len bytes" }catch{ $detail='Exists' } } else { $detail='Missing' }
    }
    $rows += [pscustomobject]@{ Title=$title; Type=$mt; Kind=$kind; Path=$path; OK=$ok; Detail=$detail }
  }
  $rows | Export-Csv -Path $csv -NoTypeInformation -Encoding UTF8
  $bad = $rows | Where-Object { -not $_.OK }
  @(
    "Media health report: $($rows.Count) items checked",
    "Problem items: $($bad.Count)",
    ""
  ) + ($bad | Select-Object -First 40 | ForEach-Object { "* "+$_.Title+"  ["+$_.Kind+"]  -> "+$_.Detail }) | Out-File -FilePath $txt -Encoding UTF8
  Log ("Health summary -> {0}" -f $txt)
}else{
  Log "Skipped media health (no DB/sqlite)."
}

# --- Zip bundle ---
Banner "PACKAGE"; Stage "Zip"
try{
  $zip = "$WorkDir.zip"
  if(Test-Path $zip){ Remove-Item $zip -Force -ErrorAction SilentlyContinue }
  Compress-Archive -Path (Join-Path $WorkDir '*') -DestinationPath $zip -Force
  Log ("Bundle -> {0}" -f $zip)
}catch{ Log ("ZIP note -> {0}" -f $_.Exception.Message) }

# --- Done ---
Banner "DONE"
Log ("Work dir -> {0}" -f $WorkDir)
Log ("Stage    -> {0}" -f $StageFile)
Log ("Log      -> {0}" -f $Log)

<# Enhancements auto-included:
 - Consistent DB snapshot via sqlite .backup to avoid lock issues.
 - Staged logging + identity capture for easy triage.
 - Safe prefs normalization: secureConnections=preferred, sane allowedNetworks from live adapters, PreferredNetworkInterface cleared.
 - Stale journal cleanup (-shm/-wal), firewall 32400 ensure.
 - Restart + HTTP wait, then media path/URL/STRM health report.
 - ZIP bundle with logs+reports for one-file capture.
#>
# ==================== END: PLEX_S1001_FIRSTAID_ALLINONE ====================


==================== LOCATE PLEX ====================
[2025-10-06 21:04:51] PlexRoot => C:\Users\jason\AppData\Local\Plex Media Server
[2025-10-06 21:04:51] DB Path  => C:\Users\jason\AppData\Local\Plex Media Server\Plug-in Support\Databases\com.plexapp.plugins.library.db
[2025-10-06 21:04:51] PlexExe  => C:\Program Files\Plex\Plex Media Server\Plex Media Server.exe

==================== SNAPSHOT ====================
[2025-10-06 21:04:51] Backed up Preferences.xml
[2025-10-06 21:05:00] Backed up library DB

==================== STOP & CLEAN ====================
[2025-10-06 21:05:01] Plex stopped (best-effort).
[2025-10-06 21:05:01] Moved stale -> com.plexapp.plugins.library.db-shm
[2025-10-06 21:05:01] Moved stale -> com.plexapp.plugins.library.db-wal

==================== PREFERENCES FIXUPS ====================
[2025-10-06 21:05:01] Prefs now => secureConnections=preferred ; allowedNetworks='127.0.0.1/8,192.168.1.184/24,127.0.0.0/24' ; PreferredNetworkInterface=''

==================== FIREWALL ====================
[2025-10-06 21:05:01] Firewall rule already present for TCP 32400

==================== RESTART PLEX ====================
[2025-10-06 21:05:02] Started Plex exe -> C:\Program Files\Plex\Plex Media Server\Plex Media Server.exe
PS C:\Windows\System32> TerminatingError(Invoke-WebRequest): "
<Response
  code="503"
  title="Maintenance"
  status="Plex Media Server is currently running startup maintenance tasks." />"
PS C:\Windows\System32> TerminatingError(Invoke-WebRequest): "
<Response
  code="503"
  title="Maintenance"
  status="Plex Media Server is currently running startup maintenance tasks." />"
PS C:\Windows\System32> TerminatingError(Invoke-WebRequest): "
<Response
  code="503"
  title="Maintenance"
  status="Plex Media Server is currently running startup maintenance tasks." />"
[2025-10-06 21:05:05] Plex HTTP ready: True

==================== MEDIA HEALTH ====================
[2025-10-06 21:05:05] Health summary -> D:\PlexFirstAid\FirstAid-20251006-210451\Reports\media-health-20251006-210451.txt

==================== PACKAGE ====================
[2025-10-06 21:05:19] Bundle -> D:\PlexFirstAid\FirstAid-20251006-210451.zip

==================== DONE ====================
[2025-10-06 21:05:19] Work dir -> D:\PlexFirstAid\FirstAid-20251006-210451
[2025-10-06 21:05:19] Stage    -> D:\PlexFirstAid\FirstAid-20251006-210451\stage.txt
[2025-10-06 21:05:19] Log      -> D:\PlexFirstAid\FirstAid-20251006-210451\plex-firstaid-20251006-210451.log
PS C:\Windows\System32> cls
PS C:\Windows\System32> & {
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
  function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
  function HasProp($o,$n){ ($o -ne $null) -and ($o.PSObject.Properties.Name -contains $n) -and ($o.$n -ne $null -and $o.$n -ne '') }
  function TryProp { param($o,[string[]]$names) foreach($n in $names){ if(HasProp $o $n){ return $o.$n } } return $null }
  function ReadFlex($p){ if(-not (Test-Path $p)){ return @() }; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json
    if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }
  function Mask($s){ if([string]::IsNullOrWhiteSpace($s)){'<empty>'} elseif($s.Length -le 6){'*'*$s.Length} else {'*'*($s.Length-6)+$s.Substring($s.Length-6)} }

  Say "UDM Auditor v2.7 quick-run starting..."

  # --- Hardcoded local admin (per your request) ---
  $LOCAL_USER = 'udm_Local_api'
  $LOCAL_PASS = 'W1ll0w1703!!'

  # --- Paths ---
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'; $Root='D:\PlexTools'
  $Reports=Join-Path $Root 'reports'; $Cache=Join-Path $Root 'cache'
  Ensure-Dir $Vault; Ensure-Dir $Reports; Ensure-Dir $Cache
  $Stamp=Get-Date -Format 'yyyyMMdd_HHmmss'; $Prefix="udm_audit_$Stamp"
  $Summary=Join-Path $Reports "$Prefix.summary.txt"
  "UDM Auditor v2.7 â€” $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

  # --- Save creds (plain + DPAPI) so other tools read them too ---
  try{
    Set-Content (Join-Path $Vault 'udm_user.txt') $LOCAL_USER -Encoding ASCII
    Set-Content (Join-Path $Vault 'udm_pass.txt') $LOCAL_PASS -Encoding ASCII
    $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
    $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
    [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)
    Add-Content $Summary ("Local admin saved. user={0} pass(masked)={1}" -f $LOCAL_USER,(Mask $LOCAL_PASS)) -Encoding UTF8
  }catch{ Add-Content $Summary ("Cred save error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

  # --- Environment + basics ---
  [Net.WebRequest]::DefaultWebProxy=$null; $env:HTTP_PROXY='';$env:HTTPS_PROXY='';$env:ALL_PROXY=''
  try{ [Net.ServicePointManager]::Expect100Continue=$false; $p=[Net.ServicePointManager]::SecurityProtocol
       if(($p -band [Net.SecurityProtocolType]::Tls12) -eq 0){ [Net.ServicePointManager]::SecurityProtocol=$p -bor [Net.SecurityProtocolType]::Tls12 } }catch{}
  $curl=Get-Command curl.exe -ErrorAction SilentlyContinue
  if(-not $curl){ Say "curl.exe missing in PATH" 'Red'; Add-Content $Summary 'curl.exe not found.'; Get-Content $Summary; return }

  # --- IP + Integration key (optional) ---
  $UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt')
  if([string]::IsNullOrWhiteSpace($UDM_IP)){
    $gw=(Get-NetIPConfiguration|?{ $_.IPv4DefaultGateway -and $_.IPv4Address }|Select-Object -First 1)
    if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII }
  }
  ("UDM IP: {0}" -f ($(if($UDM_IP){$UDM_IP}else{'<missing>'}))) | Add-Content -LiteralPath $Summary -Encoding UTF8
  if(-not $UDM_IP){ Say "No UDM IP found; aborting." 'Red'; Get-Content $Summary; return }
  $API_KEY = ***REDACTED*** (Join-Path $Vault 'udm_token.txt')

  # --- Discover canonical host via redirect from https://<IP>/ ---
  $DiscoveredHost=$null
  try{
    $eff = & $curl.Source @('-sS','-k','--noproxy','*','-L','--max-redirs','5','-o','NUL','-w','%{url_effective}',("https://$UDM_IP/")) 2>$null
    if($eff -and $eff -match '^https?://'){ try{ $u=[uri]$eff; if($u.Host){ $DiscoveredHost=$u.Host } }catch{} }
    if($DiscoveredHost){ Add-Content $Summary ("Discovered host: {0}" -f $DiscoveredHost) -Encoding UTF8; Say "Discovered host: $DiscoveredHost" 'Yellow'
                         Set-Content -LiteralPath (Join-Path $Vault 'udm_hostname.txt') -Value $DiscoveredHost -Encoding ASCII }
    else { Add-Content $Summary "No redirect host discovered (stayed on IP or blocked)." -Encoding UTF8 }
  }catch{ Add-Content $Summary ("Host discovery error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

  # --- Build host list + --resolve map for SNI ---
  $StoredHost = ReadIf (Join-Path $Vault 'udm_hostname.txt')
  $TryHosts=@(); if($DiscoveredHost){$TryHosts+=$DiscoveredHost}elseif($StoredHost){$TryHosts+=$StoredHost}
  $TryHosts += @('unifi','udm','unifi.localdomain','unifi.home','udm.home','udm.local', $UDM_IP)
  $TryHosts = $TryHosts | Select-Object -Unique
  $ResolveArgs=@(); foreach($hn in $TryHosts){ if($UDM_IP -and $hn -notmatch '^\d+\.\d+\.\d+\.\d+$'){ $ResolveArgs += @('--resolve',("$hn:443:$UDM_IP")) } }
  $ResolveArgs += @('--resolve',("$UDM_IP:443:$UDM_IP"))

  # --- Helpers for cookie login ---
  $CookieJar = Join-Path $Cache ("udm_cookie_{0}.txt" -f $Stamp)
  function CurlGetCsrf([string]$hn,[string]$csrfOut){
    if(Test-Path $CookieJar){ Remove-Item -LiteralPath $CookieJar -Force -ErrorAction SilentlyContinue }
    $url="https://$hn/api/auth/csrf"
    $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','15','-L') + $ResolveArgs +
          @('-H','Accept: application/json','-H','User-Agent: UDM-Login','-c',$CookieJar,'-b',$CookieJar,'-o',$csrfOut,'-w','%{http_code}', $url)
    try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
  }
  function CurlLogin([string]$hn,[string]$token){
    $url="https://$hn/api/auth/login"
    $payload="{`"username`":`"$LOCAL_USER`",`"password`":`"$LOCAL_PASS`",`"rememberMe`":true}"
    $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','20','-L') + $ResolveArgs +
          @('-H','Accept: application/json','-H','Content-Type: application/json','-H','User-Agent: UDM-Login',
            '-H',("Origin: https://$hn"),'-H',("Referer: https://$hn/"),'-H',("X-Csrf-Token: $token"),
            '-c',$CookieJar,'-b',$CookieJar,'--data-binary',$payload,$url,'-w','%{http_code}')
    try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
  }
  function CurlJsonCookie([string]$hn,[string]$path,[string]$outfile){
    $url="https://$hn$path"
    $csrf=$null; if(Test-Path $CookieJar){ try{ $lines=Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII; $m=[regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)'); if($m.Count -gt 0){ $csrf=$m[$m.Count-1].Groups[1].Value.Trim() } }catch{} }
    $args=@('-sS','-k','--http1.1','--noproxy','*','--connect-timeout','8','--max-time','25','-L') + $ResolveArgs +
          @('-H','Accept: application/json','-H','User-Agent: UDM-GET','-c',$CookieJar,'-b',$CookieJar,'-o',$outfile,'-w','%{http_code}', $url)
    if($csrf){ $args=@('-H',("X-Csrf-Token: $csrf")) + $args }
    try{ $code=& $curl.Source $args 2>$null; if($code -match '^\d{3}$'){ [int]$code } else { -1 } }catch{ -1 }
  }
  function FetchCookie([string]$hn,[string]$path,[string]$name){
    $outfile=Join-Path $Reports ("$Prefix.$name.json")
    $code=CurlJsonCookie $hn $path $outfile
    $show = if($code -eq 0){'000 (TLS/redirect/DNS)'}elseif($code -lt 0){'tls/err'}else{$code}
    ("Cookie {0} via '{1}' -> {2}" -f $path,$hn,$show) | Add-Content -LiteralPath $Summary -Encoding UTF8
    return ($code -ge 200 -and $code -lt 300),$outfile
  }

  # --- Try hosts for CSRF+login ---
  $loginOK=$false; $CookieHost=$null; $siteShort='default'
  foreach($hn in $TryHosts){
    Say "Trying CSRF on $hn ..."
    $csrfFile=Join-Path $Cache "csrf_$($hn)_$Stamp.json"
    $c=CurlGetCsrf $hn $csrfFile
    $disp = if($c -eq 0){'000'}elseif($c -lt 0){'tls/err'}else{$c}; Say "  CSRF -> $disp"
    if($c -ne 200){ continue }
    $tok=$null; try{ $cj=Get-Content -LiteralPath $csrfFile -Raw|ConvertFrom-Json; $tok = TryProp $cj @('token','csrfToken','csrf','csrf_token') }catch{}
    if(-not $tok){
      try{ $lines=Get-Content -LiteralPath $CookieJar -Raw -Encoding ASCII; $m=[regex]::Matches($lines,'\tcsrf_token\t([^\r\n]+)'); if($m.Count -gt 0){ $tok=$m[$m.Count-1].Groups[1].Value.Trim() } }catch{}
    }
    if(-not $tok){ Say "  No CSRF token parsed."; continue }
    $lc=CurlLogin $hn $tok
    $disp2 = if($lc -eq 0){'000'}elseif($lc -lt 0){'tls/err'}else{$lc}; Say "  LOGIN -> $disp2"
    if($lc -eq 200){ $loginOK=$true; $CookieHost=$hn; break }
  }

  if(-not $loginOK){
    Add-Content -LiteralPath $Summary -Value "Cookie login still blocked (SNI/redirect). Sticking to Integration API for now." -Encoding UTF8
    Say "Cookie login blocked. Summary next." 'Yellow'
    Get-Content -LiteralPath $Summary; return
  }

  Add-Content -LiteralPath $Summary -Value ("Cookie login OK using host '{0}'." -f $CookieHost) -Encoding UTF8
  Say "Cookie login OK on $CookieHost" 'Green'

  # --- Discover site short name ---
  $ok,$F_self = FetchCookie $CookieHost "/proxy/network/api/self/sites" "self_sites"
  if($ok){ try{ $sj=Get-Content -LiteralPath $F_self -Raw|ConvertFrom-Json; $first=$null
      if($sj.data){ $first=$sj.data|Select-Object -First 1 } elseif($sj -is [Collections.IEnumerable] -and -not ($sj -is [string])){ $first=$sj|Select-Object -First 1 }
      if($first -and (HasProp $first 'name')){ $siteShort=$first.name } }catch{} }
  ("Network site short: {0}" -f $siteShort) | Add-Content -LiteralPath $Summary -Encoding UTF8

  # --- Pull key config + stats ---
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/list/setting"        "list_setting")
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/networkconf"    "rest_networkconf")
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/list/wlanconf"       "list_wlanconf")
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/portconf"       "rest_portconf")
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallrule"   "rest_firewallrule")
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/rest/firewallgroup"  "rest_firewallgroup")
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/device"         "stat_device")
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/sta"            "stat_sta")
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/health"         "stat_health")
  $null = (FetchCookie $CookieHost "/proxy/network/api/s/$siteShort/stat/sysinfo"        "stat_sysinfo")

  # --- Quick insights if we got config ---
  $ins=Join-Path $Reports ("config_insights_{0}.txt" -f $Stamp); "Config Insights - $(Get-Date)"|Set-Content -LiteralPath $ins -Encoding UTF8
  $W=ReadFlex (Join-Path $Reports "$Prefix.list_wlanconf.json")
  $N=ReadFlex (Join-Path $Reports "$Prefix.rest_networkconf.json")
  $FR=ReadFlex (Join-Path $Reports "$Prefix.rest_firewallrule.json")
  if($W.Count -gt 0){ Add-Content $ins 'WLANs:'; foreach($w in $W){ $nm=TryProp $w @('name','ssid'); $sec=TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version'); $pmf=TryProp $w @('pmf_mode','pmf','ocpmf'); $iso=TryProp $w @('ap_isolation','isolation','is_guest','guest'); Add-Content $ins ("  - {0} | security={1} | pmf={2} | isolation={3}" -f $nm,$sec,$pmf,$iso) } }
  if($N.Count -gt 0){ $v=0; foreach($n in $N){ if(TryProp $n @('vlan','vlan_id','vlanId')){$v++} }; Add-Content $ins ("Networks: {0} (VLAN-tagged: {1})" -f $N.Count,$v) }
  if($FR.Count -gt 0){ $en=@($FR|?{ HasProp $_ 'enabled' -and $_.enabled -eq $true }).Count; Add-Content $ins ("Firewall rules: total={0}, enabled={1}" -f $FR.Count,$en) }
  ("Config insights -> {0}" -f $ins) | Add-Content -LiteralPath $Summary -Encoding UTF8

  # --- Bundle ---
  $Bundle=Join-Path $Reports "$Prefix.zip"
  try{ $toZip=Get-ChildItem -LiteralPath $Reports -File | ?{ $_.Name -like "$Prefix*" -or $_.Name -like "config_insights_$Stamp.txt" }
       if($toZip){ Compress-Archive -Path ($toZip|Select -Expand FullName) -DestinationPath $Bundle -Force }
       ("Bundle -> {0}" -f $Bundle)|Add-Content -LiteralPath $Summary -Encoding UTF8 }catch{ Add-Content -LiteralPath $Summary -Value ("Bundle error: {0}" -f $_.Exception.Message) -Encoding UTF8 }

  Say ("Done. Summary -> {0}" -f $Summary) 'Green'
  Get-Content -LiteralPath $Summary
}

[21:09:02] UDM Auditor v2.7 quick-run starting...
[21:09:03] Discovered host: 192.168.1.1
[21:09:03] Trying CSRF on 192.168.1.1 ...
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
[21:09:03]   CSRF -> 000
[21:09:03] Trying CSRF on unifi ...
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
[21:09:03]   CSRF -> 000
[21:09:03] Trying CSRF on udm ...
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
[21:09:03]   CSRF -> 000
[21:09:03] Trying CSRF on unifi.localdomain ...
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
[21:09:03]   CSRF -> 000
[21:09:03] Trying CSRF on unifi.home ...
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
[21:09:03]   CSRF -> 000
[21:09:03] Trying CSRF on udm.home ...
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
[21:09:03]   CSRF -> 000
[21:09:03] Trying CSRF on udm.local ...
curl: (49) Couldn't parse CURLOPT_RESOLVE entry '192.168.1.1'
[21:09:03]   CSRF -> 000
[21:09:03] Cookie login blocked. Summary next.
UDM Auditor v2.7 â€” 10/06/2025 21:09:02
Local admin saved. user=udm_Local_api pass(masked)=******1703!!
UDM IP: 192.168.1.1
Discovered host: 192.168.1.1
Cookie login still blocked (SNI/redirect). Sticking to Integration API for now.
PS C:\Windows\System32> cls
PS C:\Windows\System32> cls
PS C:\Windows\System32> cls
PS C:\Windows\System32> cls
PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
  function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
  function TryProp{param($o,[string[]]$names) foreach($n in $names){ if($o -and $o.PSObject.Properties[$n] -and $o.$n){ return $o.$n } } $null }
  function TryNum{param($o,[string[]]$names) foreach($n in $names){ if($o -and $o.PSObject.Properties[$n] -and $o.$n -ne $null){ try{ return [double]$o.$n }catch{} } } 0 }
  function ReadFlex($p){ if(-not(Test-Path $p)){return @()} ; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json; if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }

  Say "[START] UDM SSH audit (PS5.1-safe)"

  # Paths
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $Root='D:\PlexTools'; $Reports=Join-Path $Root 'reports'; $Cache=Join-Path $Root 'cache'; $Bin=Join-Path $Root 'bin'
  Ensure-Dir $Vault; Ensure-Dir $Reports; Ensure-Dir $Cache; Ensure-Dir $Bin

  # Save UniFi local app creds (per your request)
  $LOCAL_USER='udm_Local_api'; $LOCAL_PASS='W1ll0w1703!!'
  Set-Content (Join-Path $Vault 'udm_user.txt') $LOCAL_USER -Encoding ASCII
  Set-Content (Join-Path $Vault 'udm_pass.txt') $LOCAL_PASS -Encoding ASCII
  $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
  $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
  [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)

  # SSH creds (device OS)
  $SSH_USER = (ReadIf (Join-Path $Vault 'udm_ssh_user.txt')); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root'; Set-Content (Join-Path $Vault 'udm_ssh_user.txt') $SSH_USER -Encoding ASCII }
  $SSH_PASS = 'W1ll0w1703!!'; Set-Content (Join-Path $Vault 'udm_ssh_pass.txt') $SSH_PASS -Encoding ASCII

  # UDM IP
  $UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt')
  if([string]::IsNullOrWhiteSpace($UDM_IP)){
    $gw=(Get-NetIPConfiguration|?{ $_.IPv4DefaultGateway -and $_.IPv4Address }|Select-Object -First 1)
    if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII }
  }
  if(-not $UDM_IP){ throw "UDM IP not found. Put 192.168.1.1 in $Vault\udm_ip.txt" }

  $Stamp=Get-Date -Format 'yyyyMMdd_HHmmss'
  $Prefix="udm_ssh_audit_$Stamp"
  $Summary=Join-Path $Reports "$Prefix.summary.txt"
  "UDM SSH Auditor â€” $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

  # Prefer OpenSSH; fallback to PuTTY if missing
  $ssh = Get-Command ssh.exe -ErrorAction SilentlyContinue
  $scp = Get-Command scp.exe -ErrorAction SilentlyContinue
  if(-not $ssh -or -not $scp){
    $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
    $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
    if(-not $plink -or -not $pscp){
      Say "Downloading PuTTY (plink/pscp)..." 'Yellow'
      $PlinkPath = Join-Path $Bin 'plink.exe'; $PscpPath  = Join-Path $Bin 'pscp.exe'
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe' -OutFile $PlinkPath
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe'  -OutFile $PscpPath
      $plink = Get-Command $PlinkPath; $pscp = Get-Command $PscpPath
    }
  }

  # Remote shell script as line array (PowerShell-safe quoting)
  $RemoteLines=@()
  $RemoteLines += '#!/bin/sh'
  $RemoteLines += 'set -e'
  $RemoteLines += 'TS=$(date +%Y%m%d_%H%M%S)'
  $RemoteLines += 'OUT="/tmp/plexaudit_$TS"'
  $RemoteLines += 'mkdir -p "$OUT"'
  $RemoteLines += 'echo "OUT=$OUT"'
  $RemoteLines += ("UUSER=""{0}""" -f $LOCAL_USER)
  $RemoteLines += ("UPASS=""{0}""" -f $LOCAL_PASS)
  $RemoteLines += 'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/api/auth/csrf" -o "$OUT/csrf.json" -w "%{http_code}" > "$OUT/csrf.code"'
  # NOTE: single quotes inside PS single-quoted strings must be doubled:
  $RemoteLines += 'TOKEN=$(sed -n ''s/.*"token":"\([^"]*\)".*/\1/p'' "$OUT/csrf.json")'
  $RemoteLines += 'if [ -z "$TOKEN" ]; then TOKEN=$(awk ''/csrf_token/ {print $NF}'' "$OUT/cookie" | tail -n1); fi'
  $RemoteLines += 'LOGIN_CODE=$(curl -sk -L -o "$OUT/login.json" -w "%{http_code}" -c "$OUT/cookie" -b "$OUT/cookie" -H "Content-Type: application/json" -H "X-Csrf-Token: $TOKEN" --data "{\"username\":\"$UUSER\",\"password\":\"$UPASS\",\"rememberMe\":true}" "https://127.0.0.1/api/auth/login")'
  $RemoteLines += 'echo "$LOGIN_CODE" > "$OUT/login.code"'
  $RemoteLines += 'if [ "$LOGIN_CODE" != "200" ]; then echo "LOGIN_FAIL=$LOGIN_CODE" > "$OUT/status.txt"; echo "$OUT"; exit 0; fi'
  $RemoteLines += 'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/proxy/network/api/self/sites" -o "$OUT/self_sites.json"'
  $RemoteLines += 'SITE=$(sed -n ''s/.*"name":"\([^"]*\)".*/\1/p'' "$OUT/self_sites.json" | head -n1); [ -z "$SITE" ] && SITE="default"'
  $RemoteLines += 'echo "SITE=$SITE" > "$OUT/status.txt"'
  $RemoteLines += 'fetch(){ P="$1"; N="$2"; curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1${P}" -o "$OUT/${N}.json" -w "%{http_code}" > "$OUT/${N}.code"; }'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/list/setting"       "list_setting"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/networkconf"   "rest_networkconf"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/list/wlanconf"      "list_wlanconf"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/portconf"      "rest_portconf"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/firewallrule"  "rest_firewallrule"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/firewallgroup" "rest_firewallgroup"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/device"        "stat_device"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/sta"           "stat_sta"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/health"        "stat_health"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/sysinfo"       "stat_sysinfo"'
  $RemoteLines += 'echo "DONE" >> "$OUT/status.txt"'
  $RemoteLines += 'echo "$OUT"'
  $TmpSh = Join-Path $Cache ("udm_remote_{0}.sh" -f $Stamp)
  Set-Content -LiteralPath $TmpSh -Value $RemoteLines -Encoding ASCII
  Say ("Remote script written -> {0}" -f $TmpSh) 'DarkGray'

  # Run remote script and pull results
  Say "Connecting via SSH and running export on the UDM..." 'Yellow'
  $RemoteOutDir=$null
  if($ssh -and $scp){
    $RemoteRun = & $ssh.Source -o "StrictHostKeyChecking=no" -o "UserKnownHostsFile=/dev/null" "$SSH_USER@$UDM_IP" '/bin/sh -s' < $TmpSh
    $RemoteOutDir = ($RemoteRun | Select-Object -Last 1).Trim()
    if([string]::IsNullOrWhiteSpace($RemoteOutDir) -or -not ($RemoteOutDir -like "/tmp/plexaudit_*")){ Add-Content $Summary "Remote run failed (OpenSSH)."; Say "Remote run failed (OpenSSH)." 'Red'; Get-Content $Summary; return }
    & $scp.Source -o "StrictHostKeyChecking=no" -o "UserKnownHostsFile=/dev/null" -q "$SSH_USER@$UDM_IP:$RemoteOutDir/*" $Reports
  } else {
    $plink = Get-Command (Join-Path $Bin 'plink.exe')
    $pscp  = Get-Command (Join-Path $Bin 'pscp.exe')
    $RemoteRun = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} -m `"{4}`"" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$TmpSh)
    $RemoteOutDir = ($RemoteRun | Select-Object -Last 1).Trim()
    if([string]::IsNullOrWhiteSpace($RemoteOutDir) -or -not ($RemoteOutDir -like "/tmp/plexaudit_*")){ Add-Content $Summary "Remote run failed (PuTTY)."; Say "Remote run failed (PuTTY)." 'Red'; Get-Content $Summary; return }
    $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q {3}:{4} `"{5}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$RemoteOutDir+'/*',$Reports)
  }
  Add-Content $Summary ("Pulled from {0}" -f $RemoteOutDir)

  # Build insights + top talkers
  $ExportFiles = Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -match '^(list_|rest_|stat_)' } | Sort-Object LastWriteTime -Descending
  $ByName=@{}; foreach($f in $ExportFiles){ $ByName[$f.BaseName]=$f.FullName }
  $W = ReadFlex ($ByName['list_wlanconf']); $N=ReadFlex ($ByName['rest_networkconf']); $FR=ReadFlex ($ByName['rest_firewallrule']); $CL=ReadFlex ($ByName['stat_sta'])

  $TopCSV = Join-Path $Reports "$Prefix.top_talkers.csv"
  try{
    $rows=@(); foreach($c in $CL){
      $name=TryProp $c @('hostname','host_name','name','displayName','display_name','device_name','fingerprint_name','mac')
      $mac =TryProp $c @('mac'); $ip=TryProp $c @('ip','ip_address','ipv4','primaryIp','primary_ip')
      $ssid=TryProp $c @('ssid','wlan','wifi_ssid','wlan_name'); $band=TryProp $c @('radio','band','phy')
      $tx=TryNum $c @('tx_bytes','txBytes','tx_total','tx_total_bytes'); $rx=TryNum $c @('rx_bytes','rxBytes','rx_total','rx_total_bytes')
      $rows += [pscustomobject]@{ name=($name ?? $mac); mac=$mac; ip=$ip; ssid=$ssid; band=$band; tx_bytes=$tx; rx_bytes=$rx; total_bytes=($tx+$rx) }
    }
    $rows | Sort-Object total_bytes -Descending | Select-Object -First 50 | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8
    Add-Content $Summary ("Top talkers -> {0}" -f $TopCSV)
  }catch{ Add-Content $Summary ("Top talkers error: {0}" -f $_.Exception.Message) }

  $Ins = Join-Path $Reports "config_insights_$Stamp.txt"
  try{
    "Config Insights - $(Get-Date)" | Set-Content -LiteralPath $Ins -Encoding UTF8
    if($W.Count -gt 0){
      Add-Content $Ins "WLANs:"
      foreach($w in $W){
        $nm=TryProp $w @('name','ssid'); if(-not $nm){ $nm='(unnamed)' }
        $sec=TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version'); $pmf=TryProp $w @('pmf_mode','pmf','ocpmf')
        $iso=TryProp $w @('ap_isolation','isolation','is_guest','guest')
        Add-Content $Ins ("  - {0} | security={1} | pmf={2} | isolation={3}" -f $nm,$sec,$pmf,$iso)
      }
      Add-Content $Ins ""
    }
    if($N.Count -gt 0){
      $v=0; foreach($n in $N){ if(TryProp $n @('vlan','vlan_id','vlanId')){$v++} }
      Add-Content $Ins ("Networks: {0} (VLAN-tagged: {1})" -f $N.Count,$v)
    }
    if($FR.Count -gt 0){
      $en=@($FR|?{ $_.PSObject.Properties['enabled'] -and $_.enabled -eq $true }).Count
      Add-Content $Ins ("Firewall rules: total={0}, enabled={1}" -f $FR.Count,$en)
    }
    Add-Content $Summary ("Config insights -> {0}" -f $Ins)
  }catch{ Add-Content $Summary ("Insights error: {0}" -f $_.Exception.Message) }

  # Zip bundle
  $Bundle = Join-Path $Reports "$Prefix.bundle.zip"
  try{
    $toZip = Get-ChildItem -LiteralPath $Reports -File | ?{ $_.Name -match '^(list_|rest_|stat_)' -or $_.Name -eq (Split-Path $TopCSV -Leaf) -or $_.Name -like "config_insights_*" }
    if($toZip){ Compress-Archive -Path ($toZip|Select -Expand FullName) -DestinationPath $Bundle -Force }
    Add-Content $Summary ("Bundle -> {0}" -f $Bundle)
  }catch{ Add-Content $Summary ("Bundle error: {0}" -f $_.Exception.Message) }

  Say ("SSH audit complete -> {0}" -f $Summary) 'Green'
  Get-Content -LiteralPath $Summary
}

At line:98 char:129
+ â€¦ erKnownHostsFile=/dev/null" "$SSH_USER@$UDM_IP" '/bin/sh -s' < $TmpSh
+                                                                ~
The '<' operator is reserved for future use.

At line:101 char:97
+ â€¦ =no" -o "UserKnownHostsFile=/dev/null" -q "$SSH_USER@$UDM_IP:$RemoteO â€¦
+                                                        ~~~~~~~~
Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.
ParserError: 
Line |
  98 |  â€¦ erKnownHostsFile=/dev/null" "$SSH_USER@$UDM_IP" '/bin/sh -s' < $TmpSh
     |                                                                 ~
     | The '<' operator is reserved for future use.

PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
  function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
  function TryProp{param($o,[string[]]$names) foreach($n in $names){ if($o -and $o.PSObject.Properties[$n] -and $o.$n){ return $o.$n } } $null }
  function TryNum{param($o,[string[]]$names) foreach($n in $names){ if($o -and $o.PSObject.Properties[$n] -and $o.$n -ne $null){ try{ return [double]$o.$n }catch{} } } 0 }
  function ReadFlex($p){ if(-not(Test-Path $p)){return @()} ; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json; if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }

  Say "[START] UDM SSH audit (PS5.1 no-stdin-redirect)"

  # Paths
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $Root='D:\PlexTools'; $Reports=Join-Path $Root 'reports'; $Cache=Join-Path $Root 'cache'; $Bin=Join-Path $Root 'bin'
  Ensure-Dir $Vault; Ensure-Dir $Reports; Ensure-Dir $Cache; Ensure-Dir $Bin

  # Save UniFi local app creds (per your request)
  $LOCAL_USER='udm_Local_api'; $LOCAL_PASS='W1ll0w1703!!'
  Set-Content (Join-Path $Vault 'udm_user.txt') $LOCAL_USER -Encoding ASCII
  Set-Content (Join-Path $Vault 'udm_pass.txt') $LOCAL_PASS -Encoding ASCII
  $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
  $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
  [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)

  # SSH creds (device OS)
  $SSH_USER = (ReadIf (Join-Path $Vault 'udm_ssh_user.txt')); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root'; Set-Content (Join-Path $Vault 'udm_ssh_user.txt') $SSH_USER -Encoding ASCII }
  $SSH_PASS = 'W1ll0w1703!!'; Set-Content (Join-Path $Vault 'udm_ssh_pass.txt') $SSH_PASS -Encoding ASCII

  # UDM IP
  $UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt')
  if([string]::IsNullOrWhiteSpace($UDM_IP)){
    $gw=(Get-NetIPConfiguration|?{ $_.IPv4DefaultGateway -and $_.IPv4Address }|Select-Object -First 1)
    if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII }
  }
  if(-not $UDM_IP){ throw "UDM IP not found. Put 192.168.1.1 in $Vault\udm_ip.txt" }

  $Stamp=Get-Date -Format 'yyyyMMdd_HHmmss'
  $Prefix="udm_ssh_audit_$Stamp"
  $Summary=Join-Path $Reports "$Prefix.summary.txt"
  "UDM SSH Auditor â€” $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

  # Prefer OpenSSH; fallback to PuTTY if missing
  $ssh = Get-Command ssh.exe -ErrorAction SilentlyContinue
  $scp = Get-Command scp.exe -ErrorAction SilentlyContinue
  if(-not $ssh -or -not $scp){
    $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
    $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
    if(-not $plink -or -not $pscp){
      Say "Downloading PuTTY (plink/pscp)..." 'Yellow'
      $PlinkPath = Join-Path $Bin 'plink.exe'; $PscpPath  = Join-Path $Bin 'pscp.exe'
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe' -OutFile $PlinkPath
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe'  -OutFile $PscpPath
      $plink = Get-Command $PlinkPath; $pscp = Get-Command $PscpPath
    }
  }

  # Remote shell script (PowerShell-safe quoting)
  $RemoteLines=@()
  $RemoteLines += '#!/bin/sh'
  $RemoteLines += 'set -e'
  $RemoteLines += 'TS=$(date +%Y%m%d_%H%M%S)'
  $RemoteLines += 'OUT="/tmp/plexaudit_$TS"'
  $RemoteLines += 'mkdir -p "$OUT"'
  $RemoteLines += 'echo "OUT=$OUT"'
  $RemoteLines += ("UUSER=""{0}""" -f $LOCAL_USER)
  $RemoteLines += ("UPASS=""{0}""" -f $LOCAL_PASS)
  $RemoteLines += 'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/api/auth/csrf" -o "$OUT/csrf.json" -w "%{http_code}" > "$OUT/csrf.code"'
  $RemoteLines += 'TOKEN=$(sed -n ''s/.*"token":"\([^"]*\)".*/\1/p'' "$OUT/csrf.json")'
  $RemoteLines += 'if [ -z "$TOKEN" ]; then TOKEN=$(awk ''/csrf_token/ {print $NF}'' "$OUT/cookie" | tail -n1); fi'
  $RemoteLines += 'LOGIN_CODE=$(curl -sk -L -o "$OUT/login.json" -w "%{http_code}" -c "$OUT/cookie" -b "$OUT/cookie" -H "Content-Type: application/json" -H "X-Csrf-Token: $TOKEN" --data "{\"username\":\"$UUSER\",\"password\":\"$UPASS\",\"rememberMe\":true}" "https://127.0.0.1/api/auth/login")'
  $RemoteLines += 'echo "$LOGIN_CODE" > "$OUT/login.code"'
  $RemoteLines += 'if [ "$LOGIN_CODE" != "200" ]; then echo "LOGIN_FAIL=$LOGIN_CODE" > "$OUT/status.txt"; echo "$OUT"; exit 0; fi'
  $RemoteLines += 'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/proxy/network/api/self/sites" -o "$OUT/self_sites.json"'
  $RemoteLines += 'SITE=$(sed -n ''s/.*"name":"\([^"]*\)".*/\1/p'' "$OUT/self_sites.json" | head -n1); [ -z "$SITE" ] && SITE="default"'
  $RemoteLines += 'echo "SITE=$SITE" > "$OUT/status.txt"'
  $RemoteLines += 'fetch(){ P="$1"; N="$2"; curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1${P}" -o "$OUT/${N}.json" -w "%{http_code}" > "$OUT/${N}.code"; }'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/list/setting"       "list_setting"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/networkconf"   "rest_networkconf"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/list/wlanconf"      "list_wlanconf"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/portconf"      "rest_portconf"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/firewallrule"  "rest_firewallrule"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/firewallgroup" "rest_firewallgroup"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/device"        "stat_device"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/sta"           "stat_sta"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/health"        "stat_health"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/sysinfo"       "stat_sysinfo"'
  $RemoteLines += 'echo "DONE" >> "$OUT/status.txt"'
  $RemoteLines += 'echo "$OUT"'
  $TmpSh = Join-Path $Cache ("udm_remote_{0}.sh" -f $Stamp)
  Set-Content -LiteralPath $TmpSh -Value $RemoteLines -Encoding ASCII
  Say ("Remote script -> {0}" -f $TmpSh) 'DarkGray'

  # Run remote script and pull results
  Say "Connecting via SSH and running export on the UDM..." 'Yellow'
  $RemoteOutDir=$null
  if($ssh -and $scp){
    # PS5.1 fix: pipe the script content into ssh (no '<' redirection)
    $RemoteRun = (Get-Content -LiteralPath $TmpSh -Raw) | & $ssh.Source -o "StrictHostKeyChecking=no" -o "UserKnownHostsFile=/dev/null" "$SSH_USER@$UDM_IP" '/bin/sh -s'
    $RemoteOutDir = ($RemoteRun | Select-Object -Last 1).Trim()
    if([string]::IsNullOrWhiteSpace($RemoteOutDir) -or -not ($RemoteOutDir -like "/tmp/plexaudit_*")){ Add-Content $Summary "Remote run failed (OpenSSH)."; Say "Remote run failed (OpenSSH)." 'Red'; Get-Content $Summary; return }
    & $scp.Source -o "StrictHostKeyChecking=no" -o "UserKnownHostsFile=/dev/null" -q "$SSH_USER@$UDM_IP:$RemoteOutDir/*" $Reports
  } else {
    $plink = Get-Command (Join-Path $Bin 'plink.exe')
    $pscp  = Get-Command (Join-Path $Bin 'pscp.exe')
    $RemoteRun = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} -m `"{4}`"" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$TmpSh)
    $RemoteOutDir = ($RemoteRun | Select-Object -Last 1).Trim()
    if([string]::IsNullOrWhiteSpace($RemoteOutDir) -or -not ($RemoteOutDir -like "/tmp/plexaudit_*")){ Add-Content $Summary "Remote run failed (PuTTY)."; Say "Remote run failed (PuTTY)." 'Red'; Get-Content $Summary; return }
    $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q {3}:{4} `"{5}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$RemoteOutDir+'/*',$Reports)
  }
  Add-Content $Summary ("Pulled from {0}" -f $RemoteOutDir)

  # Build insights + top talkers
  $ExportFiles = Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -match '^(list_|rest_|stat_)' } | Sort-Object LastWriteTime -Descending
  $ByName=@{}; foreach($f in $ExportFiles){ $ByName[$f.BaseName]=$f.FullName }
  $W = ReadFlex ($ByName['list_wlanconf']); $N=ReadFlex ($ByName['rest_networkconf']); $FR=ReadFlex ($ByName['rest_firewallrule']); $CL=ReadFlex ($ByName['stat_sta'])

  $TopCSV = Join-Path $Reports "$Prefix.top_talkers.csv"
  try{
    $rows=@(); foreach($c in $CL){
      $name=TryProp $c @('hostname','host_name','name','displayName','display_name','device_name','fingerprint_name','mac')
      $mac =TryProp $c @('mac'); $ip=TryProp $c @('ip','ip_address','ipv4','primaryIp','primary_ip')
      $ssid=TryProp $c @('ssid','wlan','wifi_ssid','wlan_name'); $band=TryProp $c @('radio','band','phy')
      $tx=TryNum $c @('tx_bytes','txBytes','tx_total','tx_total_bytes'); $rx=TryNum $c @('rx_bytes','rxBytes','rx_total','rx_total_bytes')
      $rows += [pscustomobject]@{ name=($name ?? $mac); mac=$mac; ip=$ip; ssid=$ssid; band=$band; tx_bytes=$tx; rx_bytes=$rx; total_bytes=($tx+$rx) }
    }
    $rows | Sort-Object total_bytes -Descending | Select-Object -First 50 | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8
    Add-Content $Summary ("Top talkers -> {0}" -f $TopCSV)
  }catch{ Add-Content $Summary ("Top talkers error: {0}" -f $_.Exception.Message) }

  $Ins = Join-Path $Reports "config_insights_$Stamp.txt"
  try{
    "Config Insights - $(Get-Date)" | Set-Content -LiteralPath $Ins -Encoding UTF8
    if($W.Count -gt 0){
      Add-Content $Ins "WLANs:"
      foreach($w in $W){
        $nm=TryProp $w @('name','ssid'); if(-not $nm){ $nm='(unnamed)' }
        $sec=TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version'); $pmf=TryProp $w @('pmf_mode','pmf','ocpmf')
        $iso=TryProp $w @('ap_isolation','isolation','is_guest','guest')
        Add-Content $Ins ("  - {0} | security={1} | pmf={2} | isolation={3}" -f $nm,$sec,$pmf,$iso)
      }
      Add-Content $Ins ""
    }
    if($N.Count -gt 0){
      $v=0; foreach($n in $N){ if(TryProp $n @('vlan','vlan_id','vlanId')){$v++} }
      Add-Content $Ins ("Networks: {0} (VLAN-tagged: {1})" -f $N.Count,$v)
    }
    if($FR.Count -gt 0){
      $en=@($FR|?{ $_.PSObject.Properties['enabled'] -and $_.enabled -eq $true }).Count
      Add-Content $Ins ("Firewall rules: total={0}, enabled={1}" -f $FR.Count,$en)
    }
    Add-Content $Summary ("Config insights -> {0}" -f $Ins)
  }catch{ Add-Content $Summary ("Insights error: {0}" -f $_.Exception.Message) }

  # Zip bundle
  $Bundle = Join-Path $Reports "$Prefix.bundle.zip"
  try{
    $toZip = Get-ChildItem -LiteralPath $Reports -File | ?{ $_.Name -match '^(list_|rest_|stat_)' -or $_.Name -eq (Split-Path $TopCSV -Leaf) -or $_.Name -like "config_insights_*" }
    if($toZip){ Compress-Archive -Path ($toZip|Select -Expand FullName) -DestinationPath $Bundle -Force }
    Add-Content $Summary ("Bundle -> {0}" -f $Bundle)
  }catch{ Add-Content $Summary ("Bundle error: {0}" -f $_.Exception.Message) }

  Say ("SSH audit complete -> {0}" -f $Summary) 'Green'
  Get-Content -LiteralPath $Summary
}

At line:101 char:97
+ â€¦ =no" -o "UserKnownHostsFile=/dev/null" -q "$SSH_USER@$UDM_IP:$RemoteO â€¦
+                                                        ~~~~~~~~
Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.
ParserError: 
Line |
 101 |  â€¦ =no" -o "UserKnownHostsFile=/dev/null" -q "$SSH_USER@$UDM_IP:$RemoteO â€¦
     |                                                         ~~~~~~~~
     | Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.

PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
  function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
  function TryProp{param($o,[string[]]$names) foreach($n in $names){ if($o -and $o.PSObject.Properties[$n] -and $o.$n){ return $o.$n } } $null }
  function TryNum{param($o,[string[]]$names) foreach($n in $names){ if($o -and $o.PSObject.Properties[$n] -and $o.$n -ne $null){ try{ return [double]$o.$n }catch{} } } 0 }
  function ReadFlex($p){ if(-not(Test-Path $p)){return @()} ; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json; if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }

  Say "[START] UDM SSH audit (PS5.1 brace-fix)"

  # Paths
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $Root='D:\PlexTools'; $Reports=Join-Path $Root 'reports'; $Cache=Join-Path $Root 'cache'; $Bin=Join-Path $Root 'bin'
  Ensure-Dir $Vault; Ensure-Dir $Reports; Ensure-Dir $Cache; Ensure-Dir $Bin

  # UniFi local app creds (saved)
  $LOCAL_USER='udm_Local_api'; $LOCAL_PASS='W1ll0w1703!!'
  Set-Content (Join-Path $Vault 'udm_user.txt') $LOCAL_USER -Encoding ASCII
  Set-Content (Join-Path $Vault 'udm_pass.txt') $LOCAL_PASS -Encoding ASCII
  $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
  $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
  [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)

  # SSH creds (device OS)
  $SSH_USER = (ReadIf (Join-Path $Vault 'udm_ssh_user.txt')); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root'; Set-Content (Join-Path $Vault 'udm_ssh_user.txt') $SSH_USER -Encoding ASCII }
  $SSH_PASS = 'W1ll0w1703!!'; Set-Content (Join-Path $Vault 'udm_ssh_pass.txt') $SSH_PASS -Encoding ASCII

  # UDM IP
  $UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt')
  if([string]::IsNullOrWhiteSpace($UDM_IP)){
    $gw=(Get-NetIPConfiguration|?{ $_.IPv4DefaultGateway -and $_.IPv4Address }|Select-Object -First 1)
    if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII }
  }
  if(-not $UDM_IP){ throw "UDM IP not found. Put 192.168.1.1 in $Vault\udm_ip.txt" }

  $Stamp=Get-Date -Format 'yyyyMMdd_HHmmss'
  $Prefix="udm_ssh_audit_$Stamp"
  $Summary=Join-Path $Reports "$Prefix.summary.txt"
  "UDM SSH Auditor â€” $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

  # Prefer OpenSSH; fallback to PuTTY if missing
  $ssh = Get-Command ssh.exe -ErrorAction SilentlyContinue
  $scp = Get-Command scp.exe -ErrorAction SilentlyContinue
  if(-not $ssh -or -not $scp){
    $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
    $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
    if(-not $plink -or -not $pscp){
      Say "Downloading PuTTY (plink/pscp)..." 'Yellow'
      $PlinkPath = Join-Path $Bin 'plink.exe'; $PscpPath  = Join-Path $Bin 'pscp.exe'
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe' -OutFile $PlinkPath
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe'  -OutFile $PscpPath
      $plink = Get-Command $PlinkPath; $pscp = Get-Command $PscpPath
    }
  }

  # Remote shell script (PowerShell-safe quoting)
  $RemoteLines=@()
  $RemoteLines += '#!/bin/sh'
  $RemoteLines += 'set -e'
  $RemoteLines += 'TS=$(date +%Y%m%d_%H%M%S)'
  $RemoteLines += 'OUT="/tmp/plexaudit_$TS"'
  $RemoteLines += 'mkdir -p "$OUT"'
  $RemoteLines += 'echo "OUT=$OUT"'
  $RemoteLines += ("UUSER=""{0}""" -f $LOCAL_USER)
  $RemoteLines += ("UPASS=""{0}""" -f $LOCAL_PASS)
  $RemoteLines += 'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/api/auth/csrf" -o "$OUT/csrf.json" -w "%{http_code}" > "$OUT/csrf.code"'
  $RemoteLines += 'TOKEN=$(sed -n ''s/.*"token":"\([^"]*\)".*/\1/p'' "$OUT/csrf.json")'
  $RemoteLines += 'if [ -z "$TOKEN" ]; then TOKEN=$(awk ''/csrf_token/ {print $NF}'' "$OUT/cookie" | tail -n1); fi'
  $RemoteLines += 'LOGIN_CODE=$(curl -sk -L -o "$OUT/login.json" -w "%{http_code}" -c "$OUT/cookie" -b "$OUT/cookie" -H "Content-Type: application/json" -H "X-Csrf-Token: $TOKEN" --data "{\"username\":\"$UUSER\",\"password\":\"$UPASS\",\"rememberMe\":true}" "https://127.0.0.1/api/auth/login")'
  $RemoteLines += 'echo "$LOGIN_CODE" > "$OUT/login.code"'
  $RemoteLines += 'if [ "$LOGIN_CODE" != "200" ]; then echo "LOGIN_FAIL=$LOGIN_CODE" > "$OUT/status.txt"; echo "$OUT"; exit 0; fi'
  $RemoteLines += 'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/proxy/network/api/self/sites" -o "$OUT/self_sites.json"'
  $RemoteLines += 'SITE=$(sed -n ''s/.*"name":"\([^"]*\)".*/\1/p'' "$OUT/self_sites.json" | head -n1); [ -z "$SITE" ] && SITE="default"'
  $RemoteLines += 'echo "SITE=$SITE" > "$OUT/status.txt"'
  $RemoteLines += 'fetch(){ P="$1"; N="$2"; curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1${P}" -o "$OUT/${N}.json" -w "%{http_code}" > "$OUT/${N}.code"; }'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/list/setting"       "list_setting"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/networkconf"   "rest_networkconf"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/list/wlanconf"      "list_wlanconf"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/portconf"      "rest_portconf"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/firewallrule"  "rest_firewallrule"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/rest/firewallgroup" "rest_firewallgroup"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/device"        "stat_device"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/sta"           "stat_sta"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/health"        "stat_health"'
  $RemoteLines += 'fetch "/proxy/network/api/s/$SITE/stat/sysinfo"       "stat_sysinfo"'
  $RemoteLines += 'echo "DONE" >> "$OUT/status.txt"'
  $RemoteLines += 'echo "$OUT"'
  $TmpSh = Join-Path $Cache ("udm_remote_{0}.sh" -f $Stamp)
  Set-Content -LiteralPath $TmpSh -Value $RemoteLines -Encoding ASCII
  Say ("Remote script -> {0}" -f $TmpSh) 'DarkGray'

  # Run remote script and pull results
  Say "Connecting via SSH and running export on the UDM..." 'Yellow'
  $RemoteOutDir=$null
  if($ssh -and $scp){
    # Pipe content into ssh (PS5.1 has no '<' redirection)
    $RemoteRun = (Get-Content -LiteralPath $TmpSh -Raw) | & $ssh.Source -o "StrictHostKeyChecking=no" -o "UserKnownHostsFile=/dev/null" "$SSH_USER@$UDM_IP" '/bin/sh -s'
    $RemoteOutDir = ($RemoteRun | Select-Object -Last 1).Trim()
    if([string]::IsNullOrWhiteSpace($RemoteOutDir) -or -not ($RemoteOutDir -like "/tmp/plexaudit_*")){ Add-Content $Summary "Remote run failed (OpenSSH)."; Say "Remote run failed (OpenSSH)." 'Red'; Get-Content $Summary; return }
    # BUILD REMOTE SPEC FIRST (avoids $env:-style parsing)
    $RemoteSpec = ("{0}@{1}:{2}/*" -f $SSH_USER,$UDM_IP,$RemoteOutDir)
    & $scp.Source -o "StrictHostKeyChecking=no" -o "UserKnownHostsFile=/dev/null" -q $RemoteSpec $Reports
  } else {
    $plink = Get-Command (Join-Path $Bin 'plink.exe')
    $pscp  = Get-Command (Join-Path $Bin 'pscp.exe')
    $RemoteRun = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} -m `"{4}`"" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$TmpSh)
    $RemoteOutDir = ($RemoteRun | Select-Object -Last 1).Trim()
    if([string]::IsNullOrWhiteSpace($RemoteOutDir) -or -not ($RemoteOutDir -like "/tmp/plexaudit_*")){ Add-Content $Summary "Remote run failed (PuTTY)."; Say "Remote run failed (PuTTY)." 'Red'; Get-Content $Summary; return }
    $RemoteSpec2 = ("{0}@{1}:{2}/*" -f $SSH_USER,$UDM_IP,$RemoteOutDir)
    $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q {3} `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RemoteSpec2,$Reports)
  }
  Add-Content $Summary ("Pulled from {0}" -f $RemoteOutDir)

  # Build insights + top talkers
  $ExportFiles = Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -match '^(list_|rest_|stat_)' } | Sort-Object LastWriteTime -Descending
  $ByName=@{}; foreach($f in $ExportFiles){ $ByName[$f.BaseName]=$f.FullName }
  $W = ReadFlex ($ByName['list_wlanconf']); $N=ReadFlex ($ByName['rest_networkconf']); $FR=ReadFlex ($ByName['rest_firewallrule']); $CL=ReadFlex ($ByName['stat_sta'])

  $TopCSV = Join-Path $Reports "$Prefix.top_talkers.csv"
  try{
    $rows=@(); foreach($c in $CL){
      $name=TryProp $c @('hostname','host_name','name','displayName','display_name','device_name','fingerprint_name','mac')
      $mac =TryProp $c @('mac'); $ip=TryProp $c @('ip','ip_address','ipv4','primaryIp','primary_ip')
      $ssid=TryProp $c @('ssid','wlan','wifi_ssid','wlan_name'); $band=TryProp $c @('radio','band','phy')
      $tx=TryNum $c @('tx_bytes','txBytes','tx_total','tx_total_bytes'); $rx=TryNum $c @('rx_bytes','rxBytes','rx_total','rx_total_bytes')
      $rows += [pscustomobject]@{ name=($name ?? $mac); mac=$mac; ip=$ip; ssid=$ssid; band=$band; tx_bytes=$tx; rx_bytes=$rx; total_bytes=($tx+$rx) }
    }
    $rows | Sort-Object total_bytes -Descending | Select-Object -First 50 | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8
    Add-Content $Summary ("Top talkers -> {0}" -f $TopCSV)
  }catch{ Add-Content $Summary ("Top talkers error: {0}" -f $_.Exception.Message) }

  $Ins = Join-Path $Reports "config_insights_$Stamp.txt"
  try{
    "Config Insights - $(Get-Date)" | Set-Content -LiteralPath $Ins -Encoding UTF8
    if($W.Count -gt 0){
      Add-Content $Ins "WLANs:"
      foreach($w in $W){
        $nm=TryProp $w @('name','ssid'); if(-not $nm){ $nm='(unnamed)' }
        $sec=TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version'); $pmf=TryProp $w @('pmf_mode','pmf','ocpmf')
        $iso=TryProp $w @('ap_isolation','isolation','is_guest','guest')
        Add-Content $Ins ("  - {0} | security={1} | pmf={2} | isolation={3}" -f $nm,$sec,$pmf,$iso)
      }
      Add-Content $Ins ""
    }
    if($N.Count -gt 0){
      $v=0; foreach($n in $N){ if(TryProp $n @('vlan','vlan_id','vlanId')){$v++} }
      Add-Content $Ins ("Networks: {0} (VLAN-tagged: {1})" -f $N.Count,$v)
    }
    if($FR.Count -gt 0){
      $en=@($FR|?{ $_.PSObject.Properties['enabled'] -and $_.enabled -eq $true }).Count
      Add-Content $Ins ("Firewall rules: total={0}, enabled={1}" -f $FR.Count,$en)
    }
    Add-Content $Summary ("Config insights -> {0}" -f $Ins)
  }catch{ Add-Content $Summary ("Insights error: {0}" -f $_.Exception.Message) }

  # Zip bundle
  $Bundle = Join-Path $Reports "$Prefix.bundle.zip"
  try{
    $toZip = Get-ChildItem -LiteralPath $Reports -File | ?{ $_.Name -match '^(list_|rest_|stat_)' -or $_.Name -eq (Split-Path $TopCSV -Leaf) -or $_.Name -like "config_insights_*" }
    if($toZip){ Compress-Archive -Path ($toZip|Select -Expand FullName) -DestinationPath $Bundle -Force }
    Add-Content $Summary ("Bundle -> {0}" -f $Bundle)
  }catch{ Add-Content $Summary ("Bundle error: {0}" -f $_.Exception.Message) }

  Say ("SSH audit complete -> {0}" -f $Summary) 'Green'
  Get-Content -LiteralPath $Summary
}

[08:38:27] [START] UDM SSH audit (PS5.1 brace-fix)
[08:38:27] Remote script -> D:\PlexTools\cache\udm_remote_20251007_083827.sh
[08:38:27] Connecting via SSH and running export on the UDM...
PS C:\Windows\System32> TerminatingError(): "You cannot call a method on a null-valued expression."
>> TerminatingError(): "You cannot call a method on a null-valued expression."
You cannot call a method on a null-valued expression.
InvalidOperation: 
Line |
  99 |      $RemoteOutDir = ($RemoteRun | Select-Object -Last 1).Trim()
     |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | You cannot call a method on a null-valued expression.
PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
  function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }
  function TryProp{param($o,[string[]]$names) foreach($n in $names){ if($o -and $o.PSObject.Properties[$n] -and $o.$n){ return $o.$n } } $null }
  function TryNum{param($o,[string[]]$names) foreach($n in $names){ if($o -and $o.PSObject.Properties[$n] -and $o.$n -ne $null){ try{ return [double]$o.$n }catch{} } } 0 }
  function ReadFlex($p){ if(-not(Test-Path $p)){return @()} ; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json; if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }

  Say "[START] UDM SSH audit (PS5.1 + PuTTY + LF)"

  # Paths
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $Root='D:\PlexTools'
  $Reports=Join-Path $Root 'reports'; $Cache=Join-Path $Root 'cache'; $Bin=Join-Path $Root 'bin'
  Ensure-Dir $Vault; Ensure-Dir $Reports; Ensure-Dir $Cache; Ensure-Dir $Bin

  # Save UniFi local app creds (per your request)
  $LOCAL_USER='udm_Local_api'; $LOCAL_PASS='W1ll0w1703!!'
  Set-Content (Join-Path $Vault 'udm_user.txt') $LOCAL_USER -Encoding ASCII
  Set-Content (Join-Path $Vault 'udm_pass.txt') $LOCAL_PASS -Encoding ASCII
  $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
  $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
  [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)

  # SSH creds (device OS)
  $SSH_USER = (ReadIf (Join-Path $Vault 'udm_ssh_user.txt')); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root'; Set-Content (Join-Path $Vault 'udm_ssh_user.txt') $SSH_USER -Encoding ASCII }
  $SSH_PASS = 'W1ll0w1703!!'; Set-Content (Join-Path $Vault 'udm_ssh_pass.txt') $SSH_PASS -Encoding ASCII

  # UDM IP
  $UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt')
  if([string]::IsNullOrWhiteSpace($UDM_IP)){
    $gw=(Get-NetIPConfiguration|Where-Object{ $_.IPv4DefaultGateway -and $_.IPv4Address }|Select-Object -First 1)
    if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII }
  }
  if(-not $UDM_IP){ throw "UDM IP not found. Put 192.168.1.1 in $Vault\udm_ip.txt" }

  $Stamp=Get-Date -Format 'yyyyMMdd_HHmmss'
  $Prefix="udm_ssh_audit_$Stamp"
  $Summary=Join-Path $Reports "$Prefix.summary.txt"
  "UDM SSH Auditor â€” $(Get-Date)" | Set-Content -LiteralPath $Summary -Encoding UTF8

  # Ensure PuTTY tools (force PuTTY so we can pass -pw)
  $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
  $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
  if(-not $plink -or -not $pscp){
    Say "Downloading PuTTY (plink/pscp)..." 'Yellow'
    $PlinkPath = Join-Path $Bin 'plink.exe'; $PscpPath  = Join-Path $Bin 'pscp.exe'
    Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe' -OutFile $PlinkPath
    Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe'  -OutFile $PscpPath
    $plink = Get-Command $PlinkPath; $pscp = Get-Command $PscpPath
  }
  Say ("Using plink: {0}" -f $plink.Source) 'DarkGray'
  Say ("Using pscp : {0}" -f $pscp.Source)  'DarkGray'

  # --- Build remote shell script (LF endings, no 'set -e' to avoid ash quirks) ---
  $RemoteLines = @(
    '#!/bin/sh',
    'TS=$(date +%Y%m%d_%H%M%S)',
    'OUT="/tmp/plexaudit_$TS"',
    'mkdir -p "$OUT"',
    'echo "OUT=$OUT"',
    ("UUSER=""{0}""" -f $LOCAL_USER),
    ("UPASS=""{0}""" -f $LOCAL_PASS),
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/api/auth/csrf" -o "$OUT/csrf.json" -w "%{http_code}" > "$OUT/csrf.code"',
    'TOKEN=$(sed -n ''s/.*"token":"\([^"]*\)".*/\1/p'' "$OUT/csrf.json")',
    'if [ -z "$TOKEN" ]; then TOKEN=$(awk ''/csrf_token/ {print $NF}'' "$OUT/cookie" | tail -n1); fi',
    'LOGIN_CODE=$(curl -sk -L -o "$OUT/login.json" -w "%{http_code}" -c "$OUT/cookie" -b "$OUT/cookie" -H "Content-Type: application/json" -H "X-Csrf-Token: $TOKEN" --data "{\"username\":\"$UUSER\",\"password\":\"$UPASS\",\"rememberMe\":true}" "https://127.0.0.1/api/auth/login")',
    'echo "$LOGIN_CODE" > "$OUT/login.code"',
    'if [ "$LOGIN_CODE" != "200" ]; then echo "LOGIN_FAIL=$LOGIN_CODE" > "$OUT/status.txt"; echo "$OUT"; exit 0; fi',
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/proxy/network/api/self/sites" -o "$OUT/self_sites.json"',
    'SITE=$(sed -n ''s/.*"name":"\([^"]*\)".*/\1/p'' "$OUT/self_sites.json" | head -n1); [ -z "$SITE" ] && SITE="default"',
    'echo "SITE=$SITE" > "$OUT/status.txt"',
    'fetch(){ P="$1"; N="$2"; curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1${P}" -o "$OUT/${N}.json" -w "%{http_code}" > "$OUT/${N}.code"; }',
    'fetch "/proxy/network/api/s/$SITE/list/setting"       "list_setting"',
    'fetch "/proxy/network/api/s/$SITE/rest/networkconf"   "rest_networkconf"',
    'fetch "/proxy/network/api/s/$SITE/list/wlanconf"      "list_wlanconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/portconf"      "rest_portconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallrule"  "rest_firewallrule"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallgroup" "rest_firewallgroup"',
    'fetch "/proxy/network/api/s/$SITE/stat/device"        "stat_device"',
    'fetch "/proxy/network/api/s/$SITE/stat/sta"           "stat_sta"',
    'fetch "/proxy/network/api/s/$SITE/stat/health"        "stat_health"',
    'fetch "/proxy/network/api/s/$SITE/stat/sysinfo"       "stat_sysinfo"',
    'echo "DONE" >> "$OUT/status.txt"',
    'echo "$OUT"'
  )
  $TmpSh = Join-Path $Cache ("udm_remote_{0}.sh" -f $Stamp)
  # Write with UNIX LF endings explicitly
  $Unix = ($RemoteLines -join "`n")
  [System.IO.File]::WriteAllText($TmpSh, $Unix, [System.Text.Encoding]::ASCII)
  Say ("Remote script -> {0}" -f $TmpSh) 'DarkGray'

  # --- Run via plink and pull back via pscp (non-interactive, auto-accept host key) ---
  Say "Connecting via SSH and running export on the UDM..." 'Yellow'
  $RemoteRun = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} -m `"{4}`"" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$TmpSh)
  $RemoteOutDir = ($RemoteRun | Select-Object -Last 1).Trim()
  if([string]::IsNullOrWhiteSpace($RemoteOutDir) -or -not ($RemoteOutDir -like "/tmp/plexaudit_*")){
    Add-Content $Summary "Remote run did not return output dir. Check SSH creds or that SSH is enabled."
    Say "Remote script failed. Check SSH username/password or SSH enablement." 'Red'
    Get-Content -LiteralPath $Summary
    return
  }
  $RemoteSpec = ("{0}@{1}:{2}/*" -f $SSH_USER,$UDM_IP,$RemoteOutDir)
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q {3} `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RemoteSpec,$Reports)
  Add-Content $Summary ("Pulled from {0}" -f $RemoteOutDir)

  # --- Build insights + top talkers ---
  $ExportFiles = Get-ChildItem -LiteralPath $Reports -File | Where-Object { $_.Name -match '^(list_|rest_|stat_)' } | Sort-Object LastWriteTime -Descending
  $ByName=@{}; foreach($f in $ExportFiles){ $ByName[$f.BaseName]=$f.FullName }
  $W = ReadFlex ($ByName['list_wlanconf']); $N=ReadFlex ($ByName['rest_networkconf']); $FR=ReadFlex ($ByName['rest_firewallrule']); $CL=ReadFlex ($ByName['stat_sta'])

  $TopCSV = Join-Path $Reports "$Prefix.top_talkers.csv"
  try{
    $rows=@(); foreach($c in $CL){
      $name=TryProp $c @('hostname','host_name','name','displayName','display_name','device_name','fingerprint_name','mac')
      $mac =TryProp $c @('mac'); $ip=TryProp $c @('ip','ip_address','ipv4','primaryIp','primary_ip')
      $ssid=TryProp $c @('ssid','wlan','wifi_ssid','wlan_name'); $band=TryProp $c @('radio','band','phy')
      $tx=TryNum $c @('tx_bytes','txBytes','tx_total','tx_total_bytes'); $rx=TryNum $c @('rx_bytes','rxBytes','rx_total','rx_total_bytes')
      $rows += [pscustomobject]@{ name=($name ?? $mac); mac=$mac; ip=$ip; ssid=$ssid; band=$band; tx_bytes=$tx; rx_bytes=$rx; total_bytes=($tx+$rx) }
    }
    $rows | Sort-Object total_bytes -Descending | Select-Object -First 50 | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8
    Add-Content $Summary ("Top talkers -> {0}" -f $TopCSV)
  }catch{ Add-Content $Summary ("Top talkers error: {0}" -f $_.Exception.Message) }

  $Ins = Join-Path $Reports "config_insights_$Stamp.txt"
  try{
    "Config Insights - $(Get-Date)" | Set-Content -LiteralPath $Ins -Encoding UTF8
    if($W.Count -gt 0){
      Add-Content $Ins "WLANs:"
      foreach($w in $W){
        $nm=TryProp $w @('name','ssid'); if(-not $nm){ $nm='(unnamed)' }
        $sec=TryProp $w @('security','auth','auth_type','wpa_mode','wpa_version'); $pmf=TryProp $w @('pmf_mode','pmf','ocpmf')
        $iso=TryProp $w @('ap_isolation','isolation','is_guest','guest')
        Add-Content $Ins ("  - {0} | security={1} | pmf={2} | isolation={3}" -f $nm,$sec,$pmf,$iso)
      }
      Add-Content $Ins ""
    }
    if($N.Count -gt 0){
      $v=0; foreach($n in $N){ if(TryProp $n @('vlan','vlan_id','vlanId')){$v++} }
      Add-Content $Ins ("Networks: {0} (VLAN-tagged: {1})" -f $N.Count,$v)
    }
    if($FR.Count -gt 0){
      $en=@($FR|Where-Object{ $_.PSObject.Properties['enabled'] -and $_.enabled -eq $true }).Count
      Add-Content $Ins ("Firewall rules: total={0}, enabled={1}" -f $FR.Count,$en)
    }
    Add-Content $Summary ("Config insights -> {0}" -f $Ins)
  }catch{ Add-Content $Summary ("Insights error: {0}" -f $_.Exception.Message) }

  # --- Zip bundle ---
  $Bundle = Join-Path $Reports "$Prefix.bundle.zip"
  try{
    $toZip = Get-ChildItem -LiteralPath $Reports -File | Where-Object{ $_.Name -match '^(list_|rest_|stat_)' -or $_.Name -eq (Split-Path $TopCSV -Leaf) -or $_.Name -like "config_insights_*" }
    if($toZip){ Compress-Archive -Path ($toZip|Select -Expand FullName) -DestinationPath $Bundle -Force }
    Add-Content $Summary ("Bundle -> {0}" -f $Bundle)
  }catch{ Add-Content $Summary ("Bundle error: {0}" -f $_.Exception.Message) }

  Say ("SSH audit complete -> {0}" -f $Summary) 'Green'
  Get-Content -LiteralPath $Summary
}

[08:51:45] [START] UDM SSH audit (PS5.1 + PuTTY + LF)
[08:51:45] Using plink: C:\Program Files\PuTTY\plink.exe
[08:51:45] Using pscp : C:\Program Files\PuTTY\pscp.exe
[08:51:45] Remote script -> D:\PlexTools\cache\udm_remote_20251007_085145.sh
[08:51:45] Connecting via SSH and running export on the UDM...
PS C:\Windows\System32> TerminatingError(): "You cannot call a method on a null-valued expression."
>> TerminatingError(): "You cannot call a method on a null-valued expression."
You cannot call a method on a null-valued expression.
InvalidOperation: 
Line |
  97 |    $RemoteOutDir = ($RemoteRun | Select-Object -Last 1).Trim()
     |    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | You cannot call a method on a null-valued expression.
PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
  function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }

  Say "[START] UDM Collector + Mirror installer (PS5.1-safe)"

  # ===== PATHS / VAULT =====
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $Root='D:\PlexTools'
  $Reports=Join-Path $Root 'reports'
  $Cache=Join-Path $Root 'cache'
  $Bin=Join-Path $Root 'bin'
  $Scripts=Join-Path $Root 'Scripts'
  Ensure-Dir $Vault; Ensure-Dir $Reports; Ensure-Dir $Cache; Ensure-Dir $Bin; Ensure-Dir $Scripts

  # ===== CREDS (as agreed) =====
  $LOCAL_USER='udm_Local_api'
  $LOCAL_PASS='W1ll0w1703!!'
  Set-Content (Join-Path $Vault 'udm_user.txt') $LOCAL_USER -Encoding ASCII
  Set-Content (Join-Path $Vault 'udm_pass.txt') $LOCAL_PASS -Encoding ASCII
  $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
  $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
  [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)

  # SSH creds (device OS)
  $SSH_USER = ReadIf (Join-Path $Vault 'udm_ssh_user.txt'); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root'; Set-Content (Join-Path $Vault 'udm_ssh_user.txt') $SSH_USER -Encoding ASCII }
  $SSH_PASS = 'W1ll0w1703!!'; Set-Content (Join-Path $Vault 'udm_ssh_pass.txt') $SSH_PASS -Encoding ASCII

  # Gist tokens (optional)
  $GIST_ID  = ReadIf (Join-Path $Vault 'gist_id.txt')
  $GIST_TOK = ReadIf (Join-Path $Vault 'gist_token.txt')
  if(-not $GIST_TOK){
    $bin = Join-Path $Vault 'gist_token.bin'
    if(Test-Path $bin){
      try{
        $bytesG=[IO.File]::ReadAllBytes($bin)
        $dec=[Security.Cryptography.ProtectedData]::Unprotect($bytesG,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
        $GIST_TOK=[Text.Encoding]::UTF8.GetString($dec).Trim()
      }catch{}
    }
  }

  # ===== UDM IP =====
  $UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt')
  if([string]::IsNullOrWhiteSpace($UDM_IP)){
    $gw=(Get-NetIPConfiguration|Where-Object{ $_.IPv4DefaultGateway -and $_.IPv4Address }|Select-Object -First 1)
    if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII }
  }
  if(-not $UDM_IP){ throw "UDM IP not found. Put 192.168.1.1 in $Vault\udm_ip.txt" }

  # ===== Ensure PuTTY tools (we force PuTTY to avoid OpenSSH prompts) =====
  $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
  $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
  if(-not $plink -or -not $pscp){
    Say "Downloading PuTTY (plink/pscp)..." 'Yellow'
    $PlinkPath = Join-Path $Bin 'plink.exe'
    $PscpPath  = Join-Path $Bin 'pscp.exe'
    Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe' -OutFile $PlinkPath
    Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe'  -OutFile $PscpPath
    $plink = Get-Command $PlinkPath
    $pscp  = Get-Command $PscpPath
  }
  Say ("Using plink: {0}" -f $plink.Source) 'DarkGray'
  Say ("Using pscp : {0}" -f $pscp.Source)  'DarkGray'

  # ===== Build UDM on-box collector files (LF endings) =====
  $COL_DIR='/data/plexcollector'
  $BOOT_D='/data/on_boot.d'
  $INTERVAL_SEC='900'   # 15 minutes
  $RETENTION_D='30'     # keep 30 days on UDM

  # collector.sh â€” one run, writes bundle in /data/plexcollector/out/<TS>
  $CollectorLines=@(
    '#!/bin/sh',
    'TS=$(date +%Y%m%d_%H%M%S)',
    'BASE="/data/plexcollector"',
    'OUT="$BASE/out/$TS"',
    'mkdir -p "$OUT"',
    'echo "OUT=$OUT"',
    # login
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/api/auth/csrf" -o "$OUT/csrf.json" -w "%{http_code}" > "$OUT/csrf.code"',
    'TOKEN=$(sed -n ''s/.*"token":"\([^"]*\)".*/\1/p'' "$OUT/csrf.json")',
    'if [ -z "$TOKEN" ]; then TOKEN=$(awk ''/csrf_token/ {print $NF}'' "$OUT/cookie" | tail -n1); fi',
    ("UUSER='{0}'" -f $LOCAL_USER),
    ("UPASS='{0}'" -f $LOCAL_PASS),
    'LOGIN_CODE=$(curl -sk -L -o "$OUT/login.json" -w "%{http_code}" -c "$OUT/cookie" -b "$OUT/cookie" -H "Content-Type: application/json" -H "X-Csrf-Token: $TOKEN" --data "{\"username\":\"$UUSER\",\"password\":\"$UPASS\",\"rememberMe\":true}" "https://127.0.0.1/api/auth/login")',
    'echo "$LOGIN_CODE" > "$OUT/login.code"',
    'if [ "$LOGIN_CODE" != "200" ]; then echo "LOGIN_FAIL=$LOGIN_CODE" > "$OUT/status.txt"; echo "$OUT"; exit 0; fi',
    # site
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/proxy/network/api/self/sites" -o "$OUT/self_sites.json"',
    'SITE=$(sed -n ''s/.*"name":"\([^"]*\)".*/\1/p'' "$OUT/self_sites.json" | head -n1); [ -z "$SITE" ] && SITE="default"',
    'echo "SITE=$SITE" > "$OUT/status.txt"',
    # fetch helper
    'fetch(){ P="$1"; N="$2"; curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1${P}" -o "$OUT/${N}.json" -w "%{http_code}" > "$OUT/${N}.code"; }',
    # config and stats
    'fetch "/proxy/network/api/s/$SITE/list/setting"       "list_setting"',
    'fetch "/proxy/network/api/s/$SITE/rest/networkconf"   "rest_networkconf"',
    'fetch "/proxy/network/api/s/$SITE/list/wlanconf"      "list_wlanconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/portconf"      "rest_portconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallrule"  "rest_firewallrule"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallgroup" "rest_firewallgroup"',
    'fetch "/proxy/network/api/s/$SITE/stat/device"        "stat_device"',
    'fetch "/proxy/network/api/s/$SITE/stat/sta"           "stat_sta"',
    'fetch "/proxy/network/api/s/$SITE/stat/health"        "stat_health"',
    'fetch "/proxy/network/api/s/$SITE/stat/sysinfo"       "stat_sysinfo"',
    # host metrics (lightweight)
    'uname -a > "$OUT/host_uname.txt" 2>/dev/null',
    'cat /proc/loadavg > "$OUT/host_loadavg.txt" 2>/dev/null',
    'free -m > "$OUT/host_mem.txt" 2>/dev/null',
    'df -h > "$OUT/host_df.txt" 2>/dev/null',
    'ping -c 5 -W 2 1.1.1.1 > "$OUT/wan_ping_1.1.1.1.txt" 2>/dev/null || true',
    'ping -c 5 -W 2 8.8.8.8 > "$OUT/wan_ping_8.8.8.8.txt" 2>/dev/null || true',
    'echo "DONE" >> "$OUT/status.txt"',
    # retention
    ("find $BASE/out -maxdepth 1 -type d -mtime +{0} -exec rm -rf {{}} +" -f $RETENTION_D),
    'echo "$OUT"'
  )
  $CollectorSh = Join-Path $Cache 'collector.sh'
  [IO.File]::WriteAllText($CollectorSh, ($CollectorLines -join "`n"), [Text.Encoding]::ASCII)

  # run.sh â€” background loop + pid file
  $RunLines=@(
    '#!/bin/sh',
    'BASE="/data/plexcollector"',
    'PIDFILE="$BASE/collector.pid"',
    'INTERVAL_SEC='" + $INTERVAL_SEC + "'",
    'mkdir -p "$BASE/out"',
    'if [ -f "$PIDFILE" ]; then',
    '  OLD=$(cat "$PIDFILE" 2>/dev/null)',
    '  if [ -n "$OLD" ] && kill -0 "$OLD" 2>/dev/null; then',
    '    echo "collector already running (pid=$OLD)"; exit 0',
    '  fi',
    'fi',
    'echo $$ > "$PIDFILE"',
    'while true; do',
    '  /bin/sh "$BASE/collector.sh" >/dev/null 2>&1 || true',
    '  sleep "$INTERVAL_SEC"',
    'done'
  )
  $RunSh = Join-Path $Cache 'run.sh'
  [IO.File]::WriteAllText($RunSh, ($RunLines -join "`n"), [Text.Encoding]::ASCII)

  # on-boot hook
  $BootLines=@(
    '#!/bin/sh',
    'sleep 10',
    '/bin/sh /data/plexcollector/run.sh >/dev/null 2>&1 &'
  )
  $BootSh = Join-Path $Cache '99-plexcollector.sh'
  [IO.File]::WriteAllText($BootSh, ($BootLines -join "`n"), [Text.Encoding]::ASCII)

  Say "Pushing collector to UDMâ€¦" 'Yellow'
  $SpecDir = ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,$COL_DIR)
  $null = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} mkdir -p {4} {5}" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$COL_DIR,$BOOT_D)
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$CollectorSh,("$SpecDir/collector.sh"))
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RunSh,("$SpecDir/run.sh"))
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$BootSh,("{0}@{1}:{2}/99-plexcollector.sh" -f $SSH_USER,$UDM_IP,$BOOT_D))
  $null = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} chmod +x /data/plexcollector/*.sh {4}/99-plexcollector.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$BOOT_D)

  Say "Starting collector (background)..." 'Yellow'
  $null = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} /bin/sh /data/plexcollector/run.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP)

  # ===== Create Windows mirror+analyze script =====
  $MirrorScript = Join-Path $Scripts 'udm_mirror_analyze.ps1'
  $MS=@()
  $MS += '$ErrorActionPreference="Stop"; Set-StrictMode -Version Latest'
  $MS += 'function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }'
  $MS += '$Vault="C:\Users\jason\OneDrive\Public\TOKENS"; $Root="D:\PlexTools"; $Reports=Join-Path $Root "reports"; $Bin=Join-Path $Root "bin"'
  $MS += '$SSH_USER = ReadIf (Join-Path $Vault "udm_ssh_user.txt"); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER="root" }'
  $MS += '$SSH_PASS = ReadIf (Join-Path $Vault "udm_ssh_pass.txt"); if([string]::IsNullOrWhiteSpace($SSH_PASS)){ $SSH_PASS="W1ll0w1703!!" }'
  $MS += '$UDM_IP   = ReadIf (Join-Path $Vault "udm_ip.txt")'
  $MS += '$plink = Get-Command (Join-Path $Bin "plink.exe") -ErrorAction SilentlyContinue'
  $MS += '$pscp  = Get-Command (Join-Path $Bin "pscp.exe")  -ErrorAction SilentlyContinue'
  $MS += 'if(-not $plink -or -not $pscp){ throw "plink/pscp missing." }'
  $MS += 'if(-not (Test-Path $Reports)){ New-Item -ItemType Directory -Path $Reports -Force | Out-Null }'
  $MS += '$RemoteSpec = ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/out/*")'
  $MS += '$null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q -r {3} `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RemoteSpec,$Reports)'
  $MS += '$dirs = Get-ChildItem -LiteralPath $Reports -Directory | Where-Object { $_.Name -match "^\d{8}_\d{6}$" } | Sort-Object Name'
  $MS += 'if(-not $dirs){ Write-Host "[mirror] no bundles yet"; exit 0 }'
  $MS += '$latest = $dirs[-1].FullName'
  $MS += '$SumPath = Join-Path $Reports ("posture_"+$dirs[-1].Name+".txt")'
  $MS += '$WLAN = Join-Path $latest "list_wlanconf.json"; $NET = Join-Path $latest "rest_networkconf.json"; $FR=Join-Path $latest "rest_firewallrule.json"; $STA=Join-Path $latest "stat_sta.json"; $DEV=Join-Path $latest "stat_device.json"'
  $MS += 'function ReadFlex($p){ if(-not(Test-Path $p)){return @()} ; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json; if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }'
  $MS += '$w=@(); $n=@(); $fr=@(); $st=@(); $dv=@(); $w=ReadFlex $WLAN; $n=ReadFlex $NET; $fr=ReadFlex $FR; $st=ReadFlex $STA; $dv=ReadFlex $DEV'
  $MS += '"UDM Posture â€” "+(Get-Date) | Set-Content -LiteralPath $SumPath -Encoding UTF8'
  $MS += 'Add-Content $SumPath ("Latest bundle: "+$dirs[-1].Name)'
  $MS += 'Add-Content $SumPath ("WLANs: "+$w.Count+" | Networks: "+$n.Count+" | Firewall rules: "+$fr.Count+" | Clients: "+$st.Count+" | Devices: "+$dv.Count)'
  $MS += '$weak=0; foreach($c in $st){ $rssi=$null; if($c.PSObject.Properties["rssi"]){ try{$rssi=[int]$c.rssi}catch{} } if($rssi -lt -75){ $weak++ } }'
  $MS += 'Add-Content $SumPath ("Weak-RSSI clients (<-75 dBm): "+$weak)'
  $MS += '$aploads=@{}; foreach($c in $st){ $ap=$null; if($c.PSObject.Properties["ap_mac"]){ $ap=$c.ap_mac } elseif($c.PSObject.Properties["apMac"]){ $ap=$c.apMac } if($ap){ if(-not $aploads.ContainsKey($ap)){ $aploads[$ap]=0 }; $aploads[$ap]++ } }'
  $MS += '$over = @($aploads.GetEnumerator() | Where-Object { $_.Value -gt 25 })'
  $MS += 'Add-Content $SumPath ("Overloaded APs (>25 clients): "+$over.Count)'
  $MS += '$TopCSV = Join-Path $Reports ("top_talkers_"+$dirs[-1].Name+".csv")'
  $MS += '$rows=@(); foreach($c in $st){'
  $MS += '  $name=$null; foreach($k in @("hostname","host_name","name","displayName","display_name","device_name","fingerprint_name","mac")){ if($c.PSObject.Properties[$k] -and $c.$k){ $name=$c.$k; break } }'
  $MS += '  $mac=$null; if($c.PSObject.Properties["mac"]){ $mac=$c.mac }'
  $MS += '  $ip=$null; foreach($k in @("ip","ip_address","ipv4","primaryIp","primary_ip")){ if($c.PSObject.Properties[$k] -and $c.$k){ $ip=$c.$k; break } }'
  $MS += '  $ssid=$null; foreach($k in @("ssid","wlan","wifi_ssid","wlan_name")){ if($c.PSObject.Properties[$k] -and $c.$k){ $ssid=$c.$k; break } }'
  $MS += '  $band=$null; foreach($k in @("radio","band","phy")){ if($c.PSObject.Properties[$k] -and $c.$k){ $band=$c.$k; break } }'
  $MS += '  $tx=0; foreach($k in @("tx_bytes","txBytes","tx_total","tx_total_bytes")){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$tx=[double]$c.$k}catch{} } }'
  $MS += '  $rx=0; foreach($k in @("rx_bytes","rxBytes","rx_total","rx_total_bytes")){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$rx=[double]$c.$k}catch{} } }'
  $MS += '  if([string]::IsNullOrEmpty($name)){ $name=$mac }'
  $MS += '  $rows += [pscustomobject]@{ name=$name; mac=$mac; ip=$ip; ssid=$ssid; band=$band; tx_bytes=$tx; rx_bytes=$rx; total_bytes=($tx+$rx) }'
  $MS += '}'
  $MS += 'if($rows.Count -gt 0){ $rows | Sort-Object total_bytes -Descending | Select-Object -First 50 | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8; Add-Content $SumPath ("Top talkers -> "+$TopCSV) }'
  $MS += '# Local retention 90 days'
  $MS += '$cut=(Get-Date).AddDays(-90); Get-ChildItem -LiteralPath $Reports -Directory | Where-Object { $_.Name -match "^\d{8}_\d{6}$" -and $_.LastWriteTime -lt $cut } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue'
  $MS += '# Optional Gist attach'
  $MS += '$GID = ReadIf (Join-Path $Vault "gist_id.txt"); $GTK = ReadIf (Join-Path $Vault "gist_token.txt")'
  $MS += 'if(-not $GTK){ $bin=Join-Path $Vault "gist_token.bin"; if(Test-Path $bin){ try{ $bytes=[IO.File]::ReadAllBytes($bin); $dec=[Security.Cryptography.ProtectedData]::Unprotect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser); $GTK=[Text.Encoding]::UTF8.GetString($dec).Trim() }catch{} } }'
  $MS += 'if($GID -and $GTK){'
  $MS += '  try{'
  $MS += '    $files=@{}'
  $MS += '    $files[(Split-Path $SumPath -Leaf)] = @{ content = (Get-Content -LiteralPath $SumPath -Raw) }'
  $MS += '    if(Test-Path $TopCSV){ $files[(Split-Path $TopCSV -Leaf)] = @{ content = (Get-Content -LiteralPath $TopCSV -Raw) } }'
  $MS += '    $payload = @{ files = $files } | ConvertTo-Json -Depth 6'
  $MS += '    $hdr = @{ Authorization=("token "+$GTK); "User-Agent"="UDM-Collector" }'
  $MS += '    $uri = "https://api.github.com/gists/"+$GID'
  $MS += '    Invoke-WebRequest -UseBasicParsing -Uri $uri -Method Patch -Headers $hdr -Body $payload -ContentType "application/json" | Out-Null'
  $MS += '  }catch{}'
  $MS += '}'
  $MS += 'Write-Host ("[mirror] Done: "+$SumPath)'
  [IO.File]::WriteAllText($MirrorScript, ($MS -join "`n"), [Text.Encoding]::UTF8)
  Say ("Mirror+Analyze script -> {0}" -f $MirrorScript) 'DarkGray'

  # ===== Create/Update Scheduled Task (every 15 min) =====
  $TaskName='UDM_Mirror_Analyze_15min'
  $ps = "powershell.exe -NoProfile -ExecutionPolicy Bypass -File `"$MirrorScript`""
  try{
    schtasks /Create /TN "$TaskName" /SC MINUTE /MO 15 /TR "$ps" /F /RL LIMITED /IT | Out-Null
    Say ("Scheduled Task -> {0} (every 15 min)" -f $TaskName) 'Green'
  }catch{
    Say ("Could not create scheduled task: {0}" -f $_.Exception.Message) 'Red'
  }

  # ===== Kick a mirror+analyze run now =====
  try{
    & powershell -NoProfile -ExecutionPolicy Bypass -File $MirrorScript
  }catch{
    Say ("First mirror run failed: {0}" -f $_.Exception.Message) 'Yellow'
  }

  Say "[DONE] Collector installed, mirror scheduled. Expect a new posture file in D:\PlexTools\reports within ~15 min." 'Green'
}

At line:128 char:20
+     'INTERVAL_SEC='" + $INTERVAL_SEC + "'",
+                    ~~~~~~~~~~~~~~~~~~~~~
Unexpected token '" + $INTERVAL_SEC + "' in expression or statement.

At line:128 char:41
+     'INTERVAL_SEC='" + $INTERVAL_SEC + "'",
+                                         ~~~
Unexpected token ''",
    '' in expression or statement.

At line:129 char:6
+     'mkdir -p "$BASE/out"',
+      ~~~~~
Unexpected token 'mkdir' in expression or statement.

At line:151 char:31
+   $BootSh = Join-Path $Cache '99-plexcollector.sh'
+                               ~~~~~~~~~~~~~~~~~~~~
Unexpected token '99-plexcollector.sh'
  [IO.File]::WriteAllText($BootSh, ($BootLines -join "`n"), [Text.Encoding]::ASCII)

  Say "Pushing collector to UDMâ€¦" 'Yellow'
  $SpecDir = ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,$COL_DIR)
  $null = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} mkdir -p {4} {5}" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$COL_DIR,$BOOT_D)
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$CollectorSh,("$SpecDir/collector.sh"))
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RunSh,("$SpecDir/run.sh"))
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$BootSh,("{0}@{1}:{2}/99-plexcollector.sh" -f $SSH_USER,$UDM_IP,$BOOT_D))
  $null = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} chmod +x /data/plexcollector/*.sh {4}/99-plexcollector.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$BOOT_D)

  Say "Starting collector (background)..." 'Yellow'
  $null = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} /bin/sh /data/plexcollector/run.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP)

  # ===== Create Windows mirror+analyze script =====
  $MirrorScript = Join-Path $Scripts 'udm_mirror_analyze.ps1'
  $MS=@()
  $MS += '$ErrorActionPreference="Stop"' in expression or statement.

At line:151 char:33
+   $BootSh = Join-Path $Cache '99-plexcollector.sh'
+                                 ~~~~~~~~~~~~~~
Unexpected token '-plexcollector' in expression or statement.

At line:151 char:47
+   $BootSh = Join-Path $Cache '99-plexcollector.sh'
+                                               ~~~~
Unexpected token '.sh'
  [IO.File]::WriteAllText($BootSh, ($BootLines -join "`n"), [Text.Encoding]::ASCII)

  Say "Pushing collector to UDMâ€¦" 'Yellow'
  $SpecDir = ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,$COL_DIR)
  $null = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} mkdir -p {4} {5}" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$COL_DIR,$BOOT_D)
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$CollectorSh,("$SpecDir/collector.sh"))
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RunSh,("$SpecDir/run.sh"))
  $null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$BootSh,("{0}@{1}:{2}/99-plexcollector.sh" -f $SSH_USER,$UDM_IP,$BOOT_D))
  $null = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} chmod +x /data/plexcollector/*.sh {4}/99-plexcollector.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP,$BOOT_D)

  Say "Starting collector (background)..." 'Yellow'
  $null = & cmd /c ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} /bin/sh /data/plexcollector/run.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP)

  # ===== Create Windows mirror+analyze script =====
  $MirrorScript = Join-Path $Scripts 'udm_mirror_analyze.ps1'
  $MS=@()
  $MS += '$ErrorActionPreference="Stop"' in expression or statement.

At line:172 char:11
+   $MS += '$SSH_PASS = ReadIf (Join-Path $Vault "udm_ssh_pass.txt"); i â€¦
+           ~~~~~~~~~
Unexpected token '$SSH_PASS' in expression or statement.

At line:173 char:11
+   $MS += '$UDM_IP   = ReadIf (Join-Path $Vault "udm_ip.txt")'
+           ~~~~~~~
Unexpected token '$UDM_IP' in expression or statement.

At line:186 char:16
+   $MS += '$w=@(); $n=@(); $fr=@(); $st=@(); $dv=@(); $w=ReadFlex $WLA â€¦
+                ~
An expression was expected after '('.

At line:191 char:11
+   $MS += 'Add-Content $SumPath ("Weak-RSSI clients (<-75 dBm): "+$wea â€¦
+           ~~~~~~~~~~~
Unexpected token 'Add-Content' in expression or statement.

Not all parse errors were reported.  Correct the reported errors and try again.
ParserError: 
Line |
 128 |      'INTERVAL_SEC='" + $INTERVAL_SEC + "'",
     |                     ~~~~~~~~~~~~~~~~~~~~~
     | Unexpected token '" + $INTERVAL_SEC + "' in expression or statement.

PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest

  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ try{ New-Item -ItemType Directory -Path $p -Force | Out-Null }catch{} } }
  function ReadIf($p){ if(Test-Path $p){ try{ (Get-Content -LiteralPath $p -Raw).Trim() }catch{ $null } } else { $null } }

  # ---------- QA logging ----------
  $Root='D:\PlexTools'
  $Reports=Join-Path $Root 'reports'
  Ensure-Dir $Reports
  $Stamp=Get-Date -Format 'yyyyMMdd_HHmmss'
  $QA=Join-Path $Reports ("udm_collector_install_QA_{0}.txt" -f $Stamp)
  function QA($msg){ Add-Content -LiteralPath $QA -Value ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'), $msg) }
  function Run-Cmd($label,$cmd){
    try{
      $global:LASTEXITCODE = 0
      $out = & cmd /c $cmd
      $code = $LASTEXITCODE
      if($code -ne 0){ QA "$label -> FAIL (exit $code)"; return @{ ok=$false; out=$out } }
      QA "$label -> OK"
      return @{ ok=$true; out=$out }
    }catch{
      QA "$label -> EXCEPTION: $($_.Exception.Message)"
      return @{ ok=$false; out=$null }
    }
  }

  Say "[START] UDM Collector + Mirror installer (PS5.1-safe, continue-on-error)"
  QA  "CONTINUE MODE enabled: steps will log and proceed when safe"

  # ---------- Paths & vault ----------
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $Cache=Join-Path $Root 'cache'
  $Bin=Join-Path $Root 'bin'
  $Scripts=Join-Path $Root 'Scripts'
  Ensure-Dir $Vault; Ensure-Dir $Cache; Ensure-Dir $Bin; Ensure-Dir $Scripts

  # ---------- Creds (as agreed) ----------
  try{
    $LOCAL_USER='udm_Local_api'; $LOCAL_PASS='W1ll0w1703!!'
    Set-Content (Join-Path $Vault 'udm_user.txt') $LOCAL_USER -Encoding ASCII
    Set-Content (Join-Path $Vault 'udm_pass.txt') $LOCAL_PASS -Encoding ASCII
    $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
    $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
    [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)
    QA "Saved UniFi app creds -> udm_user.txt / udm_pass(.txt/.bin)"
  }catch{ QA "Save creds -> EXCEPTION: $($_.Exception.Message)" }

  # SSH creds (device OS)
  try{
    $SSH_USER = ReadIf (Join-Path $Vault 'udm_ssh_user.txt'); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root'; Set-Content (Join-Path $Vault 'udm_ssh_user.txt') $SSH_USER -Encoding ASCII }
    $SSH_PASS = 'W1ll0w1703!!'; Set-Content (Join-Path $Vault 'udm_ssh_pass.txt') $SSH_PASS -Encoding ASCII
    QA "Saved SSH creds -> udm_ssh_user.txt / udm_ssh_pass.txt"
  }catch{ QA "Save SSH creds -> EXCEPTION: $($_.Exception.Message)" }

  # ---------- UDM IP ----------
  try{
    $UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt')
    if([string]::IsNullOrWhiteSpace($UDM_IP)){
      $gw=(Get-NetIPConfiguration|Where-Object{ $_.IPv4DefaultGateway -and $_.IPv4Address }|Select-Object -First 1)
      if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII; QA "Auto-detected UDM IP -> $UDM_IP" }
    } else { QA "UDM IP from vault -> $UDM_IP" }
    if(-not $UDM_IP){ QA "UDM IP missing. Put 192.168.1.1 in $Vault\udm_ip.txt"; Say "UDM IP missing; continuing but remote steps will likely fail" 'Yellow' }
  }catch{ QA "UDM IP detect -> EXCEPTION: $($_.Exception.Message)" }

  # ---------- Ensure PuTTY tools ----------
  $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
  $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
  if(-not $plink -or -not $pscp){
    Say "Downloading PuTTY (plink/pscp)..." 'Yellow'; QA "PuTTY download starting"
    $PlinkPath = Join-Path $Bin 'plink.exe'
    $PscpPath  = Join-Path $Bin 'pscp.exe'
    try{
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe' -OutFile $PlinkPath
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe'  -OutFile $PscpPath
      $plink = Get-Command $PlinkPath -ErrorAction SilentlyContinue
      $pscp  = Get-Command $PscpPath  -ErrorAction SilentlyContinue
      QA "PuTTY download -> OK"
    }catch{ QA "PuTTY download -> EXCEPTION: $($_.Exception.Message)" }
  } else { QA ("PuTTY present -> plink={0} pscp={1}" -f $plink.Source,$pscp.Source) }
  if($plink){ Say ("Using plink: {0}" -f $plink.Source) 'DarkGray' }
  if($pscp){  Say ("Using pscp : {0}" -f $pscp.Source)  'DarkGray' }

  # ---------- Quick SSH reachability probe (non-fatal) ----------
  if($plink -and $UDM_IP){
    $probe = Run-Cmd "SSH probe (banner)" ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} echo ok" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP)
    if(-not $probe.ok){ Say "SSH probe failed (will still continue)" 'Yellow' }
  } else { QA "SSH probe skipped (plink or UDM_IP missing)" }

  # ---------- Build UDM on-box collector files (LF endings) ----------
  $COL_DIR='/data/plexcollector'
  $BOOT_D='/data/on_boot.d'
  $INTERVAL_SEC='900'   # 15 min
  $RETENTION_D='30'     # keep 30 days on UDM

  $CollectorLines=@(
    '#!/bin/sh',
    'TS=$(date +%Y%m%d_%H%M%S)',
    'BASE="/data/plexcollector"',
    'OUT="$BASE/out/$TS"',
    'mkdir -p "$OUT"',
    'echo "OUT=$OUT"',
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/api/auth/csrf" -o "$OUT/csrf.json" -w "%{http_code}" > "$OUT/csrf.code"',
    'TOKEN=$(sed -n ''s/.*"token":"\([^"]*\)".*/\1/p'' "$OUT/csrf.json")',
    'if [ -z "$TOKEN" ]; then TOKEN=$(awk ''/csrf_token/ {print $NF}'' "$OUT/cookie" | tail -n1); fi',
    ("UUSER='{0}'" -f $LOCAL_USER),
    ("UPASS='{0}'" -f $LOCAL_PASS),
    'LOGIN_CODE=$(curl -sk -L -o "$OUT/login.json" -w "%{http_code}" -c "$OUT/cookie" -b "$OUT/cookie" -H "Content-Type: application/json" -H "X-Csrf-Token: $TOKEN" --data "{\"username\":\"$UUSER\",\"password\":\"$UPASS\",\"rememberMe\":true}" "https://127.0.0.1/api/auth/login")',
    'echo "$LOGIN_CODE" > "$OUT/login.code"',
    'if [ "$LOGIN_CODE" != "200" ]; then echo "LOGIN_FAIL=$LOGIN_CODE" > "$OUT/status.txt"; echo "$OUT"; exit 0; fi',
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/proxy/network/api/self/sites" -o "$OUT/self_sites.json"',
    'SITE=$(sed -n ''s/.*"name":"\([^"]*\)".*/\1/p'' "$OUT/self_sites.json" | head -n1); [ -z "$SITE" ] && SITE="default"',
    'echo "SITE=$SITE" > "$OUT/status.txt"',
    'fetch(){ P="$1"; N="$2"; curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1${P}" -o "$OUT/${N}.json" -w "%{http_code}" > "$OUT/${N}.code"; }',
    'fetch "/proxy/network/api/s/$SITE/list/setting"       "list_setting"',
    'fetch "/proxy/network/api/s/$SITE/rest/networkconf"   "rest_networkconf"',
    'fetch "/proxy/network/api/s/$SITE/list/wlanconf"      "list_wlanconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/portconf"      "rest_portconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallrule"  "rest_firewallrule"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallgroup" "rest_firewallgroup"',
    'fetch "/proxy/network/api/s/$SITE/stat/device"        "stat_device"',
    'fetch "/proxy/network/api/s/$SITE/stat/sta"           "stat_sta"',
    'fetch "/proxy/network/api/s/$SITE/stat/health"        "stat_health"',
    'fetch "/proxy/network/api/s/$SITE/stat/sysinfo"       "stat_sysinfo"',
    'uname -a > "$OUT/host_uname.txt" 2>/dev/null',
    'cat /proc/loadavg > "$OUT/host_loadavg.txt" 2>/dev/null',
    'free -m > "$OUT/host_mem.txt" 2>/dev/null',
    'df -h > "$OUT/host_df.txt" 2>/dev/null',
    'ping -c 5 -W 2 1.1.1.1 > "$OUT/wan_ping_1.1.1.1.txt" 2>/dev/null || true',
    'ping -c 5 -W 2 8.8.8.8 > "$OUT/wan_ping_8.8.8.8.txt" 2>/dev/null || true',
    'echo "DONE" >> "$OUT/status.txt"',
    ("find $BASE/out -maxdepth 1 -type d -mtime +{0} -exec rm -rf {{}} +" -f $RETENTION_D),
    'echo "$OUT"'
  )
  $CollectorSh = Join-Path $Cache 'collector.sh'
  [IO.File]::WriteAllText($CollectorSh, ($CollectorLines -join "`n"), [Text.Encoding]::ASCII)

  $RunLines=@(
    '#!/bin/sh',
    'BASE="/data/plexcollector"',
    'PIDFILE="$BASE/collector.pid"',
    'INTERVAL_SEC='" + '900' + "'",
    'mkdir -p "$BASE/out"',
    'if [ -f "$PIDFILE" ]; then',
    '  OLD=$(cat "$PIDFILE" 2>/dev/null)',
    '  if [ -n "$OLD" ] && kill -0 "$OLD" 2>/dev/null; then',
    '    echo "collector already running (pid=$OLD)"; exit 0',
    '  fi',
    'fi',
    'echo $$ > "$PIDFILE"',
    'while true; do',
    '  /bin/sh "$BASE/collector.sh" >/dev/null 2>&1 || true',
    '  sleep "$INTERVAL_SEC"',
    'done'
  )
  $RunSh = Join-Path $Cache 'run.sh'
  [IO.File]::WriteAllText($RunSh, ($RunLines -join "`n"), [Text.Encoding]::ASCII)

  $BootLines=@(
    '#!/bin/sh',
    'sleep 10',
    '/bin/sh /data/plexcollector/run.sh >/dev/null 2>&1 &'
  )
  $BootSh = Join-Path $Cache '99-plexcollector.sh'
  [IO.File]::WriteAllText($BootSh, ($BootLines -join "`n"), [Text.Encoding]::ASCII)

  # ---------- Push files to UDM (non-fatal per step) ----------
  if($plink -and $pscp -and $UDM_IP){
    [void](Run-Cmd "mkdir /data paths" ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} mkdir -p /data/plexcollector /data/on_boot.d" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
    [void](Run-Cmd "push collector.sh" ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$CollectorSh,("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/collector.sh")))
    [void](Run-Cmd "push run.sh"       ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RunSh,      ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/run.sh")))
    [void](Run-Cmd "push boot hook"    ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$BootSh,     ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/on_boot.d/99-plexcollector.sh")))
    [void](Run-Cmd "chmod scripts"     ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} chmod +x /data/plexcollector/*.sh /data/on_boot.d/99-plexcollector.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
    [void](Run-Cmd "start collector"   ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} /bin/sh /data/plexcollector/run.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
  } else {
    QA "File push skipped (plink/pscp/UDM_IP missing)"
    Say "Could not push files (plink/pscp/UDM_IP missing). Mirror will still be installed." 'Yellow'
  }

  # ---------- Build Windows mirror+analyze (more robust) ----------
  $MirrorScript = Join-Path $Scripts 'udm_mirror_analyze.ps1'
  $MS=@()
  $MS += '$ErrorActionPreference="Stop"; Set-StrictMode -Version Latest'
  $MS += 'function ReadIf($p){ if(Test-Path $p){ try{ (Get-Content -LiteralPath $p -Raw).Trim() }catch{ $null } } else { $null } }'
  $MS += '$Vault="C:\Users\jason\OneDrive\Public\TOKENS"; $Root="D:\PlexTools"; $Reports=Join-Path $Root "reports"; $Bin=Join-Path $Root "bin"'
  $MS += 'if(-not (Test-Path $Reports)){ New-Item -ItemType Directory -Path $Reports -Force | Out-Null }'
  $MS += '$Stamp=Get-Date -Format "yyyyMMdd_HHmmss"; $Log=Join-Path $Reports ("mirror_QA_"+$Stamp+".txt")'
  $MS += 'function QA($m){ Add-Content -LiteralPath $Log -Value ("[{0}] {1}" -f (Get-Date -Format "HH:mm:ss"),$m) }'
  $MS += 'QA "Mirror start"'
  $MS += '$SSH_USER = ReadIf (Join-Path $Vault "udm_ssh_user.txt"); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER="root" }'
  $MS += '$SSH_PASS = ReadIf (Join-Path $Vault "udm_ssh_pass.txt"); if([string]::IsNullOrWhiteSpace($SSH_PASS)){ $SSH_PASS="W1ll0w1703!!" }'
  $MS += '$UDM_IP   = ReadIf (Join-Path $Vault "udm_ip.txt")'
  $MS += '$plink = Get-Command (Join-Path $Bin "plink.exe") -ErrorAction SilentlyContinue'
  $MS += '$pscp  = Get-Command (Join-Path $Bin "pscp.exe")  -ErrorAction SilentlyContinue'
  $MS += 'if(-not $plink -or -not $pscp){ QA "PuTTY missing"; Write-Host "[mirror] PuTTY missing"; exit 0 }'
  $MS += 'if([string]::IsNullOrWhiteSpace($UDM_IP)){ QA "UDM_IP missing"; Write-Host "[mirror] UDM_IP missing"; exit 0 }'
  $MS += '$RemoteSpec = ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/out/*")'
  $MS += '$global:LASTEXITCODE=0'
  $MS += '$null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q -r {3} `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RemoteSpec,$Reports)'
  $MS += '$code = $LASTEXITCODE; if($code -ne 0){ QA ("pscp pull -> FAIL ("+$code+")"); Write-Host "[mirror] pscp pull failed"; exit 0 } else { QA "pscp pull -> OK" }'
  $MS += '$dirs = Get-ChildItem -LiteralPath $Reports -Directory | Where-Object { $_.Name -match "^\d{8}_\d{6}$" } | Sort-Object Name'
  $MS += 'if(-not $dirs){ QA "no bundles yet"; Write-Host "[mirror] no bundles yet"; exit 0 }'
  $MS += '$latest = $dirs[-1].FullName'
  $MS += '$SumPath = Join-Path $Reports ("posture_"+$dirs[-1].Name+".txt")'
  $MS += 'function ReadFlex($p){ if(-not(Test-Path $p)){return @()} ; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json; if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }'
  $MS += '$WLAN = Join-Path $latest "list_wlanconf.json"; $NET = Join-Path $latest "rest_networkconf.json"; $FR=Join-Path $latest "rest_firewallrule.json"; $STA=Join-Path $latest "stat_sta.json"; $DEV=Join-Path $latest "stat_device.json"'
  $MS += '$w=ReadFlex $WLAN; $n=ReadFlex $NET; $fr=ReadFlex $FR; $st=ReadFlex $STA; $dv=ReadFlex $DEV'
  $MS += '"UDM Posture â€” "+(Get-Date) | Set-Content -LiteralPath $SumPath -Encoding UTF8'
  $MS += 'Add-Content $SumPath ("Latest bundle: "+(Split-Path $latest -Leaf))'
  $MS += 'Add-Content $SumPath ("WLANs: "+$w.Count+" | Networks: "+$n.Count+" | Firewall rules: "+$fr.Count+" | Clients: "+$st.Count+" | Devices: "+$dv.Count)'
  $MS += '$weak=0; foreach($c in $st){ if($c.PSObject.Properties["rssi"]){ try{ if([int]$c.rssi -lt -75){ $weak++ } }catch{} } }'
  $MS += 'Add-Content $SumPath ("Weak-RSSI clients (<-75 dBm): "+$weak)'
  $MS += '$aploads=@{}; foreach($c in $st){ $ap=$null; if($c.PSObject.Properties["ap_mac"]){ $ap=$c.ap_mac } elseif($c.PSObject.Properties["apMac"]){ $ap=$c.apMac } if($ap){ if(-not $aploads.ContainsKey($ap)){ $aploads[$ap]=0 }; $aploads[$ap]++ } }'
  $MS += '$over = @($aploads.GetEnumerator() | Where-Object { $_.Value -gt 25 })'
  $MS += 'Add-Content $SumPath ("Overloaded APs (>25 clients): "+$over.Count)'
  $MS += '$TopCSV = Join-Path $Reports ("top_talkers_"+(Split-Path $latest -Leaf)+".csv")'
  $MS += '$rows=@(); foreach($c in $st){'
  $MS += '  $name=$null; foreach($k in @("hostname","host_name","name","displayName","display_name","device_name","fingerprint_name","mac")){ if($c.PSObject.Properties[$k] -and $c.$k){ $name=$c.$k; break } }'
  $MS += '  if([string]::IsNullOrEmpty($name) -and $c.PSObject.Properties["mac"]){ $name=$c.mac }'
  $MS += '  $mac=$null; if($c.PSObject.Properties["mac"]){ $mac=$c.mac }'
  $MS += '  $ip=$null; foreach($k in @("ip","ip_address","ipv4","primaryIp","primary_ip")){ if($c.PSObject.Properties[$k] -and $c.$k){ $ip=$c.$k; break } }'
  $MS += '  $ssid=$null; foreach($k in @("ssid","wlan","wifi_ssid","wlan_name")){ if($c.PSObject.Properties[$k] -and $c.$k){ $ssid=$c.$k; break } }'
  $MS += '  $band=$null; foreach($k in @("radio","band","phy")){ if($c.PSObject.Properties[$k] -and $c.$k){ $band=$c.$k; break } }'
  $MS += '  $tx=0; foreach($k in @("tx_bytes","txBytes","tx_total","tx_total_bytes")){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$tx=[double]$c.$k}catch{} } }'
  $MS += '  $rx=0; foreach($k in @("rx_bytes","rxBytes","rx_total","rx_total_bytes")){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$rx=[double]$c.$k}catch{} } }'
  $MS += '  $rows += [pscustomobject]@{ name=$name; mac=$mac; ip=$ip; ssid=$ssid; band=$band; tx_bytes=$tx; rx_bytes=$rx; total_bytes=($tx+$rx) }'
  $MS += '}'
  $MS += 'if($rows.Count -gt 0){ try{ $rows | Sort-Object total_bytes -Descending | Select-Object -First 50 | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8; Add-Content $SumPath ("Top talkers -> "+$TopCSV) }catch{ QA ("Top talkers CSV -> EXCEPTION: "+$_.Exception.Message) } }'
  $MS += '# Retention 90d'
  $MS += 'try{ $cut=(Get-Date).AddDays(-90); Get-ChildItem -LiteralPath $Reports -Directory | Where-Object { $_.Name -match "^\d{8}_\d{6}$" -and $_.LastWriteTime -lt $cut } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }catch{ QA "Retention cleanup -> EXCEPTION: $($_.Exception.Message)" }'
  $MS += 'Write-Host ("[mirror] Done: "+$SumPath)'
  [IO.File]::WriteAllText($MirrorScript, ($MS -join "`n"), [Text.Encoding]::UTF8)
  QA "Mirror+Analyze script written -> $MirrorScript"
  Say ("Mirror+Analyze script -> {0}" -f $MirrorScript) 'DarkGray'

  # ---------- Scheduled Task (non-fatal) ----------
  $TaskName='UDM_Mirror_Analyze_15min'
  $ps = "powershell.exe -NoProfile -ExecutionPolicy Bypass -File `"$MirrorScript`""
  try{
    schtasks /Create /TN "$TaskName" /SC MINUTE /MO 15 /TR "$ps" /F /RL LIMITED /IT | Out-Null
    QA "Scheduled Task created/updated -> $TaskName"
    Say ("Scheduled Task -> {0} (every 15 min)" -f $TaskName) 'Green'
  }catch{
    QA ("Scheduled Task -> EXCEPTION: {0}" -f $_.Exception.Message)
    Say "Could not create scheduled task (continuing). See QA log." 'Yellow'
  }

  # ---------- First mirror run (non-fatal) ----------
  try{
    & powershell -NoProfile -ExecutionPolicy Bypass -File $MirrorScript
    QA "Manual mirror run -> attempted"
  }catch{
    QA ("Manual mirror run -> EXCEPTION: {0}" -f $_.Exception.Message)
    Say "First mirror run failed (continuing). Task will retry." 'Yellow'
  }

  Say ("[DONE] Install flow finished. QA log -> {0}" -f $QA) 'Green'
  Write-Host "Open the QA log for exact step statuses."
}

At line:143 char:20
+     'INTERVAL_SEC='" + '900' + "'",
+                    ~~~~~~~~~~~~~
Unexpected token '" + '900' + "' in expression or statement.

At line:143 char:33
+     'INTERVAL_SEC='" + '900' + "'",
+                                 ~~~
Unexpected token ''",
    '' in expression or statement.

At line:144 char:6
+     'mkdir -p "$BASE/out"',
+      ~~~~~
Unexpected token 'mkdir' in expression or statement.

At line:165 char:31
+   $BootSh = Join-Path $Cache '99-plexcollector.sh'
+                               ~~~~~~~~~~~~~~~~~~~~
Unexpected token '99-plexcollector.sh'
  [IO.File]::WriteAllText($BootSh, ($BootLines -join "`n"), [Text.Encoding]::ASCII)

  # ---------- Push files to UDM (non-fatal per step) ----------
  if($plink -and $pscp -and $UDM_IP){
    [void](Run-Cmd "mkdir /data paths" ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} mkdir -p /data/plexcollector /data/on_boot.d" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
    [void](Run-Cmd "push collector.sh" ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$CollectorSh,("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/collector.sh")))
    [void](Run-Cmd "push run.sh"       ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RunSh,      ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/run.sh")))
    [void](Run-Cmd "push boot hook"    ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$BootSh,     ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/on_boot.d/99-plexcollector.sh")))
    [void](Run-Cmd "chmod scripts"     ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} chmod +x /data/plexcollector/*.sh /data/on_boot.d/99-plexcollector.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
    [void](Run-Cmd "start collector"   ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} /bin/sh /data/plexcollector/run.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
  } else {
    QA "File push skipped (plink/pscp/UDM_IP missing)"
    Say "Could not push files (plink/pscp/UDM_IP missing). Mirror will still be installed." 'Yellow'
  }

  # ---------- Build Windows mirror+analyze (more robust) ----------
  $MirrorScript = Join-Path $Scripts 'udm_mirror_analyze.ps1'
  $MS=@()
  $MS += '$ErrorActionPreference="Stop"' in expression or statement.

At line:165 char:33
+   $BootSh = Join-Path $Cache '99-plexcollector.sh'
+                                 ~~~~~~~~~~~~~~
Unexpected token '-plexcollector' in expression or statement.

At line:165 char:47
+   $BootSh = Join-Path $Cache '99-plexcollector.sh'
+                                               ~~~~
Unexpected token '.sh'
  [IO.File]::WriteAllText($BootSh, ($BootLines -join "`n"), [Text.Encoding]::ASCII)

  # ---------- Push files to UDM (non-fatal per step) ----------
  if($plink -and $pscp -and $UDM_IP){
    [void](Run-Cmd "mkdir /data paths" ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} mkdir -p /data/plexcollector /data/on_boot.d" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
    [void](Run-Cmd "push collector.sh" ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$CollectorSh,("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/collector.sh")))
    [void](Run-Cmd "push run.sh"       ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RunSh,      ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/run.sh")))
    [void](Run-Cmd "push boot hook"    ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$BootSh,     ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/on_boot.d/99-plexcollector.sh")))
    [void](Run-Cmd "chmod scripts"     ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} chmod +x /data/plexcollector/*.sh /data/on_boot.d/99-plexcollector.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
    [void](Run-Cmd "start collector"   ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} /bin/sh /data/plexcollector/run.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
  } else {
    QA "File push skipped (plink/pscp/UDM_IP missing)"
    Say "Could not push files (plink/pscp/UDM_IP missing). Mirror will still be installed." 'Yellow'
  }

  # ---------- Build Windows mirror+analyze (more robust) ----------
  $MirrorScript = Join-Path $Scripts 'udm_mirror_analyze.ps1'
  $MS=@()
  $MS += '$ErrorActionPreference="Stop"' in expression or statement.

At line:192 char:11
+   $MS += '$SSH_PASS = ReadIf (Join-Path $Vault "udm_ssh_pass.txt"); i â€¦
+           ~~~~~~~~~
Unexpected token '$SSH_PASS' in expression or statement.

At line:193 char:11
+   $MS += '$UDM_IP   = ReadIf (Join-Path $Vault "udm_ip.txt")'
+           ~~~~~~~
Unexpected token '$UDM_IP' in expression or statement.

At line:202 char:11
+   $MS += '$dirs = Get-ChildItem -LiteralPath $Reports -Directory | Wh â€¦
+           ~~~~~
Unexpected token '$dirs' in expression or statement.

At line:213 char:11
+   $MS += 'Add-Content $SumPath ("Weak-RSSI clients (<-75 dBm): "+$wea â€¦
+           ~~~~~~~~~~~
Unexpected token 'Add-Content' in expression or statement.

Not all parse errors were reported.  Correct the reported errors and try again.
ParserError: 
Line |
 143 |      'INTERVAL_SEC='" + '900' + "'",
     |                     ~~~~~~~~~~~~~
     | Unexpected token '" + '900' + "' in expression or statement.

PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest

  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ try{ New-Item -ItemType Directory -Path $p -Force | Out-Null }catch{} } }
  function ReadIf($p){ if(Test-Path $p){ try{ (Get-Content -LiteralPath $p -Raw).Trim() }catch{ $null } } else { $null } }

  # ---------- QA logging ----------
  $Root='D:\PlexTools'
  $Reports=Join-Path $Root 'reports'
  Ensure-Dir $Reports
  $Stamp=Get-Date -Format 'yyyyMMdd_HHmmss'
  $QA=Join-Path $Reports ("udm_collector_install_QA_{0}.txt" -f $Stamp)
  function QA($msg){ Add-Content -LiteralPath $QA -Value ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'), $msg) }
  function Run-Cmd($label,$cmd){
    try{
      $global:LASTEXITCODE = 0
      $out = & cmd /c $cmd
      $code = $LASTEXITCODE
      if($code -ne 0){ QA "$label -> FAIL (exit $code)"; return @{ ok=$false; out=$out } }
      QA "$label -> OK"
      return @{ ok=$true; out=$out }
    }catch{
      QA "$label -> EXCEPTION: $($_.Exception.Message)"
      return @{ ok=$false; out=$null }
    }
  }

  Say "[START] UDM Collector + Mirror installer (PS5.1-safe, continue-on-error)"
  QA  "CONTINUE MODE enabled: steps will log and proceed when safe"

  # ---------- Paths & vault ----------
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $Cache=Join-Path $Root 'cache'
  $Bin=Join-Path $Root 'bin'
  $Scripts=Join-Path $Root 'Scripts'
  Ensure-Dir $Vault; Ensure-Dir $Cache; Ensure-Dir $Bin; Ensure-Dir $Scripts

  # ---------- Creds (as agreed) ----------
  try{
    $LOCAL_USER='udm_Local_api'; $LOCAL_PASS='W1ll0w1703!!'
    Set-Content (Join-Path $Vault 'udm_user.txt') $LOCAL_USER -Encoding ASCII
    Set-Content (Join-Path $Vault 'udm_pass.txt') $LOCAL_PASS -Encoding ASCII
    $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
    $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
    [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)
    QA "Saved UniFi app creds -> udm_user.txt / udm_pass(.txt/.bin)"
  }catch{ QA "Save creds -> EXCEPTION: $($_.Exception.Message)" }

  # SSH creds (device OS)
  try{
    $SSH_USER = ReadIf (Join-Path $Vault 'udm_ssh_user.txt'); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root'; Set-Content (Join-Path $Vault 'udm_ssh_user.txt') $SSH_USER -Encoding ASCII }
    $SSH_PASS = 'W1ll0w1703!!'; Set-Content (Join-Path $Vault 'udm_ssh_pass.txt') $SSH_PASS -Encoding ASCII
    QA "Saved SSH creds -> udm_ssh_user.txt / udm_ssh_pass.txt"
  }catch{ QA "Save SSH creds -> EXCEPTION: $($_.Exception.Message)" }

  # ---------- UDM IP ----------
  try{
    $UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt')
    if([string]::IsNullOrWhiteSpace($UDM_IP)){
      $gw=(Get-NetIPConfiguration|Where-Object{ $_.IPv4DefaultGateway -and $_.IPv4Address }|Select-Object -First 1)
      if($gw -and $gw.IPv4DefaultGateway){ $UDM_IP=$gw.IPv4DefaultGateway.NextHop; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII; QA "Auto-detected UDM IP -> $UDM_IP" }
    } else { QA "UDM IP from vault -> $UDM_IP" }
    if(-not $UDM_IP){ QA "UDM IP missing. Put 192.168.1.1 in $Vault\udm_ip.txt"; Say "UDM IP missing; continuing but remote steps will likely fail" 'Yellow' }
  }catch{ QA "UDM IP detect -> EXCEPTION: $($_.Exception.Message)" }

  # ---------- Ensure PuTTY tools ----------
  $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
  $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
  if(-not $plink -or -not $pscp){
    Say "Downloading PuTTY (plink/pscp)..." 'Yellow'; QA "PuTTY download starting"
    $PlinkPath = Join-Path $Bin 'plink.exe'
    $PscpPath  = Join-Path $Bin 'pscp.exe'
    try{
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe' -OutFile $PlinkPath
      Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe'  -OutFile $PscpPath
      $plink = Get-Command $PlinkPath -ErrorAction SilentlyContinue
      $pscp  = Get-Command $PscpPath  -ErrorAction SilentlyContinue
      QA "PuTTY download -> OK"
    }catch{ QA "PuTTY download -> EXCEPTION: $($_.Exception.Message)" }
  } else { QA ("PuTTY present -> plink={0} pscp={1}" -f $plink.Source,$pscp.Source) }
  if($plink){ Say ("Using plink: {0}" -f $plink.Source) 'DarkGray' }
  if($pscp){  Say ("Using pscp : {0}" -f $pscp.Source)  'DarkGray' }

  # ---------- Quick SSH reachability probe (non-fatal) ----------
  if($plink -and $UDM_IP){
    $probe = Run-Cmd "SSH probe (banner)" ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} echo ok" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP)
    if(-not $probe.ok){ Say "SSH probe failed (will still continue)" 'Yellow' }
  } else { QA "SSH probe skipped (plink or UDM_IP missing)" }

  # ---------- Build UDM on-box collector files (LF endings) ----------
  $COL_DIR='/data/plexcollector'
  $BOOT_D='/data/on_boot.d'
  $INTERVAL_SEC='900'   # 15 min
  $RETENTION_D='30'     # keep 30 days on UDM

  $CollectorLines=@(
    '#!/bin/sh',
    'TS=$(date +%Y%m%d_%H%M%S)',
    'BASE="/data/plexcollector"',
    'OUT="$BASE/out/$TS"',
    'mkdir -p "$OUT"',
    'echo "OUT=$OUT"',
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/api/auth/csrf" -o "$OUT/csrf.json" -w "%{http_code}" > "$OUT/csrf.code"',
    'TOKEN=$(sed -n ''s/.*"token":"\([^"]*\)".*/\1/p'' "$OUT/csrf.json")',
    'if [ -z "$TOKEN" ]; then TOKEN=$(awk ''/csrf_token/ {print $NF}'' "$OUT/cookie" | tail -n1); fi',
    ("UUSER='{0}'" -f $LOCAL_USER),
    ("UPASS='{0}'" -f $LOCAL_PASS),
    'LOGIN_CODE=$(curl -sk -L -o "$OUT/login.json" -w "%{http_code}" -c "$OUT/cookie" -b "$OUT/cookie" -H "Content-Type: application/json" -H "X-Csrf-Token: $TOKEN" --data "{\"username\":\"$UUSER\",\"password\":\"$UPASS\",\"rememberMe\":true}" "https://127.0.0.1/api/auth/login")',
    'echo "$LOGIN_CODE" > "$OUT/login.code"',
    'if [ "$LOGIN_CODE" != "200" ]; then echo "LOGIN_FAIL=$LOGIN_CODE" > "$OUT/status.txt"; echo "$OUT"; exit 0; fi',
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/proxy/network/api/self/sites" -o "$OUT/self_sites.json"',
    'SITE=$(sed -n ''s/.*"name":"\([^"]*\)".*/\1/p'' "$OUT/self_sites.json" | head -n1); [ -z "$SITE" ] && SITE="default"',
    'echo "SITE=$SITE" > "$OUT/status.txt"',
    'fetch(){ P="$1"; N="$2"; curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1${P}" -o "$OUT/${N}.json" -w "%{http_code}" > "$OUT/${N}.code"; }',
    'fetch "/proxy/network/api/s/$SITE/list/setting"       "list_setting"',
    'fetch "/proxy/network/api/s/$SITE/rest/networkconf"   "rest_networkconf"',
    'fetch "/proxy/network/api/s/$SITE/list/wlanconf"      "list_wlanconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/portconf"      "rest_portconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallrule"  "rest_firewallrule"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallgroup" "rest_firewallgroup"',
    'fetch "/proxy/network/api/s/$SITE/stat/device"        "stat_device"',
    'fetch "/proxy/network/api/s/$SITE/stat/sta"           "stat_sta"',
    'fetch "/proxy/network/api/s/$SITE/stat/health"        "stat_health"',
    'fetch "/proxy/network/api/s/$SITE/stat/sysinfo"       "stat_sysinfo"',
    'uname -a > "$OUT/host_uname.txt" 2>/dev/null',
    'cat /proc/loadavg > "$OUT/host_loadavg.txt" 2>/dev/null',
    'free -m > "$OUT/host_mem.txt" 2>/dev/null',
    'df -h > "$OUT/host_df.txt" 2>/dev/null',
    'ping -c 5 -W 2 1.1.1.1 > "$OUT/wan_ping_1.1.1.1.txt" 2>/dev/null || true',
    'ping -c 5 -W 2 8.8.8.8 > "$OUT/wan_ping_8.8.8.8.txt" 2>/dev/null || true',
    'echo "DONE" >> "$OUT/status.txt"',
    ("find $BASE/out -maxdepth 1 -type d -mtime +{0} -exec rm -rf {{}} +" -f $RETENTION_D),
    'echo "$OUT"'
  )
  $CollectorSh = Join-Path $Cache 'collector.sh'
  [IO.File]::WriteAllText($CollectorSh, ($CollectorLines -join "`n"), [Text.Encoding]::ASCII)

  $RunLines=@(
    '#!/bin/sh',
    'BASE="/data/plexcollector"',
    'PIDFILE="$BASE/collector.pid"',
    'INTERVAL_SEC=900',
    'mkdir -p "$BASE/out"',
    'if [ -f "$PIDFILE" ]; then',
    '  OLD=$(cat "$PIDFILE" 2>/dev/null)',
    '  if [ -n "$OLD" ] && kill -0 "$OLD" 2>/dev/null; then',
    '    echo "collector already running (pid=$OLD)"; exit 0',
    '  fi',
    'fi',
    'echo $$ > "$PIDFILE"',
    'while true; do',
    '  /bin/sh "$BASE/collector.sh" >/dev/null 2>&1 || true',
    '  sleep "$INTERVAL_SEC"',
    'done'
  )
  $RunSh = Join-Path $Cache 'run.sh'
  [IO.File]::WriteAllText($RunSh, ($RunLines -join "`n"), [Text.Encoding]::ASCII)

  $BootLines=@(
    '#!/bin/sh',
    'sleep 10',
    '/bin/sh /data/plexcollector/run.sh >/dev/null 2>&1 &'
  )
  $BootSh = Join-Path $Cache '99-plexcollector.sh'
  [IO.File]::WriteAllText($BootSh, ($BootLines -join "`n"), [Text.Encoding]::ASCII)

  # ---------- Push files to UDM (non-fatal per step) ----------
  if($plink -and $pscp -and $UDM_IP){
    [void](Run-Cmd "mkdir /data paths" ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} mkdir -p /data/plexcollector /data/on_boot.d" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
    [void](Run-Cmd "push collector.sh" ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$CollectorSh,("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/collector.sh")))
    [void](Run-Cmd "push run.sh"       ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RunSh,      ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/run.sh")))
    [void](Run-Cmd "push boot hook"    ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q `"{3}`" `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$BootSh,     ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/on_boot.d/99-plexcollector.sh")))
    [void](Run-Cmd "chmod scripts"     ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} chmod +x /data/plexcollector/*.sh /data/on_boot.d/99-plexcollector.sh" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
    # start in background so plink returns
    [void](Run-Cmd "start collector bg" ("echo y| `"{0}`" -ssh -batch -P 22 -l {1} -pw {2} {3} sh -c `"nohup /bin/sh /data/plexcollector/run.sh >/dev/null 2>&1 &`"" -f $plink.Source,$SSH_USER,$SSH_PASS,$UDM_IP))
  } else {
    QA "File push skipped (plink/pscp/UDM_IP missing)"
    Say "Could not push files (plink/pscp/UDM_IP missing). Mirror will still be installed." 'Yellow'
  }

  # ---------- Build Windows mirror+analyze (robust) ----------
  $MirrorScript = Join-Path $Scripts 'udm_mirror_analyze.ps1'
  $MS=@()
  $MS += '$ErrorActionPreference="Stop"; Set-StrictMode -Version Latest'
  $MS += 'function ReadIf($p){ if(Test-Path $p){ try{ (Get-Content -LiteralPath $p -Raw).Trim() }catch{ $null } } else { $null } }'
  $MS += '$Vault="C:\Users\jason\OneDrive\Public\TOKENS"; $Root="D:\PlexTools"; $Reports=Join-Path $Root "reports"; $Bin=Join-Path $Root "bin"'
  $MS += 'if(-not (Test-Path $Reports)){ New-Item -ItemType Directory -Path $Reports -Force | Out-Null }'
  $MS += '$Stamp=Get-Date -Format "yyyyMMdd_HHmmss"; $Log=Join-Path $Reports ("mirror_QA_"+$Stamp+".txt")'
  $MS += 'function QA($m){ Add-Content -LiteralPath $Log -Value ("[{0}] {1}" -f (Get-Date -Format "HH:mm:ss"),$m) }'
  $MS += 'QA "Mirror start"'
  $MS += '$SSH_USER = ReadIf (Join-Path $Vault "udm_ssh_user.txt"); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER="root" }'
  $MS += '$SSH_PASS = ReadIf (Join-Path $Vault "udm_ssh_pass.txt"); if([string]::IsNullOrWhiteSpace($SSH_PASS)){ $SSH_PASS="W1ll0w1703!!" }'
  $MS += '$UDM_IP   = ReadIf (Join-Path $Vault "udm_ip.txt")'
  $MS += '$plink = Get-Command (Join-Path $Bin "plink.exe") -ErrorAction SilentlyContinue'
  $MS += '$pscp  = Get-Command (Join-Path $Bin "pscp.exe")  -ErrorAction SilentlyContinue'
  $MS += 'if(-not $plink -or -not $pscp){ QA "PuTTY missing"; Write-Host "[mirror] PuTTY missing"; exit 0 }'
  $MS += 'if([string]::IsNullOrWhiteSpace($UDM_IP)){ QA "UDM_IP missing"; Write-Host "[mirror] UDM_IP missing"; exit 0 }'
  $MS += '$RemoteSpec = ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/out/*")'
  $MS += '$global:LASTEXITCODE=0'
  $MS += '$null = & cmd /c ("`"{0}`" -batch -P 22 -l {1} -pw {2} -q -r {3} `"{4}`"" -f $pscp.Source,$SSH_USER,$SSH_PASS,$RemoteSpec,$Reports)'
  $MS += '$code = $LASTEXITCODE; if($code -ne 0){ QA ("pscp pull -> FAIL ("+$code+")"); Write-Host "[mirror] pscp pull failed"; exit 0 } else { QA "pscp pull -> OK" }'
  $MS += '$dirs = Get-ChildItem -LiteralPath $Reports -Directory | Where-Object { $_.Name -match "^\d{8}_\d{6}$" } | Sort-Object Name'
  $MS += 'if(-not $dirs){ QA "no bundles yet"; Write-Host "[mirror] no bundles yet"; exit 0 }'
  $MS += '$latest = $dirs[-1].FullName'
  $MS += '$SumPath = Join-Path $Reports ("posture_"+$dirs[-1].Name+".txt")'
  $MS += 'function ReadFlex($p){ if(-not(Test-Path $p)){return @()} ; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json; if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }'
  $MS += '$WLAN = Join-Path $latest "list_wlanconf.json"; $NET = Join-Path $latest "rest_networkconf.json"; $FR=Join-Path $latest "rest_firewallrule.json"; $STA=Join-Path $latest "stat_sta.json"; $DEV=Join-Path $latest "stat_device.json"'
  $MS += '$w=ReadFlex $WLAN; $n=ReadFlex $NET; $fr=ReadFlex $FR; $st=ReadFlex $STA; $dv=ReadFlex $DEV'
  $MS += '"UDM Posture â€” "+(Get-Date) | Set-Content -LiteralPath $SumPath -Encoding UTF8'
  $MS += 'Add-Content $SumPath ("Latest bundle: "+(Split-Path $latest -Leaf))'
  $MS += 'Add-Content $SumPath ("WLANs: "+$w.Count+" | Networks: "+$n.Count+" | Firewall rules: "+$fr.Count+" | Clients: "+$st.Count+" | Devices: "+$dv.Count)'
  $MS += '$weak=0; foreach($c in $st){ if($c.PSObject.Properties["rssi"]){ try{ if([int]$c.rssi -lt -75){ $weak++ } }catch{} } }'
  $MS += 'Add-Content $SumPath ("Weak-RSSI clients (<-75 dBm): "+$weak)'
  $MS += '$aploads=@{}; foreach($c in $st){ $ap=$null; if($c.PSObject.Properties["ap_mac"]){ $ap=$c.ap_mac } elseif($c.PSObject.Properties["apMac"]){ $ap=$c.apMac } if($ap){ if(-not $aploads.ContainsKey($ap)){ $aploads[$ap]=0 }; $aploads[$ap]++ } }'
  $MS += '$over = @($aploads.GetEnumerator() | Where-Object { $_.Value -gt 25 })'
  $MS += 'Add-Content $SumPath ("Overloaded APs (>25 clients): "+$over.Count)'
  $MS += '$TopCSV = Join-Path $Reports ("top_talkers_"+(Split-Path $latest -Leaf)+".csv")'
  $MS += '$rows=@(); foreach($c in $st){'
  $MS += '  $name=$null; foreach($k in @("hostname","host_name","name","displayName","display_name","device_name","fingerprint_name","mac")){ if($c.PSObject.Properties[$k] -and $c.$k){ $name=$c.$k; break } }'
  $MS += '  if([string]::IsNullOrEmpty($name) -and $c.PSObject.Properties["mac"]){ $name=$c.mac }'
  $MS += '  $mac=$null; if($c.PSObject.Properties["mac"]){ $mac=$c.mac }'
  $MS += '  $ip=$null; foreach($k in @("ip","ip_address","ipv4","primaryIp","primary_ip")){ if($c.PSObject.Properties[$k] -and $c.$k){ $ip=$c.$k; break } }'
  $MS += '  $ssid=$null; foreach($k in @("ssid","wlan","wifi_ssid","wlan_name")){ if($c.PSObject.Properties[$k] -and $c.$k){ $ssid=$c.$k; break } }'
  $MS += '  $band=$null; foreach($k in @("radio","band","phy")){ if($c.PSObject.Properties[$k] -and $c.$k){ $band=$c.$k; break } }'
  $MS += '  $tx=0; foreach($k in @("tx_bytes","txBytes","tx_total","tx_total_bytes")){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$tx=[double]$c.$k}catch{} } }'
  $MS += '  $rx=0; foreach($k in @("rx_bytes","rxBytes","rx_total","rx_total_bytes")){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$rx=[double]$c.$k}catch{} } }'
  $MS += '  $rows += [pscustomobject]@{ name=$name; mac=$mac; ip=$ip; ssid=$ssid; band=$band; tx_bytes=$tx; rx_bytes=$rx; total_bytes=($tx+$rx) }'
  $MS += '}'
  $MS += 'if($rows.Count -gt 0){ try{ $rows | Sort-Object total_bytes -Descending | Select-Object -First 50 | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8; Add-Content $SumPath ("Top talkers -> "+$TopCSV) }catch{ QA ("Top talkers CSV -> EXCEPTION: "+$_.Exception.Message) } }'
  $MS += '# Retention 90d'
  $MS += 'try{ $cut=(Get-Date).AddDays(-90); Get-ChildItem -LiteralPath $Reports -Directory | Where-Object { $_.Name -match "^\d{8}_\d{6}$" -and $_.LastWriteTime -lt $cut } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }catch{ QA "Retention cleanup -> EXCEPTION: $($_.Exception.Message)" }'
  $MS += 'Write-Host ("[mirror] Done: "+$SumPath)'
  [IO.File]::WriteAllText($MirrorScript, ($MS -join "`n"), [Text.Encoding]::UTF8)
  QA "Mirror+Analyze script written -> $MirrorScript"
  Say ("Mirror+Analyze script -> {0}" -f $MirrorScript) 'DarkGray'

  # ---------- Scheduled Task (non-fatal) ----------
  $TaskName='UDM_Mirror_Analyze_15min'
  $ps = "powershell.exe -NoProfile -ExecutionPolicy Bypass -File `"$MirrorScript`""
  try{
    schtasks /Create /TN "$TaskName" /SC MINUTE /MO 15 /TR "$ps" /F /RL LIMITED /IT | Out-Null
    QA "Scheduled Task created/updated -> $TaskName"
    Say ("Scheduled Task -> {0} (every 15 min)" -f $TaskName) 'Green'
  }catch{
    QA ("Scheduled Task -> EXCEPTION: {0}" -f $_.Exception.Message)
    Say "Could not create scheduled task (continuing). See QA log." 'Yellow'
  }

  # ---------- First mirror run (non-fatal) ----------
  try{
    & powershell -NoProfile -ExecutionPolicy Bypass -File $MirrorScript
    QA "Manual mirror run -> attempted"
  }catch{
    QA ("Manual mirror run -> EXCEPTION: {0}" -f $_.Exception.Message)
    Say "First mirror run failed (continuing). Task will retry." 'Yellow'
  }

  Say ("[DONE] Install flow finished. QA log -> {0}" -f $QA) 'Green'
  Write-Host "Open the QA log for exact step statuses."
}

[20:51:35] [START] UDM Collector + Mirror installer (PS5.1-safe, continue-on-error)
[20:51:35] Using plink: C:\Program Files\PuTTY\plink.exe
[20:51:35] Using pscp : C:\Program Files\PuTTY\pscp.exe
[20:51:35] SSH probe failed (will still continue)
PS C:\Windows\System32> TerminatingError(): "The variable '$BASE' cannot be retrieved because it has not been set."
>> TerminatingError(): "The variable '$BASE' cannot be retrieved because it has not been set."
The variable '$BASE' cannot be retrieved because it has not been set.
InvalidOperation: 
Line |
 133 |      ("find $BASE/out -maxdepth 1 -type d -mtime +{0} -exec rm -rf {{} â€¦
     |             ~~~~~
     | The variable '$BASE' cannot be retrieved because it has not been set.
PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ try{ New-Item -ItemType Directory -Path $p -Force | Out-Null }catch{} } }
  function ReadIf($p){ if(Test-Path $p){ try{ (Get-Content -LiteralPath $p -Raw).Trim() }catch{ $null } } else { $null } }
  function QA($msg){ Add-Content -LiteralPath $QA -Value ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'), $msg) }
  function Run-Cmd($label,$cmd){
    try{ $global:LASTEXITCODE=0; $out=& cmd /c $cmd; if($LASTEXITCODE -ne 0){ QA "$label -> FAIL ($LASTEXITCODE)"; return @{ok=$false;out=$out} }; QA "$label -> OK"; return @{ok=$true;out=$out} }
    catch{ QA "$label -> EXCEPTION: $($_.Exception.Message)"; return @{ok=$false;out=$null} }
  }

  Say "[REPAIR] UDM collector: hostkey pin + find-line fix"
  $Root='D:\PlexTools'; $Reports=Join-Path $Root 'reports'; $Cache=Join-Path $Root 'cache'; $Bin=Join-Path $Root 'bin'
  Ensure-Dir $Reports; Ensure-Dir $Cache; Ensure-Dir $Bin
  $Stamp=Get-Date -Format 'yyyyMMdd_HHmmss'
  $QA=Join-Path $Reports ("udm_collector_repair_QA_{0}.txt" -f $Stamp)

  # --- Known-good values you already use ---
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $SSH_USER = (ReadIf (Join-Path $Vault 'udm_ssh_user.txt')); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root' }
  $SSH_PASS = (ReadIf (Join-Path $Vault 'udm_ssh_pass.txt')); if([string]::IsNullOrWhiteSpace($SSH_PASS)){ $SSH_PASS='W1ll0w1703!!' }
  $UDM_IP   = ReadIf (Join-Path $Vault 'udm_ip.txt'); if([string]::IsNullOrWhiteSpace($UDM_IP)){ $UDM_IP='192.168.1.1' }

  # --- Pin the server host key so PuTTY won't prompt (use the one you saw) ---
  $HOSTKEY='ssh-ed25519 255 SHA256:s7xKcN4xHXB9jLO8A00w8BuRNKO8wjcyPVGSE5MXCT0'

  # --- PuTTY tools ---
  $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
  $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
  if(-not $plink -or -not $pscp){
    QA "PuTTY missing, downloading"
    $PlinkPath = Join-Path $Bin 'plink.exe'; $PscpPath  = Join-Path $Bin 'pscp.exe'
    Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe' -OutFile $PlinkPath
    Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe'  -OutFile $PscpPath
    $plink = Get-Command $PlinkPath; $pscp = Get-Command $PscpPath
  }
  Say ("Using plink: {0}" -f $plink.Source) 'DarkGray'
  Say ("Using pscp : {0}" -f $pscp.Source)  'DarkGray'

  # --- Rebuild collector with PS-safe 'find' line (no $BASE expansion in PS) ---
  $CollectorLines=@(
    '#!/bin/sh',
    'TS=$(date +%Y%m%d_%H%M%S)',
    'BASE="/data/plexcollector"',
    'OUT="$BASE/out/$TS"',
    'mkdir -p "$OUT"',
    'echo "OUT=$OUT"',
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/api/auth/csrf" -o "$OUT/csrf.json" -w "%{http_code}" > "$OUT/csrf.code"',
    'TOKEN=$(sed -n ''s/.*"token":"\([^"]*\)".*/\1/p'' "$OUT/csrf.json")',
    'if [ -z "$TOKEN" ]; then TOKEN=$(awk ''/csrf_token/ {print $NF}'' "$OUT/cookie" | tail -n1); fi',
    ("UUSER='udm_Local_api'"),
    ("UPASS='W1ll0w1703!!'"),
    'LOGIN_CODE=$(curl -sk -L -o "$OUT/login.json" -w "%{http_code}" -c "$OUT/cookie" -b "$OUT/cookie" -H "Content-Type: application/json" -H "X-Csrf-Token: $TOKEN" --data "{\"username\":\"$UUSER\",\"password\":\"$UPASS\",\"rememberMe\":true}" "https://127.0.0.1/api/auth/login")',
    'echo "$LOGIN_CODE" > "$OUT/login.code"',
    'if [ "$LOGIN_CODE" != "200" ]; then echo "LOGIN_FAIL=$LOGIN_CODE" > "$OUT/status.txt"; echo "$OUT"; exit 0; fi',
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/proxy/network/api/self/sites" -o "$OUT/self_sites.json"',
    'SITE=$(sed -n ''s/.*"name":"\([^"]*\)".*/\1/p'' "$OUT/self_sites.json" | head -n1); [ -z "$SITE" ] && SITE="default"',
    'echo "SITE=$SITE" > "$OUT/status.txt"',
    'fetch(){ P="$1"; N="$2"; curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1${P}" -o "$OUT/${N}.json" -w "%{http_code}" > "$OUT/${N}.code"; }',
    'fetch "/proxy/network/api/s/$SITE/list/setting"       "list_setting"',
    'fetch "/proxy/network/api/s/$SITE/rest/networkconf"   "rest_networkconf"',
    'fetch "/proxy/network/api/s/$SITE/list/wlanconf"      "list_wlanconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/portconf"      "rest_portconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallrule"  "rest_firewallrule"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallgroup" "rest_firewallgroup"',
    'fetch "/proxy/network/api/s/$SITE/stat/device"        "stat_device"',
    'fetch "/proxy/network/api/s/$SITE/stat/sta"           "stat_sta"',
    'fetch "/proxy/network/api/s/$SITE/stat/health"        "stat_health"',
    'fetch "/proxy/network/api/s/$SITE/stat/sysinfo"       "stat_sysinfo"',
    'uname -a > "$OUT/host_uname.txt" 2>/dev/null',
    'cat /proc/loadavg > "$OUT/host_loadavg.txt" 2>/dev/null',
    'free -m > "$OUT/host_mem.txt" 2>/dev/null',
    'df -h > "$OUT/host_df.txt" 2>/dev/null',
    'ping -c 5 -W 2 1.1.1.1 > "$OUT/wan_ping_1.1.1.1.txt" 2>/dev/null || true',
    'ping -c 5 -W 2 8.8.8.8 > "$OUT/wan_ping_8.8.8.8.txt" 2>/dev/null || true',
    'echo "DONE" >> "$OUT/status.txt"',
    # NOTE: avoid PS expanding $BASE by concatenating strings in PS
    ('find $BASE/out -maxdepth 1 -type d -mtime +' + '30' + ' -exec rm -rf {} +'),
    'echo "$OUT"'
  )
  $RunLines=@(
    '#!/bin/sh',
    'BASE="/data/plexcollector"',
    'PIDFILE="$BASE/collector.pid"',
    'INTERVAL_SEC=900',
    'mkdir -p "$BASE/out"',
    'if [ -f "$PIDFILE" ]; then',
    '  OLD=$(cat "$PIDFILE" 2>/dev/null)',
    '  if [ -n "$OLD" ] && kill -0 "$OLD" 2>/dev/null; then',
    '    echo "collector already running (pid=$OLD)"; exit 0',
    '  fi',
    'fi',
    'echo $$ > "$PIDFILE"',
    'while true; do',
    '  /bin/sh "$BASE/collector.sh" >/dev/null 2>&1 || true',
    '  sleep "$INTERVAL_SEC"',
    'done'
  )
  $BootLines=@('#!/bin/sh','sleep 10','/bin/sh /data/plexcollector/run.sh >/dev/null 2>&1 &')

  $CollectorSh = Join-Path $Cache 'collector.sh'
  $RunSh       = Join-Path $Cache 'run.sh'
  $BootSh      = Join-Path $Cache '99-plexcollector.sh'
  [IO.File]::WriteAllText($CollectorSh, ($CollectorLines -join "`n"), [Text.Encoding]::ASCII)
  [IO.File]::WriteAllText($RunSh,       ($RunLines       -join "`n"), [Text.Encoding]::ASCII)
  [IO.File]::WriteAllText($BootSh,      ($BootLines      -join "`n"), [Text.Encoding]::ASCII)

  # --- Push & start using pinned hostkey (no prompts) ---
  $SshMk  = ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} mkdir -p /data/plexcollector /data/on_boot.d" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)
  $Scp1   = ("`"{0}`" -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} -q `"{4}`" `"{5}`"" -f $pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$CollectorSh,("$SSH_USER@$UDM_IP:/data/plexcollector/collector.sh"))
  $Scp2   = ("`"{0}`" -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} -q `"{4}`" `"{5}`"" -f $pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$RunSh,      ("$SSH_USER@$UDM_IP:/data/plexcollector/run.sh"))
  $Scp3   = ("`"{0}`" -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} -q `"{4}`" `"{5}`"" -f $pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$BootSh,     ("$SSH_USER@$UDM_IP:/data/on_boot.d/99-plexcollector.sh"))
  $SshCh  = ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} chmod +x /data/plexcollector/*.sh /data/on_boot.d/99-plexcollector.sh" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)
  $SshRun = ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} sh -c `"/bin/sh /data/plexcollector/run.sh >/dev/null 2>&1 &`"" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)
  [void](Run-Cmd "mkdir paths" $SshMk)
  [void](Run-Cmd "push collector.sh" $Scp1)
  [void](Run-Cmd "push run.sh" $Scp2)
  [void](Run-Cmd "push boot hook" $Scp3)
  [void](Run-Cmd "chmod scripts" $SshCh)
  [void](Run-Cmd "start collector (bg)" $SshRun)

  # --- Optional: run once now to create first bundle, then pull to Reports ---
  $SshOnce = ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} /bin/sh /data/plexcollector/collector.sh" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)
  [void](Run-Cmd "one-shot collector" $SshOnce)
  $PullAll = ("`"{0}`" -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} -q -r {4} `"{5}`"" -f $pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,("$SSH_USER@$UDM_IP:/data/plexcollector/out/*"),$Reports)
  [void](Run-Cmd "mirror bundles" $PullAll)

  Say ("[REPAIR DONE] QA log -> {0}" -f $QA) 'Green'
  Write-Host "If any step shows FAIL in the QA log, paste that line back here."
}

At line:110 char:158
+ â€¦ HOSTKEY,$SSH_USER,$SSH_PASS,$CollectorSh,("$SSH_USER@$UDM_IP:/data/pl â€¦
+                                                        ~~~~~~~~
Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.

At line:111 char:158
+ â€¦ HOSTKEY,$SSH_USER,$SSH_PASS,$RunSh,      ("$SSH_USER@$UDM_IP:/data/pl â€¦
+                                                        ~~~~~~~~
Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.

At line:112 char:158
+ â€¦ HOSTKEY,$SSH_USER,$SSH_PASS,$BootSh,     ("$SSH_USER@$UDM_IP:/data/on â€¦
+                                                        ~~~~~~~~
Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.

At line:125 char:145
+ â€¦ pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,("$SSH_USER@$UDM_IP:/data/pl â€¦
+                                                        ~~~~~~~~
Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.
ParserError: 
Line |
 110 |  â€¦ HOSTKEY,$SSH_USER,$SSH_PASS,$CollectorSh,("$SSH_USER@$UDM_IP:/data/pl â€¦
     |                                                         ~~~~~~~~
     | Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.

PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ try{ New-Item -ItemType Directory -Path $p -Force | Out-Null }catch{} } }
  function ReadIf($p){ if(Test-Path $p){ try{ (Get-Content -LiteralPath $p -Raw).Trim() }catch{ $null } } else { $null } }
  function Run-Cmd($label,$cmd){
    try{ $global:LASTEXITCODE=0; $out=& cmd /c $cmd; $code=$LASTEXITCODE
      [pscustomobject]@{ Label=$label; Ok=($code -eq 0); Code=$code; Out=$out }
    }catch{ [pscustomobject]@{ Label=$label; Ok=$false; Code=-1; Out=$_.Exception.Message } }
  }

  Say "[VERIFY] UDM collector: logs + on-box bundle + mirror + posture"

  # Paths
  $Root='D:\PlexTools'
  $Reports=Join-Path $Root 'reports'
  $Bin=Join-Path $Root 'bin'
  Ensure-Dir $Reports; Ensure-Dir $Bin

  # Vault / creds
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $SSH_USER = ReadIf (Join-Path $Vault 'udm_ssh_user.txt'); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root' }
  $SSH_PASS = ReadIf (Join-Path $Vault 'udm_ssh_pass.txt'); if([string]::IsNullOrWhiteSpace($SSH_PASS)){ $SSH_PASS='W1ll0w1703!!' }
  $UDM_IP   = ReadIf (Join-Path $Vault 'udm_ip.txt'); if([string]::IsNullOrWhiteSpace($UDM_IP)){ $UDM_IP='192.168.1.1' }

  # Host key you saw earlier (adjust if it ever changes)
  $HOSTKEY='ssh-ed25519 255 SHA256:s7xKcN4xHXB9jLO8A00w8BuRNKO8wjcyPVGSE5MXCT0'

  # PuTTY tools
  $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
  $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
  if(-not $plink -or -not $pscp){
    Say "PuTTY not found in PATH; looking under D:\PlexTools\bin..." 'Yellow'
    $plink = Get-Command (Join-Path $Bin 'plink.exe') -ErrorAction SilentlyContinue
    $pscp  = Get-Command (Join-Path $Bin 'pscp.exe')  -ErrorAction SilentlyContinue
    if(-not $plink -or -not $pscp){ throw "plink/pscp not found. Install PuTTY or run the installer block again." }
  }
  Say ("Using plink: {0}" -f $plink.Source) 'DarkGray'
  Say ("Using pscp : {0}" -f $pscp.Source)  'DarkGray'

  # --- 1) QA LOG SCAN ---
  $qaFiles = Get-ChildItem -LiteralPath $Reports -File |
    Where-Object { $_.Name -match '^udm_collector_(install|repair)_QA_\d{8}_\d{6}\.txt$' } |
    Sort-Object LastWriteTime -Descending
  if($qaFiles){
    $qaLatest = $qaFiles[0].FullName
    Say ("QA log -> {0}" -f $qaLatest) 'DarkGray'
    $lines = Get-Content -LiteralPath $qaLatest
    $bad = $lines | Where-Object { $_ -match 'FAIL|EXCEPTION' }
    if($bad){ Write-Host "â€” QA FAILURES â€”" -ForegroundColor Yellow; $bad | ForEach-Object { Write-Host $_ -ForegroundColor Yellow } }
    else { Write-Host "QA log shows no FAIL/EXCEPTION lines." -ForegroundColor Green }
  } else {
    Write-Host "No installer/repair QA logs found (skipping scan)." -ForegroundColor Yellow
  }

  # --- 2) ON-BOX CHECKS (no prompts; pinned hostkey) ---
  $cmdListOut = ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} sh -lc `"" +
                 "ls -ld /data/plexcollector; echo '---'; ls -ld /data/on_boot.d; echo '---'; " +
                 "ls -1 /data/plexcollector/out 2>/dev/null | tail -n 3" + "`"" ) -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP
  $r1 = Run-Cmd "on-box ls" $cmdListOut
  Write-Host ("on-box ls -> " + ($(if($r1.Ok){'OK'}else{'FAIL ' + $r1.Code})))
  $r1.Out | ForEach-Object { Write-Host $_ }

  # Grab latest bundle dir name from output tail
  $lastDir=$null
  if($r1.Ok -and $r1.Out){
    $tail = @($r1.Out | Select-Object -Last 3)
    foreach($t in $tail){ if($t -match '^\d{8}_\d{6}$'){ $lastDir=$t; break } }
  }

  # If we have a bundle dir, show login/status
  if($lastDir){
    $cmdShow = ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} sh -lc `"" +
                "for f in login.code status.txt; do echo '---'$f; cat /data/plexcollector/out/{5}/$f 2>/dev/null || true; done" + "`"" ) -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP,$lastDir
    $r2 = Run-Cmd "on-box show login/status" $cmdShow
    Write-Host ("on-box show -> " + ($(if($r2.Ok){'OK'}else{'FAIL ' + $r2.Code})))
    $r2.Out | ForEach-Object { Write-Host $_ }
  } else {
    Write-Host "No bundle dirs listed yet. The background collector may need a minute to create the first bundle." -ForegroundColor Yellow
  }

  # --- 3) MIRROR LATEST + QUICK POSTURE ---
  $RemoteSpec = ("{0}@{1}:{2}" -f $SSH_USER,$UDM_IP,"/data/plexcollector/out/*")
  $pull = ("`"{0}`" -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} -q -r {4} `"{5}`"" ) -f $pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$RemoteSpec,$Reports
  $r3 = Run-Cmd "mirror pscp" $pull
  Write-Host ("mirror -> " + ($(if($r3.Ok){'OK'}else{'FAIL ' + $r3.Code})))

  # Find newest pulled bundle dir and summarize
  $dirs = Get-ChildItem -LiteralPath $Reports -Directory | Where-Object { $_.Name -match '^\d{8}_\d{6}$' } | Sort-Object Name
  if(-not $dirs){ Write-Host "No mirrored bundles found in $Reports yet." -ForegroundColor Yellow; return }
  $latest = $dirs[-1].FullName
  Write-Host ("latest bundle -> " + $latest) -ForegroundColor DarkGray

  function ReadFlex($p){ if(-not(Test-Path $p)){return @()} ; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json; if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }
  $STA = ReadFlex (Join-Path $latest 'stat_sta.json')
  $DEV = ReadFlex (Join-Path $latest 'stat_device.json')
  $WLAN= ReadFlex (Join-Path $latest 'list_wlanconf.json')
  $NET = ReadFlex (Join-Path $latest 'rest_networkconf.json')
  $FR  = ReadFlex (Join-Path $latest 'rest_firewallrule.json')

  $weak=0; foreach($c in $STA){ if($c.PSObject.Properties['rssi']){ try{ if([int]$c.rssi -lt -75){ $weak++ } }catch{} } }
  Write-Host ("Summary: clients={0} devices={1} wlans={2} networks={3} fw_rules={4} weak_rssi={5}" -f $STA.Count,$DEV.Count,$WLAN.Count,$NET.Count,$FR.Count,$weak) -ForegroundColor Green

  # Top talkers CSV
  $TopCSV = Join-Path $Reports ("top_talkers_"+(Split-Path $latest -Leaf)+".csv")
  try{
    $rows=@()
    foreach($c in $STA){
      $name=$null; foreach($k in @('hostname','host_name','name','displayName','display_name','device_name','fingerprint_name','mac')){ if($c.PSObject.Properties[$k] -and $c.$k){ $name=$c.$k; break } }
      if([string]::IsNullOrEmpty($name) -and $c.PSObject.Properties['mac']){ $name=$c.mac }
      $mac=$null; if($c.PSObject.Properties['mac']){ $mac=$c.mac }
      $ip=$null; foreach($k in @('ip','ip_address','ipv4','primaryIp','primary_ip')){ if($c.PSObject.Properties[$k] -and $c.$k){ $ip=$c.$k; break } }
      $ssid=$null; foreach($k in @('ssid','wlan','wifi_ssid','wlan_name')){ if($c.PSObject.Properties[$k] -and $c.$k){ $ssid=$c.$k; break } }
      $band=$null; foreach($k in @('radio','band','phy')){ if($c.PSObject.Properties[$k] -and $c.$k){ $band=$c.$k; break } }
      $tx=0; foreach($k in @('tx_bytes','txBytes','tx_total','tx_total_bytes')){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$tx=[double]$c.$k}catch{} } }
      $rx=0; foreach($k in @('rx_bytes','rxBytes','rx_total','rx_total_bytes')){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$rx=[double]$c.$k}catch{} } }
      $rows += [pscustomobject]@{ name=$name; mac=$mac; ip=$ip; ssid=$ssid; band=$band; tx_bytes=$tx; rx_bytes=$rx; total_bytes=($tx+$rx) }
    }
    if($rows.Count -gt 0){
      $rows | Sort-Object total_bytes -Descending | Select-Object -First 50 | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8
      Write-Host ("Top talkers -> " + $TopCSV) -ForegroundColor DarkGray
    }
  }catch{ Write-Host ("Top talkers CSV error: "+$_.Exception.Message) -ForegroundColor Yellow }
}

[21:27:50] [VERIFY] UDM collector: logs + on-box bundle + mirror + posture
[21:27:50] Using plink: C:\Program Files\PuTTY\plink.exe
[21:27:50] Using pscp : C:\Program Files\PuTTY\pscp.exe
[21:27:51] QA log -> D:\PlexTools\reports\udm_collector_install_QA_20251007_205135.txt
â€” QA FAILURES â€”
[20:51:35] SSH probe (banner) -> FAIL (exit 1)
on-box ls -> OK
---
---
No bundle dirs listed yet. The background collector may need a minute to create the first bundle.
mirror -> FAIL 1
No mirrored bundles found in D:\PlexTools\reports yet.
PS C:\Windows\System32> cls
PS C:\Windows\System32> &{
  $ErrorActionPreference='Stop'; Set-StrictMode -Version Latest
  function Say($m,$c='Cyan'){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'HH:mm:ss'),$m) -ForegroundColor $c }
  function Ensure-Dir($p){ if(-not(Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p -Force | Out-Null } }
  function ReadIf($p){ if(Test-Path $p){ try{ (Get-Content -LiteralPath $p -Raw).Trim() }catch{ $null } } else { $null } }
  function RunCmd($cmd){ $global:LASTEXITCODE=0; $out = & cmd /c $cmd; [pscustomobject]@{ Out=$out; Code=$LASTEXITCODE } }

  Say "[INSTALL] UDM SSH collector + Windows scheduler (PS5.1-safe)"

  # --- Paths ---
  $Vault='C:\Users\jason\OneDrive\Public\TOKENS'
  $Root='D:\PlexTools'
  $Reports=Join-Path $Root 'reports'
  $Cache=Join-Path $Root 'cache'
  $Bin=Join-Path $Root 'bin'
  $Scripts=Join-Path $Root 'Scripts'
  Ensure-Dir $Vault; Ensure-Dir $Reports; Ensure-Dir $Cache; Ensure-Dir $Bin; Ensure-Dir $Scripts

  # --- Creds you gave me ---
  $LOCAL_USER='udm_Local_api'
  $LOCAL_PASS='W1ll0w1703!!'
  Set-Content (Join-Path $Vault 'udm_user.txt') $LOCAL_USER -Encoding ASCII
  Set-Content (Join-Path $Vault 'udm_pass.txt') $LOCAL_PASS -Encoding ASCII
  $bytes=[Text.Encoding]::UTF8.GetBytes($LOCAL_PASS)
  $enc=[Security.Cryptography.ProtectedData]::Protect($bytes,$null,[Security.Cryptography.DataProtectionScope]::CurrentUser)
  [IO.File]::WriteAllBytes((Join-Path $Vault 'udm_pass.bin'),$enc)

  # --- SSH creds (device OS) ---
  $SSH_USER = ReadIf (Join-Path $Vault 'udm_ssh_user.txt'); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER='root'; Set-Content (Join-Path $Vault 'udm_ssh_user.txt') $SSH_USER -Encoding ASCII }
  $SSH_PASS = ReadIf (Join-Path $Vault 'udm_ssh_pass.txt'); if([string]::IsNullOrWhiteSpace($SSH_PASS)){ $SSH_PASS='W1ll0w1703!!'; Set-Content (Join-Path $Vault 'udm_ssh_pass.txt') $SSH_PASS -Encoding ASCII }

  # --- Host/IP + hostkey ---
  $UDM_IP = ReadIf (Join-Path $Vault 'udm_ip.txt'); if([string]::IsNullOrWhiteSpace($UDM_IP)){ $UDM_IP='192.168.1.1'; Set-Content (Join-Path $Vault 'udm_ip.txt') $UDM_IP -Encoding ASCII }
  $HOSTKEY='ssh-ed25519 255 SHA256:s7xKcN4xHXB9jLO8A00w8BuRNKO8wjcyPVGSE5MXCT0'  # update if PuTTY shows a different fingerprint

  # --- Putty tools ---
  $plink = Get-Command plink.exe -ErrorAction SilentlyContinue
  $pscp  = Get-Command pscp.exe  -ErrorAction SilentlyContinue
  if(-not $plink -or -not $pscp){
    Say "PuTTY not found; downloading..." 'Yellow'
    $PlinkPath = Join-Path $Bin 'plink.exe'
    $PscpPath  = Join-Path $Bin 'pscp.exe'
    Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe' -OutFile $PlinkPath
    Invoke-WebRequest -UseBasicParsing -Uri 'https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe'  -OutFile $PscpPath
    $plink = Get-Command $PlinkPath; $pscp = Get-Command $PscpPath
  }
  Say ("Using plink: {0}" -f $plink.Source) 'DarkGray'
  Say ("Using pscp : {0}" -f $pscp.Source)  'DarkGray'

  # --- Probe SSH (tell you if auth/hostkey mismatches) ---
  $Probe = RunCmd ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} echo ok" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)
  if($Probe.Code -ne 0){
    Write-Host "[SSH] Could not log in non-interactively." -ForegroundColor Yellow
    Write-Host " - Check: Settings > System > Advanced > Enable SSH (username is 'root', password is your device SSH password)." -ForegroundColor Yellow
    Write-Host " - If PuTTY prints a NEW fingerprint, replace HOSTKEY in this block and re-run." -ForegroundColor Yellow
    return
  }

  # --- Build collector.sh (no 'set -e', no PS-here-strings) ---
  $CollectorLines=@(
    '#!/bin/sh',
    'TS=$(date +%Y%m%d_%H%M%S)',
    'BASE="/data/plexcollector"',
    'OUT="$BASE/out/$TS"',
    'mkdir -p "$OUT"',
    'echo "OUT=$OUT"',
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/api/auth/csrf" -o "$OUT/csrf.json" -w "%{http_code}" > "$OUT/csrf.code"',
    'TOKEN=$(sed -n ''s/.*"token":"\([^"]*\)".*/\1/p'' "$OUT/csrf.json")',
    'if [ -z "$TOKEN" ]; then TOKEN=$(awk ''/csrf_token/ {print $NF}'' "$OUT/cookie" | tail -n1); fi',
    ("UUSER='{0}'" -f $LOCAL_USER),
    ("UPASS='{0}'" -f $LOCAL_PASS),
    'LOGIN_CODE=$(curl -sk -L -o "$OUT/login.json" -w "%{http_code}" -c "$OUT/cookie" -b "$OUT/cookie" -H "Content-Type: application/json" -H "X-Csrf-Token: $TOKEN" --data "{\"username\":\"$UUSER\",\"password\":\"$UPASS\",\"rememberMe\":true}" "https://127.0.0.1/api/auth/login")',
    'echo "$LOGIN_CODE" > "$OUT/login.code"',
    'if [ "$LOGIN_CODE" != "200" ]; then echo "LOGIN_FAIL=$LOGIN_CODE" > "$OUT/status.txt"; echo "$OUT"; exit 0; fi',
    'curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1/proxy/network/api/self/sites" -o "$OUT/self_sites.json"',
    'SITE=$(sed -n ''s/.*"name":"\([^"]*\)".*/\1/p'' "$OUT/self_sites.json" | head -n1); [ -z "$SITE" ] && SITE="default"',
    'echo "SITE=$SITE" > "$OUT/status.txt"',
    'fetch(){ P="$1"; N="$2"; curl -sk -c "$OUT/cookie" -b "$OUT/cookie" "https://127.0.0.1${P}" -o "$OUT/${N}.json" -w "%{http_code}" > "$OUT/${N}.code"; }',
    'fetch "/proxy/network/api/s/$SITE/list/setting"       "list_setting"',
    'fetch "/proxy/network/api/s/$SITE/rest/networkconf"   "rest_networkconf"',
    'fetch "/proxy/network/api/s/$SITE/list/wlanconf"      "list_wlanconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/portconf"      "rest_portconf"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallrule"  "rest_firewallrule"',
    'fetch "/proxy/network/api/s/$SITE/rest/firewallgroup" "rest_firewallgroup"',
    'fetch "/proxy/network/api/s/$SITE/stat/device"        "stat_device"',
    'fetch "/proxy/network/api/s/$SITE/stat/sta"           "stat_sta"',
    'fetch "/proxy/network/api/s/$SITE/stat/health"        "stat_health"',
    'fetch "/proxy/network/api/s/$SITE/stat/sysinfo"       "stat_sysinfo"',
    'uname -a > "$OUT/host_uname.txt" 2>/dev/null',
    'cat /proc/loadavg > "$OUT/host_loadavg.txt" 2>/dev/null',
    'free -m > "$OUT/host_mem.txt" 2>/dev/null',
    'df -h > "$OUT/host_df.txt" 2>/dev/null',
    'ping -c 5 -W 2 1.1.1.1 > "$OUT/wan_ping_1.1.1.1.txt" 2>/dev/null || true',
    'ping -c 5 -W 2 8.8.8.8 > "$OUT/wan_ping_8.8.8.8.txt" 2>/dev/null || true',
    'echo "DONE" >> "$OUT/status.txt"',
    ('find $BASE/out -maxdepth 1 -type d -mtime +' + '30' + ' -exec rm -rf {} +'),
    'echo "$OUT"'
  )
  $CollectorSh = Join-Path $Cache 'collector.sh'
  [IO.File]::WriteAllText($CollectorSh, ($CollectorLines -join "`n"), [Text.Encoding]::ASCII)

  # --- Push to UDM ---
  $mk = RunCmd ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} mkdir -p /data/plexcollector /data/plexcollector/out" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)
  $up = RunCmd ("`"{0}`" -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} -q `"{4}`" `"{5}`"" -f $pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$CollectorSh,("$SSH_USER@$UDM_IP:/data/plexcollector/collector.sh"))
  $ch = RunCmd ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} chmod +x /data/plexcollector/collector.sh" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)
  if($mk.Code -ne 0 -or $up.Code -ne 0 -or $ch.Code -ne 0){ Say "Push/chmod failed; aborting." 'Red'; return }

  # --- Run once now, then discover newest OUT dir ---
  $run = RunCmd ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} /bin/sh /data/plexcollector/collector.sh" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)
  if($run.Code -ne 0){ Say "Collector run failed. (SSH ok but script error). We can print remote logs on request." 'Yellow' }

  $last = RunCmd ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} sh -lc `"ls -1 /data/plexcollector/out 2>/dev/null | tail -n 1`"" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)
  $LastDir = $null; if($last.Code -eq 0 -and $last.Out){ $LastDir = ($last.Out | Select-Object -Last 1).Trim() }
  if([string]::IsNullOrWhiteSpace($LastDir)){ Say "No bundle dir yet (the login may have failed on-box). We'll still set up the Windows scheduler." 'Yellow' }

  # --- Mirror all bundles to Reports ---
  $Pull = RunCmd ("`"{0}`" -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} -q -r {4} `"{5}`"" -f $pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,("$SSH_USER@$UDM_IP:/data/plexcollector/out/*"),$Reports)
  if($Pull.Code -ne 0){ Say "Mirror failed (nothing to copy yet is common on first run)." 'Yellow' }

  # --- Summarize the newest local bundle (if present) ---
  $dirs = Get-ChildItem -LiteralPath $Reports -Directory | Where-Object { $_.Name -match '^\d{8}_\d{6}$' } | Sort-Object Name
  if($dirs){
    $latest = $dirs[-1].FullName
    function ReadFlex($p){ if(-not(Test-Path $p)){return @()} ; try{ $j=Get-Content -LiteralPath $p -Raw|ConvertFrom-Json; if($j -eq $null){@()} elseif($j.data){@($j.data)} elseif($j.items){@($j.items)} elseif($j -is [System.Collections.IEnumerable] -and -not ($j -is [string])){@($j)} else {@($j)} }catch{@()} }
    $STA = ReadFlex (Join-Path $latest 'stat_sta.json')
    $DEV = ReadFlex (Join-Path $latest 'stat_device.json')
    $WLAN= ReadFlex (Join-Path $latest 'list_wlanconf.json')
    $NET = ReadFlex (Join-Path $latest 'rest_networkconf.json')
    $FR  = ReadFlex (Join-Path $latest 'rest_firewallrule.json')
    $weak=0; foreach($c in $STA){ if($c.PSObject.Properties['rssi']){ try{ if([int]$c.rssi -lt -75){ $weak++ } }catch{} } }
    Say ("Summary: clients={0} devices={1} wlans={2} networks={3} fw_rules={4} weak_rssi={5}" -f $STA.Count,$DEV.Count,$WLAN.Count,$NET.Count,$FR.Count,$weak) 'Green'

    # Export top talkers CSV
    $TopCSV = Join-Path $Reports ("top_talkers_"+(Split-Path $latest -Leaf)+".csv")
    try{
      $rows=@()
      foreach($c in $STA){
        $name=$null; foreach($k in @('hostname','host_name','name','displayName','display_name','device_name','fingerprint_name','mac')){ if($c.PSObject.Properties[$k] -and $c.$k){ $name=$c.$k; break } }
        if([string]::IsNullOrEmpty($name) -and $c.PSObject.Properties['mac']){ $name=$c.mac }
        $mac=$null; if($c.PSObject.Properties['mac']){ $mac=$c.mac }
        $ip=$null; foreach($k in @('ip','ip_address','ipv4','primaryIp','primary_ip')){ if($c.PSObject.Properties[$k] -and $c.$k){ $ip=$c.$k; break } }
        $ssid=$null; foreach($k in @('ssid','wlan','wifi_ssid','wlan_name')){ if($c.PSObject.Properties[$k] -and $c.$k){ $ssid=$c.$k; break } }
        $band=$null; foreach($k in @('radio','band','phy')){ if($c.PSObject.Properties[$k] -and $c.$k){ $band=$c.$k; break } }
        $tx=0; foreach($k in @('tx_bytes','txBytes','tx_total','tx_total_bytes')){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$tx=[double]$c.$k}catch{} } }
        $rx=0; foreach($k in @('rx_bytes','rxBytes','rx_total','rx_total_bytes')){ if($c.PSObject.Properties[$k] -and $c.$k -ne $null){ try{$rx=[double]$c.$k}catch{} } }
        $rows += [pscustomobject]@{ name=$name; mac=$mac; ip=$ip; ssid=$ssid; band=$band; tx_bytes=$tx; rx_bytes=$rx; total_bytes=($tx+$rx) }
      }
      if($rows.Count -gt 0){
        $rows | Sort-Object total_bytes -Descending | Select-Object -First 50 | Export-Csv -LiteralPath $TopCSV -NoTypeInformation -Encoding UTF8
        Say ("Top talkers -> {0}" -f $TopCSV) 'DarkGray'
      }
    }catch{ Say ("Top talkers CSV error: "+$_.Exception.Message) 'Yellow' }
  } else {
    Say "No local bundles yet (first run may have produced an auth 401 on-box). Scheduler will retry." 'Yellow'
  }

  # --- Create scheduler that repeats run+mirror every 15 minutes ---
  $Runner = Join-Path $Scripts 'udm_collect_and_mirror.ps1'
  $L=@()
  $L += '$ErrorActionPreference="Stop"; Set-StrictMode -Version Latest'
  $L += '$Vault="C:\Users\jason\OneDrive\Public\TOKENS"; $Root="D:\PlexTools"; $Reports=Join-Path $Root "reports"; $Bin=Join-Path $Root "bin"'
  $L += 'function ReadIf($p){ if(Test-Path $p){ (Get-Content -LiteralPath $p -Raw).Trim() } else { $null } }'
  $L += '$SSH_USER=ReadIf (Join-Path $Vault "udm_ssh_user.txt"); if([string]::IsNullOrWhiteSpace($SSH_USER)){ $SSH_USER="root" }'
  $L += '$SSH_PASS=ReadIf (Join-Path $Vault "udm_ssh_pass.txt"); if([string]::IsNullOrWhiteSpace($SSH_PASS)){ $SSH_PASS="W1ll0w1703!!" }'
  $L += '$UDM_IP  =ReadIf (Join-Path $Vault "udm_ip.txt"); if([string]::IsNullOrWhiteSpace($UDM_IP)){ $UDM_IP="192.168.1.1" }'
  $L += '$HOSTKEY="ssh-ed25519 255 SHA256:s7xKcN4xHXB9jLO8A00w8BuRNKO8wjcyPVGSE5MXCT0"'
  $L += '$plink = Get-Command (Join-Path $Bin "plink.exe"); $pscp = Get-Command (Join-Path $Bin "pscp.exe")'
  $L += '$null = & cmd /c ("`"{0}`" -ssh -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} {4} /bin/sh /data/plexcollector/collector.sh" -f $plink.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,$UDM_IP)'
  $L += '$null = & cmd /c ("`"{0}`" -batch -hostkey `"{1}`" -P 22 -l {2} -pw {3} -q -r {4} `"{5}`"" -f $pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,("$SSH_USER@$UDM_IP:/data/plexcollector/out/*"),$Reports)'
  [IO.File]::WriteAllText($Runner, ($L -join "`n"), [Text.Encoding]::UTF8)
  $TaskName='UDM_Collector_15min'
  $ps = "powershell.exe -NoProfile -ExecutionPolicy Bypass -File `"$Runner`""
  schtasks /Create /TN "$TaskName" /SC MINUTE /MO 15 /TR "$ps" /F /RL LIMITED /IT | Out-Null
  Say ("Scheduled Task -> {0} (every 15 min)" -f $TaskName) 'Green'

  Say "[DONE] First run attempted; scheduler installed. If SSH auth worked, a bundle folder like 2025xxxxx_xxxxxx will appear under D:\PlexTools\reports." 'Green'
}

At line:104 char:161
+ â€¦ HOSTKEY,$SSH_USER,$SSH_PASS,$CollectorSh,("$SSH_USER@$UDM_IP:/data/pl â€¦
+                                                        ~~~~~~~~
Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.

At line:117 char:149
+ â€¦ pscp.Source,$HOSTKEY,$SSH_USER,$SSH_PASS,("$SSH_USER@$UDM_IP:/data/pl â€¦
+                                                        ~~~~~~~~
Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.
ParserError: 
Line |
 104 |  â€¦ HOSTKEY,$SSH_USER,$SSH_PASS,$CollectorSh,("$SSH_USER@$UDM_IP:/data/pl â€¦
     |                                                         ~~~~~~~~
     | Variable reference is not valid. ':' was not followed by a valid variable name character. Consider using ${} to delimit the name.

